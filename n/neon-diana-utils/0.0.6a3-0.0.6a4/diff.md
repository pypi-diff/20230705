# Comparing `tmp/neon_diana_utils-0.0.6a3-py3-none-any.whl.zip` & `tmp/neon_diana_utils-0.0.6a4-py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,25 +1,25 @@
-Zip file size: 32648 bytes, number of entries: 23
--rw-r--r--  2.0 unx     1685 b- defN 22-Apr-11 21:45 neon_diana_utils/__init__.py
--rw-r--r--  2.0 unx    10951 b- defN 22-Apr-11 21:45 neon_diana_utils/cli.py
--rw-r--r--  2.0 unx     3213 b- defN 22-Apr-11 21:45 neon_diana_utils/constants.py
--rw-r--r--  2.0 unx     6085 b- defN 22-Apr-11 21:45 neon_diana_utils/rabbitmq_api.py
--rw-r--r--  2.0 unx     1856 b- defN 22-Apr-11 21:45 neon_diana_utils/version.py
--rw-r--r--  2.0 unx      419 b- defN 22-Apr-11 21:45 neon_diana_utils/templates/docker-compose.yml
--rw-r--r--  2.0 unx       60 b- defN 22-Apr-11 21:45 neon_diana_utils/templates/k8s_config_map.yml
--rw-r--r--  2.0 unx     4971 b- defN 22-Apr-11 21:45 neon_diana_utils/templates/k8s_ingress_nginx_mq.yml
--rw-r--r--  2.0 unx     1546 b- defN 22-Apr-11 21:45 neon_diana_utils/templates/k8s_nfs_volume.yml
--rw-r--r--  2.0 unx       76 b- defN 22-Apr-11 21:45 neon_diana_utils/templates/k8s_secret.yml
--rw-r--r--  2.0 unx      170 b- defN 22-Apr-11 21:45 neon_diana_utils/templates/kubernetes.yml
--rw-r--r--  2.0 unx    23471 b- defN 22-Apr-11 21:45 neon_diana_utils/templates/service_mappings.yml
--rw-r--r--  2.0 unx     1685 b- defN 22-Apr-11 21:45 neon_diana_utils/utils/__init__.py
--rw-r--r--  2.0 unx    17316 b- defN 22-Apr-11 21:45 neon_diana_utils/utils/backend.py
--rw-r--r--  2.0 unx     5180 b- defN 22-Apr-11 21:45 neon_diana_utils/utils/docker_utils.py
--rw-r--r--  2.0 unx     9058 b- defN 22-Apr-11 21:45 neon_diana_utils/utils/kubernetes_utils.py
--rw-r--r--  2.0 unx     1626 b- defN 22-Apr-11 21:45 neon_diana_utils-0.0.6a3.dist-info/LICENSE.md
--rw-r--r--  2.0 unx    10279 b- defN 22-Apr-11 21:45 neon_diana_utils-0.0.6a3.dist-info/METADATA
--rw-r--r--  2.0 unx       92 b- defN 22-Apr-11 21:45 neon_diana_utils-0.0.6a3.dist-info/WHEEL
--rw-r--r--  2.0 unx       63 b- defN 22-Apr-11 21:45 neon_diana_utils-0.0.6a3.dist-info/entry_points.txt
--rw-r--r--  2.0 unx       17 b- defN 22-Apr-11 21:45 neon_diana_utils-0.0.6a3.dist-info/top_level.txt
--rw-r--r--  2.0 unx        1 b- defN 22-Apr-11 21:45 neon_diana_utils-0.0.6a3.dist-info/zip-safe
-?rw-rw-r--  2.0 unx     2158 b- defN 22-Apr-11 21:45 neon_diana_utils-0.0.6a3.dist-info/RECORD
-23 files, 101978 bytes uncompressed, 29054 bytes compressed:  71.5%
+Zip file size: 35271 bytes, number of entries: 23
+-rw-r--r--  2.0 unx     1685 b- defN 22-Apr-13 20:05 neon_diana_utils/__init__.py
+-rw-r--r--  2.0 unx    13283 b- defN 22-Apr-13 20:05 neon_diana_utils/cli.py
+-rw-r--r--  2.0 unx     3213 b- defN 22-Apr-13 20:05 neon_diana_utils/constants.py
+-rw-r--r--  2.0 unx     6085 b- defN 22-Apr-13 20:05 neon_diana_utils/rabbitmq_api.py
+-rw-r--r--  2.0 unx     1856 b- defN 22-Apr-13 20:05 neon_diana_utils/version.py
+-rw-r--r--  2.0 unx       53 b- defN 22-Apr-13 20:05 neon_diana_utils/templates/docker-compose.yml
+-rw-r--r--  2.0 unx       60 b- defN 22-Apr-13 20:05 neon_diana_utils/templates/k8s_config_map.yml
+-rw-r--r--  2.0 unx     4971 b- defN 22-Apr-13 20:05 neon_diana_utils/templates/k8s_ingress_nginx_mq.yml
+-rw-r--r--  2.0 unx     1546 b- defN 22-Apr-13 20:05 neon_diana_utils/templates/k8s_nfs_volume.yml
+-rw-r--r--  2.0 unx       76 b- defN 22-Apr-13 20:05 neon_diana_utils/templates/k8s_secret.yml
+-rw-r--r--  2.0 unx      170 b- defN 22-Apr-13 20:05 neon_diana_utils/templates/kubernetes.yml
+-rw-r--r--  2.0 unx    23471 b- defN 22-Apr-13 20:05 neon_diana_utils/templates/service_mappings.yml
+-rw-r--r--  2.0 unx     1685 b- defN 22-Apr-13 20:05 neon_diana_utils/utils/__init__.py
+-rw-r--r--  2.0 unx    17400 b- defN 22-Apr-13 20:05 neon_diana_utils/utils/backend.py
+-rw-r--r--  2.0 unx     5283 b- defN 22-Apr-13 20:05 neon_diana_utils/utils/docker_utils.py
+-rw-r--r--  2.0 unx    19203 b- defN 22-Apr-13 20:05 neon_diana_utils/utils/kubernetes_utils.py
+-rw-r--r--  2.0 unx     1626 b- defN 22-Apr-13 20:05 neon_diana_utils-0.0.6a4.dist-info/LICENSE.md
+-rw-r--r--  2.0 unx    12175 b- defN 22-Apr-13 20:05 neon_diana_utils-0.0.6a4.dist-info/METADATA
+-rw-r--r--  2.0 unx       92 b- defN 22-Apr-13 20:05 neon_diana_utils-0.0.6a4.dist-info/WHEEL
+-rw-r--r--  2.0 unx       63 b- defN 22-Apr-13 20:05 neon_diana_utils-0.0.6a4.dist-info/entry_points.txt
+-rw-r--r--  2.0 unx       17 b- defN 22-Apr-13 20:05 neon_diana_utils-0.0.6a4.dist-info/top_level.txt
+-rw-r--r--  2.0 unx        1 b- defN 22-Apr-13 20:05 neon_diana_utils-0.0.6a4.dist-info/zip-safe
+?rw-rw-r--  2.0 unx     2158 b- defN 22-Apr-13 20:05 neon_diana_utils-0.0.6a4.dist-info/RECORD
+23 files, 116172 bytes uncompressed, 31677 bytes compressed:  72.7%
```

## zipnote {}

```diff
@@ -42,29 +42,29 @@
 
 Filename: neon_diana_utils/utils/docker_utils.py
 Comment: 
 
 Filename: neon_diana_utils/utils/kubernetes_utils.py
 Comment: 
 
-Filename: neon_diana_utils-0.0.6a3.dist-info/LICENSE.md
+Filename: neon_diana_utils-0.0.6a4.dist-info/LICENSE.md
 Comment: 
 
-Filename: neon_diana_utils-0.0.6a3.dist-info/METADATA
+Filename: neon_diana_utils-0.0.6a4.dist-info/METADATA
 Comment: 
 
-Filename: neon_diana_utils-0.0.6a3.dist-info/WHEEL
+Filename: neon_diana_utils-0.0.6a4.dist-info/WHEEL
 Comment: 
 
-Filename: neon_diana_utils-0.0.6a3.dist-info/entry_points.txt
+Filename: neon_diana_utils-0.0.6a4.dist-info/entry_points.txt
 Comment: 
 
-Filename: neon_diana_utils-0.0.6a3.dist-info/top_level.txt
+Filename: neon_diana_utils-0.0.6a4.dist-info/top_level.txt
 Comment: 
 
-Filename: neon_diana_utils-0.0.6a3.dist-info/zip-safe
+Filename: neon_diana_utils-0.0.6a4.dist-info/zip-safe
 Comment: 
 
-Filename: neon_diana_utils-0.0.6a3.dist-info/RECORD
+Filename: neon_diana_utils-0.0.6a4.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## neon_diana_utils/cli.py

```diff
@@ -228,8 +228,65 @@
 @click.argument('output_path', default=getenv("NEON_CONFIG_DIR", "~/.config/neon/"))
 def make_github_secret(username, token, output_path):
     from neon_diana_utils.utils.kubernetes_utils import cli_make_github_secret
     try:
         output_path = cli_make_github_secret(username, token, output_path)
         click.echo(f"Generated outputs in {output_path}")
     except Exception as e:
-        click.echo(e)
+        click.echo(e)
+
+
+@neon_diana_cli.command(help="Add routing for TCP service to ingress")
+@click.option("--service", "-s",
+              help="Service Name")
+@click.option("--port", "-p",
+              help="TCP port to forward")
+@click.option("--namespace", "-n", default="default",
+              help="Namespace service is running in")
+@click.argument('output_path', default=getenv("NEON_CONFIG_DIR", "~/.config/neon/"))
+def add_tcp_service(service, port, namespace, output_path):
+    from neon_diana_utils.utils.kubernetes_utils import cli_update_tcp_config
+    try:
+        files = cli_update_tcp_config(service, port, namespace, output_path)
+        click.echo(f"Wrote: {', '.join(files)}")
+    except Exception as e:
+        click.echo(e)
+
+
+@neon_diana_cli.command(help="Add ingress definition")
+@click.option("--service", "-s",
+              help="Service name")
+@click.option("--port", "-p",
+              help="Service port")
+@click.option("--host", "-h",
+              help="host (URL) to bind")
+@click.option("--namespace", "-n", default="default",
+              help="Namespace service is running in")
+@click.argument('output_path', default=getenv("NEON_CONFIG_DIR",
+                                              "~/.config/neon/"))
+def add_ingress(service, port, host, namespace, output_path):
+    from neon_diana_utils.utils.kubernetes_utils import cli_update_ingress_config
+    try:
+        file = cli_update_ingress_config(service, int(port), host,
+                                         namespace, output_path)
+        click.echo(f"Wrote: {file}")
+    except Exception as e:
+        click.echo(e)
+
+
+@neon_diana_cli.command(help="Add issuer definition")
+@click.option("--name", "-n", default="letsencrypt-prod",
+              help="Issuer name")
+@click.option("--email", "-e",
+              help="Registered email address")
+@click.argument('output_path', default=getenv("NEON_CONFIG_DIR",
+                                              "~/.config/neon/"))
+def make_cert_issuer(name, email, output_path):
+    from neon_diana_utils.utils.kubernetes_utils import cli_make_cert_issuer
+    try:
+        if not email:
+            click.echo("Email address is required")
+            return
+        file = cli_make_cert_issuer(name, email, output_path)
+        click.echo(f"Wrote: {file}")
+    except Exception as e:
+        click.echo(e)
```

## neon_diana_utils/version.py

```diff
@@ -22,8 +22,8 @@
 # EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 # PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
 # OR PROFITS;  OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 # LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 # NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 # SOFTWARE,  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
-__version__ = "0.0.6a3"
+__version__ = "0.0.6a4"
```

## neon_diana_utils/templates/docker-compose.yml

```diff
@@ -1,20 +1,6 @@
 version: "3.1"
 
 networks:
   mq-backend:
 
-volumes:
-  config:
-    driver_opts:
-      type: ${VOLUME_TYPE}-config
-      o: ${CONFIG_OPTS}
-      device: ${NEON_CONFIG_PATH}
-    labels:
-      kompose.volume.storage-class-name: nfs-config
-  metrics:
-    driver_opts:
-      type: ${VOLUME_TYPE}-metrics
-      o: ${METRIC_OPTS}
-      device: ${NEON_METRIC_PATH}
-    labels:
-      kompose.volume.storage-class-name: nfs-metrics
+volumes: {}
```

## neon_diana_utils/utils/backend.py

```diff
@@ -65,18 +65,18 @@
         raise ValueError("Null password")
 
     # Validate services
     if not mq_services and not http:
         raise ValueError("No services specified")
 
     # Parse volume paths
-    volumes = None
-    if volume_path:
-        volumes = {"config": join(volume_path, "config"),
-                   "metrics": join(volume_path, "metrics")}
+    volumes = {"config": join(volume_path, "config") if volume_path
+               else config_path,
+               "metrics": join(volume_path, "metrics") if volume_path
+               else join(config_path, "metrics")}
 
     # Parse Namespaces
     namespaces = {"MQ_NAMESPACE": mq_namespace,
                   "HTTP_NAMESPACE": http_namespace}
 
     # Parse user and orchestrator configuration
     mq_services_config = _parse_services(mq_services, "mq-backend")
@@ -175,15 +175,15 @@
                      "users": credentials}
     LOG.info(f"Writing Neon MQ configuration to {config_file}")
     with open(config_file, 'w+') as new_config:
         json.dump(configuration, new_config, indent=2)
 
     # Generate k8s secret
     generate_secret("mq-config", {"mq_config.json": json.dumps(configuration)},
-                    join(config_path, "k8s_secret_mq-config.yml"))
+                    join(config_path, "config", "k8s_secret_mq-config.yml"))
 
 
 def write_rabbit_config(api: RabbitMQAPI, config_file: Optional[str] = None):
     """
     Writes out RabbitMQ config files for persistence on next run
     :param api: Configured RabbitMQAPI object
     :param config_file: Path to `rabbit_mq_config.json` file to write
@@ -205,15 +205,15 @@
     rmq_conf_contents = f"load_definitions = /config/{config_basename}"
     with open(join(config_path, "rabbitmq.conf"), 'w+') as rabbit:
         rabbit.write(rmq_conf_contents)
 
     # Generate k8s config
     generate_config_map("rabbitmq", {"rabbit_mq_config.json": json.dumps(config),
                                      "rabbitmq.conf": rmq_conf_contents},
-                        join(config_path, "k8s_config_rabbitmq.yml"))
+                        join(config_path, "config", "k8s_config_rabbitmq.yml"))
 
 
 def _parse_services(requested_services: set,
                     service_class: str = "mq-backend") -> dict:
     """
     Parse requested services and return a dict mapping of valid service names
     to configurations read from service_mappings.yml
```

## neon_diana_utils/utils/docker_utils.py

```diff
@@ -22,16 +22,16 @@
 # OR PROFITS;  OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 # LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 # NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 # SOFTWARE,  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
 import docker
 
-from os import getenv
-from os.path import join, dirname, expanduser
+from os import getenv, makedirs
+from os.path import join, dirname, expanduser, isdir
 from typing import Optional
 
 from docker.errors import APIError
 from docker.models.containers import Container
 from ruamel.yaml import YAML
 from neon_utils import LOG
 
@@ -88,25 +88,27 @@
     with open(join(dirname(dirname(__file__)), "templates", "docker-compose.yml")) as f:
         compose_boilerplate = YAML().load(f)
     compose_contents = {**compose_boilerplate, **{"services": services_config}}
 
     volumes = volumes or list()
     for vol in volumes:
         if volume_type == "nfs":
-            config_host, config_path = volumes[vol].split(':')
-            config_opts = f"addr={config_host},nolock,rw,soft,nfsvers=4"
-            neon_config_path = f"\":{config_path}\""
+            volume_host, volume_path = volumes[vol].split(':')
+            volume_opts = f"addr={volume_host},nolock,rw,soft,nfsvers=4"
+            volume_path = f"\":{volume_path}\""
         else:
-            config_opts = "bind"
-            neon_config_path = volumes[vol] or dirname(compose_file)
+            volume_opts = "bind"
+            volume_path = volumes[vol] or dirname(compose_file)
+            if not isdir(volume_path):
+                makedirs(volume_path)
         compose_contents["volumes"][vol] = {
             "driver_opts": {
-                "type": f"{volume_type}-{vol}",
-                "o": config_opts,
-                "device": neon_config_path
+                "type": f"{volume_type}-{vol}" if volume_type else vol,
+                "o": volume_opts,
+                "device": volume_path
             },
             "labels": {
                 "kompose.volume.storage-class-name": f"nfs-{vol}"
             }
         }
 
     with open(compose_file, "w+") as f:
```

## neon_diana_utils/utils/kubernetes_utils.py

```diff
@@ -20,31 +20,30 @@
 # EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 # PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
 # OR PROFITS;  OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 # LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 # NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 # SOFTWARE,  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
-import subprocess
+import os.path
 import ruamel.yaml as yaml
 
 from typing import Optional
 from os import getenv
 from os.path import dirname, join, expanduser, isdir, isfile
 from neon_utils.logger import LOG
 from ruamel.yaml import YAML
 
-from neon_diana_utils.constants import Orchestrator
-
 
 def cli_make_rmq_config_map(input_path: str, output_path: str) -> str:
     """
     Generate a ConfigMap object for RabbitMQ from general config files
     :param input_path: path to directory containing RabbitMQ config files
     :param output_path: file or dir to write Kubernetes spec file to
+    :returns: path to output config file
     """
     file_path = expanduser(input_path)
     if not isdir(file_path):
         raise FileNotFoundError(f"Could not find requested directory: "
                                 f"{input_path}")
     output_path = expanduser(output_path)
     if isdir(output_path):
@@ -64,14 +63,15 @@
 
 
 def cli_make_api_secret(input_path: str, output_path: str) -> str:
     """
     Generate a Secret object for ngi-auth from general config files
     :param input_path: path to directory containing ngi_auth_vars.yml
     :param output_path: file or dir to write Kubernetes spec file to
+    :returns: path to output config file
     """
     file_path = expanduser(input_path)
     if not isdir(file_path):
         raise FileNotFoundError(f"Could not find requested directory: {input_path}")
     output_path = expanduser(output_path)
     if isfile(output_path):
         output_path = dirname(output_path)
@@ -79,41 +79,103 @@
     with open(join(file_path, "ngi_auth_vars.yml")) as f:
         ngi_auth = f.read()
     generate_secret("ngi-auth", {"ngi_auth_vars.yml": ngi_auth},
                     join(output_path, "k8s_secret_ngi-auth.yml"))
     return output_path
 
 
-def cli_make_github_secret(username: str, token: str, config_dir: str):
+def cli_make_github_secret(username: str, token: str, config_dir: str) -> str:
     """
     Generate a Secret object for a GitHub image pull secret
     :param username: Github username
     :param token: Github PAT with package_read permissions
     :param config_dir: Directory to write output spec file to
+    :returns: path to output config file
     """
     output_file = _create_github_secret(username, token,
                                         join(config_dir,
                                              "k8s_secret_github.yml"))
     return output_file
 
 
+def cli_make_cert_issuer(name: str, email: str,
+                         output_path: str = getenv("NEON_CONFIG_PATH",
+                                                   "~/.config/neon")) -> str:
+    """
+
+    """
+    config_path = expanduser(join(output_path, "ingress",
+                                  "k8s_config_cert_issuer.yml"))
+    os.makedirs(dirname(config_path), exist_ok=True)
+    config_path = _create_cert_issuer(name, email, config_path)
+    return config_path
+
+
+def cli_update_tcp_config(service: str, port: int, namespace: str = "default",
+                          output_path: str = getenv("NEON_CONFIG_PATH",
+                                                    "~/.config/neon")) -> \
+        (str, str):
+    """
+    Generate an updated tcp-services config map
+    :param service: service name to configure
+    :param port: port to configure
+    :param namespace: namespace associated with service
+    :param output_path: Directory to write output spec file to
+    :returns: path to tcp service config, path to nginx service patch
+    """
+    config_path = expanduser(join(output_path, "ingress",
+                                  "k8s_config_tcp_services.yml"))
+    os.makedirs(dirname(config_path), exist_ok=True)
+
+    tcp_config_path = _update_tcp_config(
+        {port: f"{namespace}/{service}:{port}"},
+        config_path)
+    patched_nginx_service = _patch_ingress_nginx_controller_service(
+        f"{namespace}-{service}", int(port),
+        output_path=join(output_path, "ingress",
+                         "k8s_patch_nginx_service.yml"))
+    return tcp_config_path, patched_nginx_service
+
+
+def cli_update_ingress_config(service: str, port: int, host: str,
+                              namespace: str = "default",
+                              output_path: str = getenv("NEON_CONFIG_PATH",
+                                                        "~/.config/neon")) -> \
+        str:
+    """
+    Generate an updated ingress configuration
+    :param service: service name to configure
+    :param port: service port to configure
+    :param host: host (URL) to bind to service
+    :param namespace: namespace of service to configure
+    :param output_path: Directory to write output files to
+    :returns: path to output config file
+    """
+    output_file = expanduser(join(output_path, "ingress",
+                                  f"k8s_config_ingress_{namespace}.yml"))
+    os.makedirs(dirname(output_file), exist_ok=True)
+    ingress_config = _update_ingress_config(host, service,
+                                            port, output_path=output_file)
+    return ingress_config
+
+
 def write_kubernetes_spec(k8s_config: list, output_path: Optional[str] = None,
                           namespaces: dict = None):
     """
     Generates and writes a kubernetes.yml spec file according to the passed services
     :param k8s_config: list of k8s objects specified, usually read from service_mappings.yml
     :param output_path: path to write spec files to
     :param namespaces: dict of placeholders to namespaces
     """
     namespaces = namespaces or dict()
     output_dir = expanduser(output_path) if output_path else \
         expanduser(getenv("NEON_CONFIG_PATH", "~/.config/neon"))
 
-    diana_spec_file = join(output_dir, "k8s_diana_backend.yml")
-    ingress_spec_file = join(output_dir, "k8s_ingress_nginx_mq.yml")
+    diana_spec_file = join(output_dir, "services", "k8s_diana_backend.yml")
+    os.makedirs(dirname(diana_spec_file), exist_ok=True)
 
     # Write Diana services spec file
     with open(join(dirname(dirname(__file__)), "templates",
                    "kubernetes.yml")) as f:
         diana_spec_contents = YAML().load(f)
     diana_spec_contents["items"].extend(k8s_config)
 
@@ -125,55 +187,66 @@
             string_contents = string_contents.replace(
                 '${' + placeholder + '}', replacement)
         f.seek(0)
         f.truncate(0)
         f.write(string_contents)
 
     # Write Ingress spec file
-    with open(join(dirname(dirname(__file__)), "templates",
-                   "k8s_ingress_nginx_mq.yml")) as f:
-        ingress_string_contents = f.read()
-    for placeholder, replacement in namespaces.items():
-        ingress_string_contents = ingress_string_contents.replace(
-            '${' + placeholder + '}', replacement)
+    os.makedirs(join(output_path, "ingress"), exist_ok=True)
 
-    with open(ingress_spec_file, "w+") as f:
-        f.write(ingress_string_contents)
+    tcp_config = {'5672': f"{namespaces.get('MQ_NAMESPACE') or 'default'}"
+                          f"/neon-rabbitmq:5672"}
+    tcp_config = _update_tcp_config(tcp_config,
+                                    join(output_path, "ingress",
+                                         "k8s_config_tcp_services.yml"))
+    LOG.info(f"Wrote {tcp_config}")
+    ingress_config = _patch_ingress_nginx_controller_service(
+        "neon-rabbitmq", 5672,
+        output_path=join(output_path, "ingress",
+                         "k8s_patch_nginx_service.yml"))
+    LOG.info(f"Wrote {ingress_config}")
 
 
 def generate_config_map(name: str, config_data: dict, output_path: str):
     """
     Generate a Kubernetes ConfigMap yml definition
     :param name: ConfigMap name
     :param config_data: Dict data to store
     :param output_path: output file to write
     """
     output_path = output_path or join(getenv("NEON_CONFIG_PATH", "~/.config/neon"), f"k8s_config_{name}.yml")
     output_path = expanduser(output_path)
+    if not isdir(dirname(output_path)):
+        os.makedirs(dirname(output_path), exist_ok=True)
     config_template = join(dirname(dirname(__file__)),
                            "templates", "k8s_config_map.yml")
     with open(config_template) as f:
         config_map = yaml.safe_load(f)
 
     config_map["metadata"]["name"] = name
     config_map["data"] = config_data
 
     with open(output_path, 'w+') as f:
         yaml.dump(config_map, f)
 
 
-def generate_secret(name: str, secret_data: dict, output_path: Optional[str] = None):
+def generate_secret(name: str, secret_data: dict,
+                    output_path: Optional[str] = None):
     """
     Generate a Kubernetes Secret yml definition
     :param name: ConfigMap name
     :param secret_data: Dict data to store
     :param output_path: output file to write
     """
-    output_path = output_path or join(getenv("NEON_CONFIG_PATH", "~/.config/neon"), f"k8s_secret_{name}.yml")
+    output_path = output_path or join(getenv("NEON_CONFIG_PATH",
+                                             "~/.config/neon"),
+                                      f"k8s_secret_{name}.yml")
     output_path = expanduser(output_path)
+    if not isdir(dirname(output_path)):
+        os.makedirs(dirname(output_path), exist_ok=True)
     config_template = join(dirname(dirname(__file__)),
                            "templates", "k8s_secret.yml")
     with open(config_template) as f:
         config_map = yaml.safe_load(f)
 
     config_map["metadata"]["name"] = name
     config_map["stringData"] = secret_data
@@ -211,7 +284,182 @@
         "data": {
             ".dockerconfigjson": encoded_config.decode()
         }
     }
     with open(output_path, 'w+') as f:
         yaml.dump(secret_spec, f)
     return output_path
+
+
+def _update_tcp_config(port_config: dict,
+                       output_path: Optional[str] = None) -> str:
+    """
+    Generate (or update) a tcp-services config spec for ingress-nginx
+    :param port_config: dict of "{port}" to "{namespace}/{service}:{port}"
+    :param output_path: output file to write
+    :returns: path to `tcp-services` k8s config map spec to be applied
+    """
+    output_file = output_path or join(getenv("NEON_CONFIG_PATH",
+                                             "~/.config/neon"), "ingress",
+                                      f"k8s_config_tcp_services.yml")
+    output_file = expanduser(output_file)
+
+    if isfile(output_file):
+        with open(output_file) as f:
+            config = yaml.safe_load(f)
+    else:
+        config = {'apiVersion': 'v1',
+                  'kind': 'ConfigMap',
+                  'metadata': {
+                      'name': 'tcp-services',
+                      'namespace': 'ingress-nginx'
+                  },
+                  'data': {}
+                  }
+    config['data'] = {**config['data'], **port_config}
+    with open(output_file, 'w+') as f:
+        yaml.dump(config, f, default_flow_style=False)
+    return output_file
+
+
+def _patch_ingress_nginx_controller_service(name: str, port: int,
+                                            target_port: Optional[int] = None,
+                                            protocol: str = "TCP",
+                                            output_path: Optional[str] = None):
+    """
+    Generate an updated nginx controller service spec
+    :param name: name of TCP service to configure
+    :param port: port to forward
+    :param target_port: optional target port (else uses `port`)
+    :param protocol: transport protocol (default TCP)
+    :param output_path: path to output file to write
+    """
+
+    output_file = output_path or join(getenv("NEON_CONFIG_PATH",
+                                             "~/.config/neon"), "ingress",
+                                      f"k8s_patch_nginx_service.yml")
+    output_file = expanduser(output_file)
+    if os.path.isfile(output_file):
+        LOG.info(f"Reading ingress config from {output_file}")
+        with open(output_file) as f:
+            config = yaml.safe_load(f)
+    else:
+        config = {"spec": {"ports": []}}
+
+    if any([i['name'] == name for i in config['spec']['ports']]):
+        LOG.info(f"Skipping already configured port: {name}")
+        return output_file
+    config['spec']['ports'].append({'name': name,
+                                    'port': port,
+                                    'targetPort': target_port or port,
+                                    'protocol': protocol})
+
+    with open(output_file, 'w+') as f:
+        yaml.dump(config, f, default_flow_style=False)
+    return output_file
+
+
+def _update_ingress_config(address: str, service: str, port: int,
+                           cert_issuer: str = "letsencrypt-prod",
+                           output_path: Optional[str] = None):
+    """
+    Update routing rules to route traffic to a service.
+    Note this assumes you are using ingress-nginx and tls
+    :param address: hostname rule applies to
+    :param service: service name
+    :param port: exposed container port service is running on
+    :param cert_issuer: Name of k8s Issuer to provide TLS certificates
+    :param output_path: path to output file to write
+    """
+    output_file = output_path or join(getenv("NEON_CONFIG_PATH",
+                                             "~/.config/neon"), "ingress",
+                                      f"k8s_config_ingress.yml")
+    output_file = expanduser(output_file)
+    if os.path.isfile(output_file):
+        LOG.info(f"Reading ingress config from {output_file}")
+        with open(output_file) as f:
+            config = yaml.safe_load(f)
+        if config['metadata']['annotations']['cert-manager.io/issuer'] != cert_issuer:
+            raise RuntimeError("Config cert_issuer conflict, skipping update")
+    else:
+        config = {
+            "kind": "Ingress",
+            "apiVersion": "networking.k8s.io/v1",
+            "metadata": {
+                "name": "ingress-diana",
+                "annotations": {
+                    "cert-manager.io/issuer": cert_issuer
+                }
+            },
+            "spec": {
+                "ingressClassName": "nginx",
+                "tls": [
+                    {"hosts": [],
+                     "secretName": f"tls-{cert_issuer}"}
+                ],
+                "rules": []
+            }
+        }
+
+    if address in config['spec']['tls'][0]['hosts']:
+        LOG.warning(f"Skipping address already configured: {address}")
+        return output_file
+
+    config['spec']['tls'][0]['hosts'].append(address)
+    config['spec']['rules'].append({"host": address,
+                                    "http": {"paths": [
+                                        {"path": '/',
+                                         "pathType": "Prefix",
+                                         "backend": {
+                                             "service": {
+                                                 "name": service,
+                                                 "port": {
+                                                     "number": port
+                                                 }
+                                             }
+                                         }}
+                                    ]}})
+    with open(output_file, 'w+') as f:
+        yaml.dump(config, f, default_flow_style=False)
+    return output_file
+
+
+def _create_cert_issuer(name: str, email: str,
+                        output_path: Optional[str] = None) -> str:
+    """
+    Create a certificate Issuer k8s spec
+    :param name: name for Issuer
+    :param email: email to use for ACME registration
+    :param output_path: spec file to write
+    """
+    output_file = output_path or join(getenv("NEON_CONFIG_PATH",
+                                             "~/.config/neon"), "ingress",
+                                      f"k8s_config_cert_issuer.yml")
+    output_file = expanduser(output_file)
+    spec = {
+        "apiVersion": "cert-manager.io/v1",
+        "kind": "Issuer",
+        "metadata": {
+            "name": name
+        },
+        "spec": {
+            "acme": {
+                "server": "https://acme-v02.api.letsencrypt.org/directory",
+                "email": email,
+                "privateKeySecretRef": {
+                    "name": name
+                },
+                "solvers": [
+                    {
+                        "http01": {
+                            "ingress": {
+                                "class": "nginx"
+                            }
+                        }
+                    }
+                ]
+            }
+        }
+    }
+    with open(output_file, 'w+') as f:
+        yaml.dump(spec, f, default_flow_style=False)
+    return output_file
```

## Comparing `neon_diana_utils-0.0.6a3.dist-info/LICENSE.md` & `neon_diana_utils-0.0.6a4.dist-info/LICENSE.md`

 * *Files identical despite different names*

## Comparing `neon_diana_utils-0.0.6a3.dist-info/METADATA` & `neon_diana_utils-0.0.6a4.dist-info/METADATA`

 * *Files 24% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: neon-diana-utils
-Version: 0.0.6a3
+Version: 0.0.6a4
 Summary: Utilities for administration of Neon DIANA
 Home-page: https://github.com/NeonGeckoCom/neon-diana-backend
 Author: NeonGecko
 Author-email: developers@neon.ai
 License: BSD-3-Clause
 Platform: UNKNOWN
 Classifier: Intended Audience :: Developers
@@ -139,14 +139,18 @@
 saved to the host filesystem or a configured NFS share. The configuration files 
 [generated earlier](#generate-config-with-diana) are all that is necessary to start the backend with Docker Compose
 
 ##### Running Configured Backend Services
 After a backend is configured, it can be started with `diana start-backend`. A standard example is included here, but 
 a description of config options is available via: `diana start-backend --help`.
 
+> *Note*: If running private containers, you will need to authenticate with Docker.
+> Documentation is available [from docker](https://docs.docker.com/engine/reference/commandline/login/).
+> Containers from NeonGecko are published to the `ghcr.io` server
+
 ```shell
 diana start-backend ~/neon_diana
 ```
 * `~/neon_diana` specifies the path to backend configuration
 
 ##### Stopping a Running Backend
 After a backend is started, it can be stopped with `diana stop-backend`. A standard example is included here, but 
@@ -186,31 +190,60 @@
 
 ```shell
 diana make-api-secrets -p ~/.config/neon ~/neon_diana
 ```
 * `-p` specifies the path to the directory containing `ngi_auth_vars.yml`
 * `~/neon_diana` specifies the output path for configuration files
 
+##### Defining Ingress
+
+###### TCP Services
+`diana` includes cli utilities for generating ingress definitions for non-http services.
+In general, ingress definitions will be created or updated when relevant backend services are configured, but
+the `diana add-tcp-service` entrypoint is also available to define these manually. Note that adding configuration
+will modify existing spec files in the configured path.
+
+###### HTTP Services
+`diana` includes cli utilities for generating ingress rules for http services when using `ingress-nginx`.
+It is assumed that the `ingress-nginx` and `cert-manager` namespaced services are deployed as described 
+[below](#kubernetes-cluster-references) and that A Records are defined for all configured subdomains.
+
+HTTP `Ingress` is namespaced, so the configurations generated here must be applied to the same namespace
+as the HTTP `Service`s they forward to. The commands in this guide will assume everything is in the "default"
+namespace unless otherwise specified.
+
+```shell
+# Create a certificate issuer (must be deployed to each namespace)
+diana make-cert-issuer -e <email_address> ~/neon_diana
+
+# Update an Ingress configuration for every HTTP service
+diana add-ingress -s <service_name> -p <service_http_port> -h <url_for_service> ~/neon_diana
+```
+
 ##### Applying Configuration to a Cluster
 `kubectl` should be configured to reference the Kubernetes cluster you are deploying to.
 If you are accessing private repositories, you will also need to configure the secret `github-auth`. Documentation 
 can be found [in the Kubernetes docs](https://kubernetes.io/dkocs/tasks/configure-pod-container/pull-image-private-registry/).
 
 ```shell
 # Apply configuration and secrets
-kubectl apply -f ~/neon_diana/k8s_secret_mq-config.yml -f ~/neon_diana/k8s_config_rabbitmq.yml -f ~/neon_diana/k8s_secret_ngi-auth.yml
+kubectl apply -f ~/neon_diana/config/k8s_secret_mq-config.yml -f ~/neon_diana/config/k8s_config_rabbitmq.yml -f ~/neon_diana/k8s_secret_ngi-auth.yml
+
+# If using ingress-nginx, apply those configurations
+kubectl apply -f ~/neon_diana/ingress/k8s_config_tcp_services.yml
+kubectl patch -n ingress-nginx service ingress-nginx-controller --patch-file ~/neon_diana/ingress/k8s_patch_nginx_service.yml
+
+# If using HTTP services, apply ingress rules
+kubectl apply -f ~/neon_diana/ingress/k8s_config_cert_issuer.yml -f ~/neon_diana/ingress/k8s_config_ingress.yml
 
 # If using private images
 kubectl apply -f ~/neon_diana/k8s_secret_github.yml
 
-# Apply ingress rules
-kubectl apply -f ~/neon_diana/k8s_ingress_nginx_mq.yml
-
 # Start backend services
-kubectl apply -f ~/neon_diana/k8s_diana_backend.yml
+kubectl apply -f ~/neon_diana/services/k8s_diana_backend.yml
 ```
 
 # Kubernetes Cluster References
 The following configurations were used at the time of writing this document:
 
 - [ingress-nginx](https://raw.githubusercontent.com/kubernetes/ingress-nginx/controller-v1.1.0/deploy/static/provider/cloud/deploy.yaml)
 - [cert-manager](https://github.com/jetstack/cert-manager/releases/download/v1.6.1/cert-manager.yaml)
```

## Comparing `neon_diana_utils-0.0.6a3.dist-info/RECORD` & `neon_diana_utils-0.0.6a4.dist-info/RECORD`

 * *Files 7% similar despite different names*

```diff
@@ -1,23 +1,23 @@
 neon_diana_utils/__init__.py,sha256=2AwtZbd8r3OwlQQjExpaQ3oLz4Z6dDOgNSPPDPjTNX0,1685
-neon_diana_utils/cli.py,sha256=lrmhrOfAqdhjuzFBkLuFxGZQQrsZ13fVWMjfiIjSeRI,10951
+neon_diana_utils/cli.py,sha256=HTEe2NF6B7nBtLPmzhfe6cQ5ds9jgSGmPoeQH9BCLiM,13283
 neon_diana_utils/constants.py,sha256=i9TtDze3sopF8eLCR4X3MKf3t6PuZleSm5grdf25YaU,3213
 neon_diana_utils/rabbitmq_api.py,sha256=0z1wMpnlEJt3luiNDtMaBWaWHasE-vXow8h3bNCVSPA,6085
-neon_diana_utils/version.py,sha256=XWoSLvmyPfl8m13_EGAof2ZKfGCiilAzRZfUPEDb8xA,1856
-neon_diana_utils/templates/docker-compose.yml,sha256=y57T4-rEo3NlLl2PwEIrgpvHeUVELP-huuqlYbK7G9k,419
+neon_diana_utils/version.py,sha256=hUCTOjt25kIECWx5bGtQ398O6mkG4TCByPwBAdIhiJQ,1856
+neon_diana_utils/templates/docker-compose.yml,sha256=_mHCb9ikK8Vs3ptsyBzQJdvtXfFk-30Ac0YUeWzfEY0,53
 neon_diana_utils/templates/k8s_config_map.yml,sha256=0k0VcpCcirQOYJjKKDSQNFPdUcdWeB1r_OtVFBMfIpc,60
 neon_diana_utils/templates/k8s_ingress_nginx_mq.yml,sha256=rvGwlPX5asszIm6his9z24aPoMnQNuoNSm6pQfKkzgw,4971
 neon_diana_utils/templates/k8s_nfs_volume.yml,sha256=YvwFM8K7ec9gU4JFm4n2lO-1k-NT4eKrvqN5UWU4DJ8,1546
 neon_diana_utils/templates/k8s_secret.yml,sha256=HOfU8k68AL3bZka52__KG7qilU2f8sNzqBxgaomEDZ0,76
 neon_diana_utils/templates/kubernetes.yml,sha256=hJCbMqml50QXHgNBM7JfIvzSCgFpwDoGY_PjPZkBkZ4,170
 neon_diana_utils/templates/service_mappings.yml,sha256=KH1XjowXFAWJgCXnBo0CZ2xa5oLTF1_X2mf5NSr9Cc8,23471
 neon_diana_utils/utils/__init__.py,sha256=2AwtZbd8r3OwlQQjExpaQ3oLz4Z6dDOgNSPPDPjTNX0,1685
-neon_diana_utils/utils/backend.py,sha256=0uhBm7bdV5gpKnSr6IPmnDUAs4vRlJGqbh5J8l3PgME,17316
-neon_diana_utils/utils/docker_utils.py,sha256=KiwnY40bK012_cIlCUDIqdyrxOei329nwPVbxZXU-e4,5180
-neon_diana_utils/utils/kubernetes_utils.py,sha256=_21ysglFnUYeQD-ARV5bkRdF0hCaTq3jAQYh5lPpgjk,9058
-neon_diana_utils-0.0.6a3.dist-info/LICENSE.md,sha256=6omeVSVshpc337BRGzhEQ22HCfrhcJ2QZA_5Ikyfx4I,1626
-neon_diana_utils-0.0.6a3.dist-info/METADATA,sha256=T3eFJqVkR8-uVFuxZZVRjEM71sC4w9UKbU6ghXURzns,10279
-neon_diana_utils-0.0.6a3.dist-info/WHEEL,sha256=G16H4A3IeoQmnOrYV4ueZGKSjhipXx8zc8nu9FGlvMA,92
-neon_diana_utils-0.0.6a3.dist-info/entry_points.txt,sha256=BQqjpqg017etnXpe_5fLo6UEKLQIs8IFMJDTC8nu9J4,63
-neon_diana_utils-0.0.6a3.dist-info/top_level.txt,sha256=XT31Q-_ovt3xd2uFucXJC7rgnAXR2BE_VcwWqQnfTmk,17
-neon_diana_utils-0.0.6a3.dist-info/zip-safe,sha256=AbpHGcgLb-kRsJGnwFEktk7uzpZOCcBY74-YBdrKVGs,1
-neon_diana_utils-0.0.6a3.dist-info/RECORD,,
+neon_diana_utils/utils/backend.py,sha256=ivPTeGiPiRehrUbvHgrypJ9zKO5Ld30AKtxQiSPBFv0,17400
+neon_diana_utils/utils/docker_utils.py,sha256=1vspmBeJft0DmpyrjzOvAtB-lxVEg9qoJ-JSPOtCMmY,5283
+neon_diana_utils/utils/kubernetes_utils.py,sha256=Vw4_AA3m1j-VB8y53xhjQvnlpCa29bGAptx9ft0oKPo,19203
+neon_diana_utils-0.0.6a4.dist-info/LICENSE.md,sha256=6omeVSVshpc337BRGzhEQ22HCfrhcJ2QZA_5Ikyfx4I,1626
+neon_diana_utils-0.0.6a4.dist-info/METADATA,sha256=EVrTKVOUy-UTRq4xjU0xezeHrWriYZ9235I4SvqJ6fw,12175
+neon_diana_utils-0.0.6a4.dist-info/WHEEL,sha256=G16H4A3IeoQmnOrYV4ueZGKSjhipXx8zc8nu9FGlvMA,92
+neon_diana_utils-0.0.6a4.dist-info/entry_points.txt,sha256=BQqjpqg017etnXpe_5fLo6UEKLQIs8IFMJDTC8nu9J4,63
+neon_diana_utils-0.0.6a4.dist-info/top_level.txt,sha256=XT31Q-_ovt3xd2uFucXJC7rgnAXR2BE_VcwWqQnfTmk,17
+neon_diana_utils-0.0.6a4.dist-info/zip-safe,sha256=AbpHGcgLb-kRsJGnwFEktk7uzpZOCcBY74-YBdrKVGs,1
+neon_diana_utils-0.0.6a4.dist-info/RECORD,,
```

