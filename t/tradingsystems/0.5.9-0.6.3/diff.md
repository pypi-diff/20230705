# Comparing `tmp/tradingsystems-0.5.9-py3-none-any.whl.zip` & `tmp/tradingsystems-0.6.3-py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,24 +1,24 @@
-Zip file size: 55988 bytes, number of entries: 22
--rw-rw-rw-  2.0 fat       31 b- defN 23-Jan-06 08:09 tradingsystems/__init__.py
--rw-rw-rw-  2.0 fat    10552 b- defN 21-Aug-04 08:28 tradingsystems/dollar_exits.py
--rw-rw-rw-  2.0 fat    32350 b- defN 22-Mar-22 14:31 tradingsystems/graphs.py
--rw-rw-rw-  2.0 fat    35416 b- defN 21-Dec-22 10:25 tradingsystems/indicator_entries.py
--rw-rw-rw-  2.0 fat    34950 b- defN 22-Mar-22 13:39 tradingsystems/indicator_exits.py
--rw-rw-rw-  2.0 fat    11960 b- defN 21-Dec-14 15:50 tradingsystems/ma_entries.py
--rw-rw-rw-  2.0 fat    17442 b- defN 22-Mar-22 13:32 tradingsystems/marketdata.py
--rw-rw-rw-  2.0 fat    30512 b- defN 21-Aug-23 16:58 tradingsystems/pnl.py
--rw-rw-rw-  2.0 fat    21039 b- defN 21-Dec-23 16:37 tradingsystems/positions.py
--rw-rw-rw-  2.0 fat    33581 b- defN 22-Mar-16 16:58 tradingsystems/reports.py
--rw-rw-rw-  2.0 fat    21380 b- defN 22-Mar-16 16:58 tradingsystems/signals.py
--rw-rw-rw-  2.0 fat    24511 b- defN 22-Mar-22 15:26 tradingsystems/systems.py
--rw-rw-rw-  2.0 fat     8828 b- defN 21-Dec-22 10:28 tradingsystems/systems_params.py
--rw-rw-rw-  2.0 fat     8886 b- defN 21-Sep-01 09:06 tradingsystems/targets.py
--rw-rw-rw-  2.0 fat    10853 b- defN 22-Mar-22 13:48 tradingsystems/trades.py
--rw-rw-rw-  2.0 fat    15184 b- defN 22-Mar-22 14:19 tradingsystems/utils.py
--rw-rw-rw-  2.0 fat    10297 b- defN 22-Mar-22 13:34 tradingsystems/winloss.py
--rw-rw-rw-  2.0 fat     1089 b- defN 23-Jan-06 08:22 tradingsystems-0.5.9.dist-info/LICENSE
--rw-rw-rw-  2.0 fat      687 b- defN 23-Jan-06 08:22 tradingsystems-0.5.9.dist-info/METADATA
--rw-rw-rw-  2.0 fat       92 b- defN 23-Jan-06 08:22 tradingsystems-0.5.9.dist-info/WHEEL
--rw-rw-rw-  2.0 fat       15 b- defN 23-Jan-06 08:22 tradingsystems-0.5.9.dist-info/top_level.txt
-?rw-rw-r--  2.0 fat     1857 b- defN 23-Jan-06 08:22 tradingsystems-0.5.9.dist-info/RECORD
-22 files, 331512 bytes uncompressed, 52994 bytes compressed:  84.0%
+Zip file size: 57207 bytes, number of entries: 22
+-rw-rw-rw-  2.0 fat       31 b- defN 23-Jul-05 14:24 tradingsystems/__init__.py
+-rw-rw-rw-  2.0 fat    10977 b- defN 23-Jun-27 15:40 tradingsystems/dollar_exits.py
+-rw-rw-rw-  2.0 fat    33480 b- defN 23-Jun-27 15:32 tradingsystems/graphs.py
+-rw-rw-rw-  2.0 fat    36518 b- defN 23-Jun-27 15:23 tradingsystems/indicator_entries.py
+-rw-rw-rw-  2.0 fat    35665 b- defN 23-Jun-27 15:34 tradingsystems/indicator_exits.py
+-rw-rw-rw-  2.0 fat    12218 b- defN 23-Jun-27 15:24 tradingsystems/ma_entries.py
+-rw-rw-rw-  2.0 fat    18012 b- defN 23-Jun-27 15:26 tradingsystems/marketdata.py
+-rw-rw-rw-  2.0 fat    31484 b- defN 23-Jun-27 15:37 tradingsystems/pnl.py
+-rw-rw-rw-  2.0 fat    21615 b- defN 23-Jun-27 15:37 tradingsystems/positions.py
+-rw-rw-rw-  2.0 fat    34026 b- defN 23-Jun-27 15:40 tradingsystems/reports.py
+-rw-rw-rw-  2.0 fat    21796 b- defN 23-Jun-27 15:40 tradingsystems/signals.py
+-rw-rw-rw-  2.0 fat    25416 b- defN 23-Jun-27 15:23 tradingsystems/systems.py
+-rw-rw-rw-  2.0 fat     8862 b- defN 23-Jul-05 09:00 tradingsystems/systems_params.py
+-rw-rw-rw-  2.0 fat     9247 b- defN 23-Jun-27 15:41 tradingsystems/targets.py
+-rw-rw-rw-  2.0 fat    11034 b- defN 23-Jun-27 15:13 tradingsystems/trades.py
+-rw-rw-rw-  2.0 fat    15769 b- defN 23-Jul-05 09:42 tradingsystems/utils.py
+-rw-rw-rw-  2.0 fat    10467 b- defN 23-Jun-27 15:15 tradingsystems/winloss.py
+-rw-rw-rw-  2.0 fat     1089 b- defN 23-Jul-05 14:26 tradingsystems-0.6.3.dist-info/LICENSE
+-rw-rw-rw-  2.0 fat      687 b- defN 23-Jul-05 14:26 tradingsystems-0.6.3.dist-info/METADATA
+-rw-rw-rw-  2.0 fat       92 b- defN 23-Jul-05 14:26 tradingsystems-0.6.3.dist-info/WHEEL
+-rw-rw-rw-  2.0 fat       15 b- defN 23-Jul-05 14:26 tradingsystems-0.6.3.dist-info/top_level.txt
+-rw-rw-r--  2.0 fat     1857 b- defN 23-Jul-05 14:26 tradingsystems-0.6.3.dist-info/RECORD
+22 files, 340357 bytes uncompressed, 54213 bytes compressed:  84.1%
```

## zipnote {}

```diff
@@ -45,23 +45,23 @@
 
 Filename: tradingsystems/utils.py
 Comment: 
 
 Filename: tradingsystems/winloss.py
 Comment: 
 
-Filename: tradingsystems-0.5.9.dist-info/LICENSE
+Filename: tradingsystems-0.6.3.dist-info/LICENSE
 Comment: 
 
-Filename: tradingsystems-0.5.9.dist-info/METADATA
+Filename: tradingsystems-0.6.3.dist-info/METADATA
 Comment: 
 
-Filename: tradingsystems-0.5.9.dist-info/WHEEL
+Filename: tradingsystems-0.6.3.dist-info/WHEEL
 Comment: 
 
-Filename: tradingsystems-0.5.9.dist-info/top_level.txt
+Filename: tradingsystems-0.6.3.dist-info/top_level.txt
 Comment: 
 
-Filename: tradingsystems-0.5.9.dist-info/RECORD
+Filename: tradingsystems-0.6.3.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## tradingsystems/__init__.py

```diff
@@ -1,5 +1,5 @@
-__version__ = "0.5.9"
+__version__ = "0.6.3"
```

## tradingsystems/dollar_exits.py

```diff
@@ -1,22 +1,26 @@
 """
 Exit signals based on a dollar value.
 
 """
+import pandas as pd
 import numpy as np
 
 class DollarExit():
     """
     Calculate dollar value based exit signals.
 
     """
 
     @classmethod
     def exit_dollar(
-            cls, prices, trigger_value, exit_level):
+        cls,
+        prices: pd.DataFrame,
+        trigger_value: pd.Series,
+        exit_level: str) -> tuple[pd.DataFrame, np.ndarray]:
         """
         Calculate exit based on a dollar amount.
 
         Parameters
         ----------
         prices : DataFrame
             The OHLC data.
@@ -73,15 +77,17 @@
                 prices=prices,
                 trigger_value=trigger_value)
 
         return prices, exit_
 
 
     @staticmethod
-    def _exit_profit_target(prices, trigger_value):
+    def _exit_profit_target(
+        prices: pd.DataFrame,
+        trigger_value: pd.Series) -> tuple[pd.DataFrame, np.ndarray]:
         """
         Calculate exit based on a profit target.
 
         Parameters
         ----------
         prices : DataFrame
             The OHLC data.
@@ -134,15 +140,17 @@
                     # Set the exit signal to 0
                     profit_target_exit[row] = 0
 
         return prices, profit_target_exit
 
 
     @staticmethod
-    def _exit_initial_dollar_loss(prices, trigger_value):
+    def _exit_initial_dollar_loss(
+        prices: pd.DataFrame,
+        trigger_value: pd.Series) -> tuple[pd.DataFrame, np.ndarray]:
         """
         Calculate exit based on a given loss from the entry point.
 
         Parameters
         ----------
         prices : DataFrame
             The OHLC data.
@@ -196,15 +204,17 @@
                     # Set the exit signal to 0
                     initial_dollar_loss_exit[row] = 0
 
         return prices, initial_dollar_loss_exit
 
 
     @staticmethod
-    def _exit_breakeven(prices, trigger_value):
+    def _exit_breakeven(
+        prices: pd.DataFrame,
+        trigger_value: pd.Series) -> tuple[pd.DataFrame, np.ndarray]:
         """
         Calculate exit based on passing a breakeven threshold.
 
         Parameters
         ----------
         prices : DataFrame
             The OHLC data.
@@ -271,15 +281,17 @@
                     # Set the exit signal to 0
                     breakeven_exit[row] = 0
 
         return prices, breakeven_exit
 
 
     @staticmethod
-    def _exit_trailing(prices, trigger_value):
+    def _exit_trailing(
+        prices: pd.DataFrame,
+        trigger_value: pd.Series) -> tuple[pd.DataFrame, np.ndarray]:
         """
         Calculate exit based on a trailing stop.
 
         Parameters
         ----------
         prices : DataFrame
             The OHLC data.
```

## tradingsystems/graphs.py

```diff
@@ -1,26 +1,32 @@
 """
 Graph the performance of the trading strategy
 
 """
 import numpy as np
+import pandas as pd
 import matplotlib.pyplot as plt
+from matplotlib import axes
 from matplotlib.ticker import FormatStrFormatter
 # pylint: disable=unbalanced-tuple-unpacking
 # pylint: disable=no-else-return
 
 class PerformanceGraph():
     """
     Class of functions used to graph trading system performance
 
     """
 
     @classmethod
     def two_panel_graph(
-            cls, signals=None, tables=None, params=None, es_dict=None):
+        cls,
+        es_dict: dict,
+        params: dict,
+        tables: dict,
+        signals: bool | None = None) -> dict:
         """
         Create the 2 panel graph
 
         Parameters
         ----------
         signals : Bool
             Whether to plot the Buy/Sell signals on the price chart.
@@ -66,15 +72,19 @@
         plt.show()
 
         return params
 
 
     @classmethod
     def three_panel_graph(
-            cls, signals=None, tables=None, params=None, es_dict=None):
+        cls,
+        es_dict: dict,
+        params: dict,
+        tables: dict,
+        signals: bool | None = None) -> dict:
         """
         Create the 3 panel graph
 
         Parameters
         ----------
         signals : Bool
             Whether to plot the Buy/Sell signals on the price chart.
@@ -132,38 +142,40 @@
             if params['entry_type'] == 'macd':
                 axt = cls._indicator_format(
                     axis=axt, dates=graph_params['dates'], indicator=indicator,
                     params=params)
 
             # Add legend, labels and titles to the graphs
             if params['entry_type'] == 'macd':
-                axes = {'ax1':ax1, 'ax2':ax2, 'ax3':ax3, 'axt':axt}
+                axes_dict = {'ax1':ax1, 'ax2':ax2, 'ax3':ax3, 'axt':axt}
                 ax1, ax2, ax3, axt = cls._three_panel_legend(
-                    axes=axes, perf_dict=tables['perf_dict'],
+                    axes_dict=axes_dict, perf_dict=tables['perf_dict'],
                     params=params,
                     entry_signal_labels=es_dict['entry_signal_labels'])
             else:
-                axes = {'ax1':ax1, 'ax2':ax2, 'ax3':ax3}
+                axes_dict = {'ax1':ax1, 'ax2':ax2, 'ax3':ax3}
                 ax1, ax2, ax3 = cls._three_panel_legend(
-                    axes=axes, perf_dict=tables['perf_dict'],
+                    axes_dict=axes_dict, perf_dict=tables['perf_dict'],
                     params=params,
                     entry_signal_labels=es_dict['entry_signal_labels'])
 
         params['graph_params'] = graph_params
         params['signal_dict'] = signal_dict
 
         # Plot the graphs
         plt.show()
 
         return params
 
 
     @staticmethod
     def _graph_variables(
-            prices=None, entry_type=None, entry_signal_indicators=None):
+        prices: pd.DataFrame,
+        entry_type: str,
+        entry_signal_indicators: dict | None = None) -> dict:
         """
         Create graph initialization variables
 
         Returns
         -------
         dates : Pandas Series
             The dates to plot on the x-axis.
@@ -225,15 +237,19 @@
             graph_params['upper_bound'] = graph_params['price']
 
         return graph_params
 
 
     @classmethod
     def _two_panel_setup(
-            cls, prices=None, graph_params=None, params=None, es_dict=None):
+        cls,
+        prices: pd.DataFrame,
+        graph_params: dict,
+        params: dict,
+        es_dict: dict) -> tuple[axes.Axes,axes.Axes]:
         """
         Set up the 2 panel chart
 
         Parameters
         ----------
         dates : Pandas Series
             The dates to plot on the x-axis.
@@ -366,23 +382,29 @@
                  label='MTM Equity')
 
         return ax1, ax2
 
 
     @classmethod
     def _three_panel_setup(
-            cls, prices=None, graph_params=None, params=None, es_dict=None):
+        cls,
+        prices: pd.DataFrame,
+        graph_params: dict,
+        params: dict,
+        es_dict: dict) -> tuple[
+            axes.Axes, axes.Axes, axes.Axes, axes.Axes] | tuple[
+                axes.Axes, axes.Axes, axes.Axes]:
         """
         Set up the 3 panel chart
 
         Parameters
         ----------
         dates : Pandas Series
             The dates to plot on the x-axis.
-        price : Pandas Series
+        prices : Pandas Series
             Closing Prices.
         equity : Pandas Series
             Daily Mark to Market Equity level.
 
         Returns
         -------
         ax1 : Matplotlib Axes object
@@ -537,15 +559,18 @@
             axt.set_xlim(graph_params['dates'][0], graph_params['dates'][-1])
             return ax1, ax2, ax3, axt
         else:
             return ax1, ax2, ax3
 
 
     @staticmethod
-    def _bar_color(price_data, color1, color2):
+    def _bar_color(
+        price_data: pd.Series,
+        color1: str,
+        color2: str) -> np.ndarray:
         """
         Set barchart color to green if positive and red if negative.
 
         Parameters
         ----------
         price_data : Series
             Price data.
@@ -560,15 +585,19 @@
             Series of colors for each data point.
 
         """
         return np.where(price_data.values > 0, color1, color2).T
 
 
     @classmethod
-    def _axis_scale(cls, ax1, graph_params, params):
+    def _axis_scale(
+        cls,
+        ax1: axes.Axes,
+        graph_params: dict,
+        params: dict) -> axes.Axes:
 
         # Set y-axis to 2 decimal places for FX pairs
         if params['asset_type'] == 'fx':
             ax1.yaxis.set_major_formatter(FormatStrFormatter('% 1.2f'))
 
         else:
             upper, lower = cls._set_upper_lower(graph_params=graph_params)
@@ -582,15 +611,17 @@
                 ax1.yaxis.set_major_formatter(FormatStrFormatter('% 1.0f'))
 
         return ax1
 
 
     @classmethod
     def _create_signals(
-            cls, prices=None, graph_params=None):
+        cls,
+        prices: pd.DataFrame,
+        graph_params: dict) -> dict:
         """
         Create trade signals to be plotted on main price chart
 
         Parameters
         ----------
         cumsig : Pandas Series
             The cumulative buy / sell signal.
@@ -691,28 +722,31 @@
         signal_dict['sell_short_dates'] = prices.index[
             signal_dict['sell_short_signals']]
 
         return signal_dict
 
 
     @staticmethod
-    def _set_upper_lower(graph_params):
+    def _set_upper_lower(
+        graph_params: dict) -> tuple[float, float]:
         # Set upper to the max of the upper bound and lower to the lowest
         # non-zero value of the lower bound, stripping zeros and nan values
 
         upper = graph_params['upper_bound'][
             graph_params['upper_bound'] != 0].dropna().max()
         lower = graph_params['lower_bound'][
             graph_params['lower_bound'] != 0].dropna().min()
 
         return upper, lower
 
 
     @staticmethod
-    def _plot_signals(axis=None, signal_dict=None):
+    def _plot_signals(
+        axis: axes.Axes,
+        signal_dict: dict) -> axes.Axes:
         """
         Plot trade signals on price-time chart
 
         Parameters
         ----------
         axis : Matplotlib Axes object
             The main price chart.
@@ -758,15 +792,18 @@
                     label='Go Short')
 
         return axis
 
 
     @staticmethod
     def _indicator_format(
-            axis=None, indicator=None, dates=None,  params=None):
+        axis: axes.Axes,
+        params: dict,
+        indicator: pd.Series | None = None,
+        dates: pd.Series | None = None) -> axes.Axes:
         """
         Apply Overbought / Oversold formatting to the indicator chart
 
         Parameters
         ----------
         ax : Matplotlib Axes object
             The Indicator chart.
@@ -779,15 +816,16 @@
         -------
         ax : Matplotlib Axes object
             The Indicator chart.
 
         """
 
         # For all the indicators other than momentum, volatility, adx and macd
-        if params['entry_type'] not in ['momentum', 'volatility', 'adx', 'macd']:
+        if params['entry_type'] not in [
+            'momentum', 'volatility', 'adx', 'macd']:
 
             # Plot horizontal overbought and oversold lines
             axis.axhline(
                 y=params['entry_oversold'],
                 color='black',
                 linewidth=1)
             axis.axhline(
@@ -824,15 +862,18 @@
                 color='black',
                 linewidth=1)
 
         return axis
 
 
     @staticmethod
-    def _two_panel_legend(ax1, ax2, perf_dict):
+    def _two_panel_legend(
+        ax1: axes.Axes,
+        ax2: axes.Axes,
+        perf_dict: dict) -> tuple[axes.Axes, axes.Axes]:
         """
         Create the legend, axis labels and titles for the 2 panel graph
 
         Parameters
         ----------
         ax1 : Matplotlib Axes object
             The main price chart.
@@ -857,15 +898,20 @@
         ax1.legend()
 
         return ax1, ax2
 
 
     @staticmethod
     def _three_panel_legend(
-            axes, perf_dict, entry_signal_labels, params):
+        axes_dict: dict[str, axes.Axes],
+        perf_dict: dict,
+        entry_signal_labels: dict,
+        params: dict) -> tuple[
+            axes.Axes, axes.Axes, axes.Axes, axes.Axes] | tuple[
+                axes.Axes, axes.Axes, axes.Axes]:
         """
         Create the legend, axis labels and titles for the 3 panel graph
 
         Parameters
         ----------
         ax1 : Matplotlib Axes object
             The main price chart.
@@ -880,17 +926,17 @@
             The main price chart.
         ax2 : Matplotlib Axes object
             The Indicator chart.
         ax3 : Matplotlib Axes object
             The MTM Equity chart.
 
         """
-        ax1 = axes['ax1']
-        ax2 = axes['ax2']
-        ax3 = axes['ax3']
+        ax1 = axes_dict['ax1']
+        ax2 = axes_dict['ax2']
+        ax3 = axes_dict['ax3']
 
         # Title of main price chart is the contract longname plus the entry
         # strategy
         ax1.set_title(perf_dict['longname']+' - '+perf_dict['entry_label'])
         ax1.set_ylabel('Price')
 
         # Title of the Indicator chart is the time period plus indicator name
@@ -901,14 +947,14 @@
                                     'stoch_over_under']:
             ax2.legend(loc=2)
         ax3.set_title("Equity Curve")
         ax3.set_ylabel('Equity')
         ax1.legend()
 
         if params['entry_type'] == 'macd':
-            axt = axes['axt']
+            axt = axes_dict['axt']
             ax2.set_ylabel('MACD - Signal')
             axt.set_ylabel('Histogram')
             ax2.set_title(entry_signal_labels[params['entry_type']])
             return ax1, ax2, ax3, axt
         else:
             return ax1, ax2, ax3
```

## tradingsystems/indicator_entries.py

```diff
@@ -1,23 +1,26 @@
 """
 Indicator Entry signals
 
 """
 
+import pandas as pd
 import numpy as np
 from technicalmethods.methods import Indicators
 
 class IndicatorEntry():
     """
     Calculate entry signals using indicators / oscillators.
 
     """
 
     @staticmethod
-    def entry_parabolic_sar(prices, acceleration_factor):
+    def entry_parabolic_sar(
+        prices: pd.DataFrame,
+        acceleration_factor: float) -> tuple[pd.DataFrame, int, np.ndarray]:
         """
         Entry signals based on Parabolic SAR
 
         Parameters
         ----------
         prices : DataFrame
             The OHLC data
@@ -231,15 +234,17 @@
         prices['ep_sar_diff_entry'] = ep_sar_diff
         prices['af_x_diff_entry'] = af_x_diff
 
         return prices, start, trade_signal
 
 
     @staticmethod
-    def entry_channel_breakout(prices, time_period):
+    def entry_channel_breakout(
+        prices: pd.DataFrame,
+        time_period: int) -> tuple[pd.DataFrame, int, np.ndarray]:
         """
         Entry signals based on a channel breakout.
 
         Parameters
         ----------
         prices : DataFrame
             The OHLC data
@@ -300,15 +305,19 @@
         prices['rolling_high_close_entry'] = rolling_high_close
         prices['rolling_low_close_entry'] = rolling_low_close
 
         return prices, start, trade_signal
 
 
     @staticmethod
-    def entry_stochastic_crossover(prices, time_period, oversold, overbought):
+    def entry_stochastic_crossover(
+        prices: pd.DataFrame,
+        time_period: int,
+        oversold: int,
+        overbought: int) -> tuple[pd.DataFrame, int, np.ndarray]:
         """
         Entry signals based on slow k / slow d stochastics crossing.
 
         Parameters
         ----------
         prices : DataFrame
             The OHLC data
@@ -379,15 +388,19 @@
         prices['slow_k_entry'] = slow_k
         prices['slow_d_entry'] = slow_d
 
         return prices, start, trade_signal
 
 
     @staticmethod
-    def entry_stochastic_over_under(prices, time_period, oversold, overbought):
+    def entry_stochastic_over_under(
+        prices: pd.DataFrame,
+        time_period: int,
+        oversold: int,
+        overbought: int) -> tuple[pd.DataFrame, int, np.ndarray]:
         """
         Entry signals based on slow k / slow d stochastics crossing
         overbought / oversold levels.
 
         Parameters
         ----------
         prices : DataFrame
@@ -479,15 +492,19 @@
         prices['slow_k_entry'] = slow_k
         prices['slow_d_entry'] = slow_d
 
         return prices, start, trade_signal
 
 
     @staticmethod
-    def entry_stochastic_pop(prices, time_period, oversold, overbought):
+    def entry_stochastic_pop(
+        prices: pd.DataFrame,
+        time_period: int,
+        oversold: int,
+        overbought: int) -> tuple[pd.DataFrame, int, np.ndarray]:
         """
         Entry signals based on the Stochastic Pop method
 
         Parameters
         ----------
         prices : DataFrame
             The OHLC data
@@ -578,15 +595,19 @@
         prices['slow_k_entry'] = slow_k
         prices['slow_d_entry'] = slow_d
 
         return prices, start, trade_signal
 
 
     @staticmethod
-    def entry_rsi(prices, time_period, oversold, overbought):
+    def entry_rsi(
+        prices: pd.DataFrame,
+        time_period: int,
+        oversold: int,
+        overbought: int) -> tuple[pd.DataFrame, int, np.ndarray]:
         """
         Entry signals based on the Relative Strength Index
 
         Parameters
         ----------
         prices : DataFrame
             The OHLC data
@@ -648,15 +669,18 @@
         # Assign the series to the OHLC data
         prices['RSI_entry'] = rsi
 
         return prices, start, trade_signal
 
 
     @staticmethod
-    def entry_adx(prices, time_period, threshold):
+    def entry_adx(
+        prices: pd.DataFrame,
+        time_period: int,
+        threshold: int) -> tuple[pd.DataFrame, int, np.ndarray]:
         """
         Entry signals based on the ADX indicator.
 
         Parameters
         ----------
         prices : DataFrame
             The OHLC data
@@ -738,15 +762,17 @@
         prices['DI_plus_entry'] = di_plus
         prices['DI_minus_entry'] = di_minus
 
         return prices, start, trade_signal
 
 
     @staticmethod
-    def entry_macd(prices, macd_params):
+    def entry_macd(
+        prices: pd.DataFrame,
+        macd_params: tuple) -> tuple[pd.DataFrame, int, np.ndarray]:
         """
         Entry signals based on the MACD indicator.
 
         Parameters
         ----------
         prices : DataFrame
             The OHLC data
@@ -805,26 +831,29 @@
         prices['MACD_Signal_entry'] = macd_signal
         prices['MACD_Hist_entry'] = macd_hist
 
         return prices, start, trade_signal
 
 
     @staticmethod
-    def entry_commodity_channel_index(prices, time_period, threshold):
+    def entry_commodity_channel_index(
+        prices: pd.DataFrame,
+        time_period: int,
+        threshold: float) -> tuple[pd.DataFrame, int, np.ndarray]:
         """
         Entry signals based on the Commodity Channel Index
 
         Parameters
         ----------
         prices : DataFrame
             The OHLC data
         time_period : Int
             The number of days to use in the indicator calculation.
-        threshold : TYPE
-            DESCRIPTION.
+        threshold : Float
+            The threshold used for taking signals. The default is 0.
 
         Returns
         -------
         prices : DataFrame
             The OHLC data with additional columns.
         start : Int
             The first valid date row to calculate from.
@@ -875,15 +904,18 @@
         # Assign the series to the OHLC data
         prices['CCI_entry'] = cci
 
         return prices, start, trade_signal
 
 
     @staticmethod
-    def entry_momentum(prices, time_period, threshold):
+    def entry_momentum(
+        prices: pd.DataFrame,
+        time_period: int,
+        threshold: float) -> tuple[pd.DataFrame, int, np.ndarray]:
         """
         Entry signals based on n-day momentum
 
         Parameters
         ----------
         prices : DataFrame
             The OHLC data
@@ -945,15 +977,18 @@
         prices['n_day_close'] = n_day_close
         prices['momentum'] = prices['Close'] - prices['n_day_close']
 
         return prices, start, trade_signal
 
 
     @staticmethod
-    def entry_volatility(prices, time_period, threshold):
+    def entry_volatility(
+        prices: pd.DataFrame,
+        time_period: int,
+        threshold: float) -> tuple[pd.DataFrame, int, np.ndarray]:
         """
         Entry signals based on a volatility breakout.
 
         Parameters
         ----------
         prices : DataFrame
             The OHLC data
```

## tradingsystems/indicator_exits.py

```diff
@@ -1,25 +1,29 @@
 """
 Exit signals using indicators.
 
 """
 
 import random
 import numpy as np
+import pandas as pd
 from technicalmethods.methods import Indicators
 
 class IndicatorExit():
     """
     Calculate exit signals using indicators.
 
     """
 
     @staticmethod
     def exit_parabolic_sar(
-            prices, time_period, acceleration_factor, sip_price):
+        prices: pd.DataFrame,
+        time_period: int,
+        acceleration_factor: float,
+        sip_price: bool) -> tuple[pd.DataFrame, np.ndarray]:
         """
         Calculate exit based on a Parabolic SAR.
 
         Parameters
         ----------
         prices : DataFrame
             The OHLC data
@@ -272,15 +276,19 @@
         prices['ep_sar_diff_exit'] = ep_sar_diff
         prices['af_x_diff_exit'] = af_x_diff
 
         return prices, parabolic_sar_exit
 
 
     @staticmethod
-    def exit_rsi_trail(prices, time_period, oversold, overbought):
+    def exit_rsi_trail(
+        prices: pd.DataFrame,
+        time_period: int,
+        oversold: int,
+        overbought: int) -> tuple[pd.DataFrame, np.ndarray]:
         """
         Calculate exit based on a trailing RSI - a down close when the RSI is
         overbought when long or an up close when the RSI is oversold when
         short.
 
         Parameters
         ----------
@@ -349,15 +357,17 @@
         # Set the DataFrame column to the numpy array
         prices['RSI_exit'] = rsi
 
         return prices, rsi_trail_exit
 
 
     @staticmethod
-    def exit_key_reversal(prices, time_period):
+    def exit_key_reversal(
+        prices: pd.DataFrame,
+        time_period: int) -> tuple[pd.DataFrame, np.ndarray]:
         """
         Calculate exit based on a key reversal day - a new high combined with
         a down close when long or a new low combined with an up close when
         short.
 
         Parameters
         ----------
@@ -427,15 +437,18 @@
         prices['rolling_high_key'] = rolling_high
         prices['rolling_low_key'] = rolling_low
 
         return prices, key_reversal_exit
 
 
     @staticmethod
-    def exit_volatility(prices, time_period, threshold):
+    def exit_volatility(
+        prices: pd.DataFrame,
+        time_period: int,
+        threshold: float) -> tuple[pd.DataFrame, np.ndarray]:
         """
         Calculate exit based on an increase in volatility - a fall in price
         greater than the ATR * Threshold when long or a rise in price greater
         than the ATR * Threshold when when short.
 
         Parameters
         ----------
@@ -504,15 +517,17 @@
         # Set the DataFrame column to the numpy array
         prices['ATR_exit'] = atr
 
         return prices, volatility_exit
 
 
     @staticmethod
-    def exit_stochastic_crossover(prices, time_period):
+    def exit_stochastic_crossover(
+        prices: pd.DataFrame,
+        time_period: int) -> tuple[pd.DataFrame, np.ndarray]:
         """
         Calculate exit based on a stochastic crossover - if the slow k crosses
         below the slow d when long or if the slow k crosses above the slow d
         when short.
 
         Parameters
         ----------
@@ -580,15 +595,15 @@
         prices['slow_k_exit'] = slow_k
         prices['slow_d_exit'] = slow_d
 
         return prices, stoch_cross_exit
 
 
     @staticmethod
-    def exit_random(prices):
+    def exit_random(prices: pd.DataFrame) -> tuple[pd.DataFrame, np.ndarray]:
         """
         Calculate exit based on the first losing day after a random time
         interval.
 
         Parameters
         ----------
         prices : DataFrame
@@ -656,15 +671,17 @@
         # Set the DataFrame column to the numpy array
         prices['random_days_exit'] = exit_days
 
         return prices, random_exit
 
 
     @staticmethod
-    def exit_support_resistance(prices, time_period):
+    def exit_support_resistance(
+        prices: pd.DataFrame,
+        time_period: int) -> tuple[pd.DataFrame, np.ndarray]:
         """
         Calculate exit based on an n-day high / low.
 
         Parameters
         ----------
         prices : DataFrame
             The OHLC data.
@@ -734,15 +751,17 @@
         prices['rolling_low_close_sr_exit'] = rolling_low_close
         prices['exit_level'] = exit_level
 
         return prices, support_resistance_exit
 
 
     @staticmethod
-    def exit_immediate_profit(prices, time_period):
+    def exit_immediate_profit(
+        prices: pd.DataFrame,
+        time_period: int) -> tuple[pd.DataFrame, np.ndarray]:
         """
         Calculate exit based on an immediate n-day profit.
 
         Parameters
         ----------
         prices : DataFrame
             The OHLC data.
@@ -805,15 +824,17 @@
                         # Set the exit signal to 0
                         immediate_profit_exit[row] = 0
 
         return prices, immediate_profit_exit
 
 
     @staticmethod
-    def exit_nday_range(prices, time_period):
+    def exit_nday_range(
+        prices: pd.DataFrame,
+        time_period: int) -> tuple[pd.DataFrame, np.ndarray]:
         """
         Calculate exit based on an n-day range.
 
         Parameters
         ----------
         prices : DataFrame
             The OHLC data.
```

## tradingsystems/ma_entries.py

```diff
@@ -1,22 +1,25 @@
 """
 Moving Average trading signals
 
 """
 
 import numpy as np
+import pandas as pd
 from technicalmethods.methods import Indicators
 
 class MovingAverageEntry():
     """
     Functions to create moving average crossover trading signals
 
     """
     @staticmethod
-    def entry_double_ma_crossover(prices, params):
+    def entry_double_ma_crossover(
+        prices: pd.DataFrame,
+        params: dict) -> tuple[pd.DataFrame, int, np.ndarray]:
         """
         Entry signal for Double Moving Average Crossover strategy
 
         Parameters
         ----------
         prices : DataFrame
             The OHLC data
@@ -103,15 +106,17 @@
         prices['min_ma'] = min_ma
         prices['max_ma'] = max_ma
 
         return prices, start, trade_signal
 
 
     @staticmethod
-    def entry_triple_ma_crossover(prices, params):
+    def entry_triple_ma_crossover(
+        prices: pd.DataFrame,
+        params: dict) -> tuple[pd.DataFrame, int, np.ndarray]:
         """
         Entry signal for Triple Moving Average Crossover strategy
 
         Parameters
         ----------
         prices : DataFrame
             The OHLC data
@@ -211,15 +216,17 @@
         prices['min_ma'] = min_ma
         prices['max_ma'] = max_ma
 
         return prices, start, trade_signal
 
 
     @staticmethod
-    def entry_quad_ma_crossover(prices, params):
+    def entry_quad_ma_crossover(
+        prices: pd.DataFrame,
+        params: dict) -> tuple[pd.DataFrame, int, np.ndarray]:
 
         """
         Entry signals for Quad Moving Average strategy
 
         Parameters
         ----------
         prices : DataFrame
```

## tradingsystems/marketdata.py

```diff
@@ -12,15 +12,18 @@
     """
     Methods for collecting data from Norgate Data, Yahoo Finance and
     AlphaVantage and extracting the long names of the Norgate Data tickers.
 
     """
     @classmethod
     def create_base_data(
-            cls, ticker=None, source=None, params=None):
+        cls,
+        ticker: str | None = None,
+        source: str | None = None,
+        params: dict | None = None) -> tuple[pd.DataFrame, dict]:
         """
         Create DataFrame of OHLC prices from NorgateData or Yahoo Finance
 
         Parameters
         ----------
         ticker : Str, optional
             Underlying to return. The default '$SPX'.
@@ -67,15 +70,17 @@
             raise ValueError(
                 'Select a data source from yahoo, norgate or alpha')
 
         return prices, params
 
 
     @classmethod
-    def reset_data(cls, tables, params):
+    def reset_data(cls,
+        tables: dict,
+        params: dict) -> tuple[dict, dict]:
         """
         Reset price table to initial data
 
         Parameters
         ----------
         tables : Dict
             Dictionary of key tables.
@@ -103,15 +108,17 @@
         else:
             params['contract_point_value'] = 1
 
         return tables_reset, params
 
 
     @staticmethod
-    def return_yahoo_data(ticker, params):
+    def return_yahoo_data(
+        ticker: str,
+        params: dict) -> pd.DataFrame:
         """
         Create DataFrame of historic prices for specified ticker using Yahoo
         Finance as the source.
 
         Parameters
         ----------
         ticker : Int
@@ -155,15 +162,18 @@
         # Set Index to Datetime
         prices.index = pd.to_datetime(prices.index)
 
         return prices
 
 
     @classmethod
-    def return_alphavantage_data(cls, params, ticker=None):
+    def return_alphavantage_data(
+        cls,
+        params: dict,
+        ticker: str | None = None) -> pd.DataFrame:
         """
         Create DataFrame of historic prices for specified ticker using
         AlphaVantage as the source.
 
         Parameters
         ----------
         ticker : Str
@@ -248,15 +258,18 @@
         # Trim data to specified dates
         prices = prices.loc[start:end]
 
         return prices
 
 
     @staticmethod
-    def _alphavantage_fx(ccy_1, ccy_2, api_key):
+    def _alphavantage_fx(
+        ccy_1: str,
+        ccy_2: str,
+        api_key: str) -> pd.DataFrame:
         """
         Create DataFrame of historic prices for an fx pair using
         AlphaVantage as the source.
 
         Parameters
         ----------
         ccy_1 : Str
@@ -280,15 +293,15 @@
         # Set fx params
         params = {'function': 'FX_DAILY',
                   'from_symbol': ccy_1,
                   'to_symbol': ccy_2,
                   'outputsize':'full',
                   'apikey': api_key}
 
-        response = requests.get(base_url, params=params)
+        response = requests.get(base_url, params=params, timeout=10)
         response_dict = response.json()
 
         _, header = response.json()
 
         #Convert to pandas dataframe
         prices = pd.DataFrame.from_dict(
             response_dict[header], orient='index')
@@ -300,15 +313,18 @@
         # Set datatype to float
         prices = prices.astype(float)
 
         return prices
 
 
     @staticmethod
-    def _alphavantage_crypto(ccy_1, ccy_2, api_key):
+    def _alphavantage_crypto(
+        ccy_1: str,
+        ccy_2: str,
+        api_key: str) -> pd.DataFrame:
         """
         Create DataFrame of historic prices for a cryptocurrency pair using
         AlphaVantage as the source.
 
         Parameters
         ----------
         ccy_1 : Str
@@ -330,15 +346,15 @@
 
         # Set crypto params
         params = {'function': 'DIGITAL_CURRENCY_DAILY',
                   'symbol': ccy_1,
                   'market': ccy_2,
                   'apikey': api_key}
 
-        response = requests.get(base_url, params=params)
+        response = requests.get(base_url, params=params, timeout=10)
         response_dict = response.json()
 
         _, header = response.json()
 
         #Convert to pandas dataframe
         prices = pd.DataFrame.from_dict(
             response_dict[header], orient='index')
@@ -354,15 +370,17 @@
         # Set datatype to float
         prices = prices.astype(float)
 
         return prices
 
 
     @staticmethod
-    def _alphavantage_equity(ticker, api_key):
+    def _alphavantage_equity(
+        ticker: str,
+        api_key: str) -> pd.DataFrame:
         """
         Create DataFrame of historic prices for an equity ticker using
         AlphaVantage as the source.
 
         Parameters
         ----------
         ticker : Str
@@ -382,15 +400,15 @@
 
         # Set equity params
         params = {'function': 'TIME_SERIES_DAILY_ADJUSTED',
                   'symbol': ticker,
                   'outputsize':'full',
                   'apikey': api_key}
 
-        response = requests.get(base_url, params=params)
+        response = requests.get(base_url, params=params, timeout=10)
         response_dict = response.json()
 
         _, header = response.json()
 
         #Convert to pandas dataframe
         prices = pd.DataFrame.from_dict(
             response_dict[header], orient='index')
@@ -429,15 +447,17 @@
 class NorgateFunctions():
     """
     Methods using an import from Norgate Data
 
     """
 
     @staticmethod
-    def return_norgate_data(ticker, params):
+    def return_norgate_data(
+        ticker: str,
+        params: dict) -> pd.DataFrame:
         """
         Create DataFrame of historic prices for specified ticker using Norgate
         Data as the source.
 
         Parameters
         ----------
         ticker : Str
@@ -462,15 +482,18 @@
             end_date=params['end_date'],
             format=timeseriesformat)
 
         return prices
 
 
     @staticmethod
-    def contract_data(ticker, prices, params):
+    def contract_data(
+        ticker: str,
+        prices: pd.DataFrame,
+        params: dict) -> dict:
         """
         Specifies per-contract-margin and contract-point-value data
 
         Parameters
         ----------
         ticker : Str
             Norgate data ticker.
@@ -504,15 +527,15 @@
         else:
             params['contract_point_value'] = 1
 
         return params
 
 
     @staticmethod
-    def get_norgate_name_dict():
+    def get_norgate_name_dict() -> dict:
         """
         Creates a dictionary of the long names of the Norgate tickers.
 
         Returns
         -------
         norgate_name_dict : Dict
             Dictionary lookup of Norgate tickers to long names.
```

## tradingsystems/pnl.py

```diff
@@ -11,15 +11,18 @@
     """
     Functions for calculating trade profits, mark to market equity, trade
     runs etc.
 
     """
 
     @classmethod
-    def profit_data(cls, prices, params):
+    def profit_data(
+        cls,
+        prices: pd.DataFrame,
+        params: dict) -> pd.DataFrame:
         """
         Adds profit fields to the OHLC data
 
         Parameters
         ----------
         prices : DataFrame
             The OHLC data.
@@ -55,15 +58,18 @@
         # Calculate margin utilisation
         prices = cls._margin_calc(prices=prices, params=params)
 
         return prices
 
 
     @classmethod
-    def _pnl_mtm(cls, prices, params):
+    def _pnl_mtm(
+        cls,
+        prices: pd.DataFrame,
+        params: dict) -> pd.DataFrame:
         """
         Calculate pnl and mark to market columns
 
         Parameters
         ----------
         prices : DataFrame
             The OHLC data and trades signals.
@@ -93,15 +99,17 @@
                                   * prices['Close']
                                   * params['contract_point_value'])
 
         return prices
 
 
     @staticmethod
-    def _daily_pnl(prices, params):
+    def _daily_pnl(
+        prices: pd.DataFrame,
+        params: dict) -> pd.DataFrame:
         """
         Calculate daily PNL
 
         Parameters
         ----------
         prices : DataFrame
             The OHLC data and trades signals.
@@ -206,15 +214,18 @@
         prices['daily_pnl'] = (prices['current_trade_pnl']
                                + prices['last_day_trade_pnl'])
 
         return prices
 
 
     @classmethod
-    def _cumulative_trade_pnl_and_equity(cls, prices, equity):
+    def _cumulative_trade_pnl_and_equity(
+        cls,
+        prices: pd.DataFrame,
+        equity: float) -> pd.DataFrame:
         """
         Calculate cumulative per trade pnl and various account equity series
 
         Parameters
         ----------
         prices : DataFrame
             The OHLC data and trades signals.
@@ -236,15 +247,17 @@
 
         prices = cls._trade_drawback(prices=prices)
 
         return prices
 
 
     @staticmethod
-    def _pnl_equity(prices, equity):
+    def _pnl_equity(
+        prices: pd.DataFrame,
+        equity: float) -> pd.DataFrame:
         """
         Calculate cumulative per trade pnl and open, closed and mtm equity
         series
 
         Parameters
         ----------
         prices : DataFrame
@@ -398,15 +411,17 @@
         prices['closed_equity'] = closed_equity
         prices['open_equity'] = open_equity
 
         return prices
 
 
     @staticmethod
-    def _min_max_equity(prices, equity):
+    def _min_max_equity(
+        prices: pd.DataFrame,
+        equity: float) -> pd.DataFrame:
         """
         Calculate min and max mtm equity, closed equity, max retracement and
         ulcer index input series
 
         Parameters
         ----------
         prices : DataFrame
@@ -466,15 +481,16 @@
         prices['min_mtm_equity'] = min_mtm_equity
         prices['ulcer_index_d_sq'] = ulcer_index_d_sq
 
         return prices
 
 
     @staticmethod
-    def _max_dd_gain(prices):
+    def _max_dd_gain(
+        prices: pd.DataFrame) -> pd.DataFrame:
         """
         Calculate max drawdown and max equity gain
 
         Parameters
         ----------
         prices : DataFrame
             The OHLC data and trades signals.
@@ -521,15 +537,16 @@
         prices['max_gain'] = max_gain
         prices['max_gain_perc'] = max_gain_perc
 
         return prices
 
 
     @staticmethod
-    def _trade_drawback(prices):
+    def _trade_drawback(
+        prices: pd.DataFrame) -> pd.DataFrame:
         """
         Calculate max trade pnl drawback
 
         Parameters
         ----------
         prices : DataFrame
             The OHLC data and trades signals.
@@ -567,15 +584,17 @@
         prices['trade_pnl_drawback'] = trade_pnl_drawback
         prices['trade_pnl_drawback_perc'] = trade_pnl_drawback_perc
 
         return prices
 
 
     @staticmethod
-    def _perfect_profit(prices, params):
+    def _perfect_profit(
+        prices: pd.DataFrame,
+        params: dict) -> pd.DataFrame:
         """
         Theoretical optimal of buying every low and selling every high
 
         Parameters
         ----------
         prices : DataFrame
             The OHLC data, trades signals and pnl.
@@ -617,15 +636,17 @@
         prices['total_perfect_profit'] = prices[
             'daily_perfect_profit'].cumsum()
 
         return prices
 
 
     @staticmethod
-    def _margin_calc(prices, params):
+    def _margin_calc(
+        prices: pd.DataFrame,
+        params: dict) -> pd.DataFrame:
 
         prices['total_margin'] = np.array([0.0]*len(prices))
 
         if params['ticker'][0] == '&':
             prices['initial_margin'] = (
                 prices['position_size'] * params['per_contract_margin'])
 
@@ -638,15 +659,16 @@
                 prices['initial_margin'][row]
                 + max(0, -prices['cumulative_trade_pnl'][row]))
 
         return prices
 
 
     @staticmethod
-    def time_to_recover(prices):
+    def time_to_recover(
+        prices: pd.DataFrame) -> int | str:
         """
         Calculate the time taken for largest loss from peak to trough
 
         Parameters
         ----------
         prices : DataFrame
             The core OHLC DataFrame.
@@ -673,15 +695,15 @@
         else:
             dd_length = 'N/A'
 
         return dd_length
 
 
     @staticmethod
-    def time_max_gain(prices):
+    def time_max_gain(prices: pd.DataFrame) -> int:
         """
         Calculate the time taken for largest gain from trough to peak
 
         Parameters
         ----------
         prices : DataFrame
             The core OHLC DataFrame.
@@ -704,16 +726,19 @@
 
         # Calculate the time taken from zero to this max gain
         gain_length = (gain_rev[max_gain_loc:].values == 0).argmax()
 
         return gain_length
 
 
-    @staticmethod
-    def create_monthly_data(prices, equity):
+    @classmethod
+    def create_monthly_data(
+        cls,
+        prices: pd.DataFrame,
+        equity: int) -> pd.DataFrame:
         """
         Create monthly summary data
 
         Parameters
         ----------
         prices : DataFrame
             The OHLC data.
@@ -722,59 +747,17 @@
 
         Returns
         -------
         monthly_data : DataFrame
             The monthly summary data.
 
         """
-        # Create empty DataFrame
-        monthly_data = pd.DataFrame()
-
-        # Summarize daily pnl data by resampling to monthly
-        monthly_data['total_net_profit'] = prices[
-            'daily_pnl'].resample('1M').sum()
-        monthly_data['average_net_profit'] = prices[
-            'daily_pnl'].resample('1M').mean()
-        monthly_data['max_net_profit'] = prices[
-            'daily_pnl'].resample('1M').max()
-        monthly_data['min_net_profit'] = prices[
-            'daily_pnl'].resample('1M').min()
-
-        # Create arrays of zeros to hold data
-        monthly_data['beginning_equity'] = np.array([0.0]*len(monthly_data))
-        monthly_data['additions'] = np.array([0.0]*len(monthly_data))
-        monthly_data['withdrawals'] = np.array([0.0]*len(monthly_data))
-        monthly_data['end_equity'] = np.array([0.0]*len(monthly_data))
-        monthly_data['return'] = np.array([0.0]*len(monthly_data))
-        monthly_data['beginning_equity_raw'] = np.array(
-            [0.0]*len(monthly_data))
-        monthly_data['end_equity_raw'] = np.array([0.0]*len(monthly_data))
-        monthly_data['return_raw'] = np.array([0.0]*len(monthly_data))
-        monthly_data['abs_loss'] = np.array([0.0]*len(monthly_data))
-        monthly_data['abs_loss_raw'] = np.array([0.0]*len(monthly_data))
-
-        # Set initial values
-        monthly_data['additions'].iloc[0] = equity
-        monthly_data['end_equity'].iloc[0] = (
-            monthly_data['beginning_equity'].iloc[0]
-            + monthly_data['additions'].iloc[0]
-            + monthly_data['withdrawals'].iloc[0]
-            + monthly_data['total_net_profit'].iloc[0])
-        monthly_data['return'].iloc[0] = (
-            (monthly_data['total_net_profit'].iloc[0])
-            / (monthly_data['beginning_equity'].iloc[0]
-               + monthly_data['additions'].iloc[0]
-               + monthly_data['withdrawals'].iloc[0]))
-        monthly_data['beginning_equity_raw'].iloc[0] = equity
-        monthly_data['end_equity_raw'].iloc[0] = (
-            monthly_data['beginning_equity_raw'].iloc[0]
-            + monthly_data['total_net_profit'].iloc[0])
-        monthly_data['return_raw'].iloc[0] = (
-            (monthly_data['total_net_profit'].iloc[0])
-            / (monthly_data['beginning_equity_raw'].iloc[0]))
+        # Set up monthly data DataFrame
+        monthly_data = cls._initialise_monthly_data(
+            prices=prices, equity=equity)
 
         # For each month
         for row in range(1, len(monthly_data)):
 
             # Beginning equity is the closing equity from the prior period
             # Raw data keeps all the profits invested whereas the other resets
             # the equity balance each year
@@ -834,7 +817,60 @@
             # For use in Gain to Pain Ratio, absolute loss is the positive
             # value of the negative monthly returns
             if monthly_data['return_raw'][row] < 0:
                 monthly_data['abs_loss_raw'][row] = -monthly_data[
                     'return_raw'][row]
 
         return monthly_data
+
+
+    @staticmethod
+    def _initialise_monthly_data(
+        prices: pd.DataFrame,
+        equity: int) -> pd.DataFrame:
+        # Create empty DataFrame
+        monthly_data = pd.DataFrame()
+
+        # Summarize daily pnl data by resampling to monthly
+        monthly_data['total_net_profit'] = prices[
+            'daily_pnl'].resample('1M').sum()
+        monthly_data['average_net_profit'] = prices[
+            'daily_pnl'].resample('1M').mean()
+        monthly_data['max_net_profit'] = prices[
+            'daily_pnl'].resample('1M').max()
+        monthly_data['min_net_profit'] = prices[
+            'daily_pnl'].resample('1M').min()
+
+        # Create arrays of zeros to hold data
+        monthly_data['beginning_equity'] = np.array([0.0]*len(monthly_data))
+        monthly_data['additions'] = np.array([0.0]*len(monthly_data))
+        monthly_data['withdrawals'] = np.array([0.0]*len(monthly_data))
+        monthly_data['end_equity'] = np.array([0.0]*len(monthly_data))
+        monthly_data['return'] = np.array([0.0]*len(monthly_data))
+        monthly_data['beginning_equity_raw'] = np.array(
+            [0.0]*len(monthly_data))
+        monthly_data['end_equity_raw'] = np.array([0.0]*len(monthly_data))
+        monthly_data['return_raw'] = np.array([0.0]*len(monthly_data))
+        monthly_data['abs_loss'] = np.array([0.0]*len(monthly_data))
+        monthly_data['abs_loss_raw'] = np.array([0.0]*len(monthly_data))
+
+        # Set initial values
+        monthly_data['additions'].iloc[0] = equity
+        monthly_data['end_equity'].iloc[0] = (
+            monthly_data['beginning_equity'].iloc[0]
+            + monthly_data['additions'].iloc[0]
+            + monthly_data['withdrawals'].iloc[0]
+            + monthly_data['total_net_profit'].iloc[0])
+        monthly_data['return'].iloc[0] = (
+            (monthly_data['total_net_profit'].iloc[0])
+            / (monthly_data['beginning_equity'].iloc[0]
+               + monthly_data['additions'].iloc[0]
+               + monthly_data['withdrawals'].iloc[0]))
+        monthly_data['beginning_equity_raw'].iloc[0] = equity
+        monthly_data['end_equity_raw'].iloc[0] = (
+            monthly_data['beginning_equity_raw'].iloc[0]
+            + monthly_data['total_net_profit'].iloc[0])
+        monthly_data['return_raw'].iloc[0] = (
+            (monthly_data['total_net_profit'].iloc[0])
+            / (monthly_data['beginning_equity_raw'].iloc[0]))
+
+        return monthly_data
```

## tradingsystems/positions.py

```diff
@@ -13,15 +13,18 @@
 
 class Positions():
     """
     Functions for calculating trade and position data.
 
     """
     @staticmethod
-    def calc_positions(prices, signal, start):
+    def calc_positions(
+        prices: pd.DataFrame,
+        signal: pd.Series,
+        start: int) -> dict:
         """
         Calculate start of day and end of day positions and any buy / sell
         trade actions
 
         Parameters
         ----------
         prices : DataFrame
@@ -73,15 +76,17 @@
         pos_dict['end_of_day_position'] = end_of_day_position
 
         return pos_dict
 
 
     @staticmethod
     def position_values(
-            prices, end_of_day_position, trade_price_dict):
+        prices: pd.DataFrame,
+        end_of_day_position: pd.Series,
+        trade_price_dict: dict) -> dict:
         """
         Calculate position values
 
         Parameters
         ----------
         prices : DataFrame
             The OHLC data.
@@ -219,23 +224,27 @@
         pos_val_dict[
             'min_trade_close_position_value'] = min_trade_close_position_value
 
         return pos_val_dict
 
 
     @classmethod
-    def position_size(cls, prices, benchmark, params):
+    def position_size(
+        cls,
+        prices: pd.DataFrame,
+        benchmark: pd.DataFrame,
+        params: dict) -> tuple[pd.DataFrame, pd.DataFrame, dict]:
         """
         Calculate trade position size
 
         Parameters
         ----------
         prices : DataFrame
             The OHLC data.
-        benchmark : Series
+        benchmark : DataFrame
             The closing prices of the benchmark series
         params : Dict
             equity : Float
                 The account equity.
             start : Int
                 Row from which trade signals can be generated.
 
@@ -294,15 +303,17 @@
             benchmark=benchmark, params=params)
 
 
         return prices, benchmark, params
 
 
     @staticmethod
-    def _benchmark_position_size(benchmark, params):
+    def _benchmark_position_size(
+        benchmark: pd.DataFrame,
+        params: dict) -> tuple[pd.DataFrame, dict]:
 
         # Set the position size to the number of shares that can be bought with
         # the initial equity
 
         # Set the number of units to use a percentage of starting equity at
         # the point when trade signals begin
         try:
@@ -330,15 +341,17 @@
         params['init_benchmark_position_size'] = benchmark[
             'benchmark_position_size'].loc[params['benchmark_start_date']]
 
         return benchmark, params
 
 
     @staticmethod
-    def _equity_constant_position_size(prices, params):
+    def _equity_constant_position_size(
+        prices: pd.DataFrame,
+        params: dict) -> tuple[pd.DataFrame, dict]:
 
         # Extract the raw trade signal from the OHLC data
         trade_number = prices['raw_trade_number']
 
         # Set the position size to the number of shares that can be
         # bought with the initial equity
 
@@ -373,15 +386,17 @@
                 prices['position_size_pp'][row] = prices[
                     'position_size_pp'][row-1]
 
         return prices, params
 
 
     @staticmethod
-    def _equity_variable_position_size(prices, params):
+    def _equity_variable_position_size(
+        prices: pd.DataFrame,
+        params: dict) -> tuple[pd.DataFrame, dict]:
 
         # Extract the raw trade signal from the OHLC data
         trade_number = prices['raw_trade_number']
 
         # For each row since the first trade entry
         for row in range(params['first_trade_start'], len(prices['Close'])):
 
@@ -420,15 +435,17 @@
                 prices['position_size_pp'][row] = prices[
                     'position_size_pp'][row-1]
 
         return prices, params
 
 
     @staticmethod
-    def _atr_position_size(prices, params):
+    def _atr_position_size(
+        prices: pd.DataFrame,
+        params: dict) -> tuple[pd.DataFrame, dict]:
 
         # Calculate ATR levels
         prices['position_ATR'] = Indicators.ATR(
             prices['High'], prices['Low'], prices['Close'],
             params['atr_pos_size'])
 
         # Replace nan values with difference between high and low prices
@@ -506,15 +523,17 @@
                 prices['position_size_pp'][row] = prices[
                     'position_size_pp'][row-1]
 
         return prices, params
 
 
     @staticmethod
-    def _fixed_position_size(prices, params):
+    def _fixed_position_size(
+        prices: pd.DataFrame,
+        params: dict) -> tuple[pd.DataFrame, dict]:
 
         # Extract the raw trade signal from the OHLC data
         trade_number = prices['raw_trade_number']
 
         units = params['fixed_pos_size']
 
         # For each row since the first trade entry
```

## tradingsystems/reports.py

```diff
@@ -3,28 +3,34 @@
 
 """
 
 import datetime as dt
 from decimal import Decimal
 import math
 import numpy as np
+import pandas as pd
 from scipy.stats import skew, kurtosis
 from tradingsystems.pnl import Profit
 from tradingsystems.winloss import Runs
-
+# pylint: disable=C0209
 
 class PerfReport():
     """
     Create a dictionary of performance data and produce a text report of the
     system performance.
 
     """
 
     @classmethod
-    def performance_data(cls, tables, params, labels, norgate_name_dict):
+    def performance_data(
+        cls,
+        tables: dict,
+        params: dict,
+        labels: dict,
+        norgate_name_dict: dict) -> dict:
         """
         Create dictionary of performance data.
 
         Parameters
         ----------
         prices : DataFrame
             The OHLC data, trades signals and pnl.
@@ -260,15 +266,20 @@
 
         perf_dict.update(placeholder_dict)
 
         return perf_dict
 
 
     @staticmethod
-    def _perf_data_init(perf_dict, prices, params, labels, norgate_name_dict):
+    def _perf_data_init(
+        perf_dict: dict,
+        prices: pd.DataFrame,
+        params: dict,
+        labels: dict,
+        norgate_name_dict: dict) -> dict:
 
         # Contract and strategy details
         if (params['ticker_source'] == 'alpha'
             and params['asset_type'] in ['fx', 'crypto']):
             perf_dict['contract'] = params['ccy_1'] + params['ccy_2']
         else:
             perf_dict['contract'] = params['ticker']
@@ -296,15 +307,17 @@
         perf_dict['start_date'] = prices.index[0].date().strftime("%d/%m/%y")
         perf_dict['end_date'] = prices.index[-1].date().strftime("%d/%m/%y")
 
         return perf_dict
 
 
     @staticmethod
-    def _perf_data_trades(perf_dict, tables):
+    def _perf_data_trades(
+        perf_dict: dict,
+        tables: dict) -> dict:
 
         prices = tables['prices']
 
         # Calculate trade data
         perf_dict['trade_data_dict'] = Runs.trade_data(prices)
 
         perf_dict['total_trades'] = perf_dict['trade_data_dict']['num_trades']
@@ -411,15 +424,18 @@
             perf_dict['net_pnl']
             / len(perf_dict['trade_data_dict']['trades']), 2)
 
         return perf_dict
 
 
     @staticmethod
-    def _perf_data_stat_measures(perf_dict, tables, params):
+    def _perf_data_stat_measures(
+        perf_dict: dict,
+        tables: dict,
+        params: dict) -> dict:
 
         prices = tables['prices']
 
         # Riskfree Rate
         perf_dict['riskfree_rate'] = params['riskfree']
 
         # Mean Price
@@ -531,15 +547,15 @@
             tables['monthly_data']['return'].sum()
             / tables['monthly_data']['abs_loss'].sum(), 2)
 
         return perf_dict
 
 
     @classmethod
-    def report_table(cls, input_dict):
+    def report_table(cls, input_dict: dict) -> None:
         """
         Print out backtesting performance results.
 
         Modelled on performance results presented in Robert Pardo, 1992,
         Design, Testing and Optimization of Trading Systems
 
         Parameters
@@ -575,15 +591,15 @@
         cls._report_key_perf(input_dict)
 
         # Data distribution statistics
         cls._report_data_dist(input_dict)
 
 
     @staticmethod
-    def _report_header(input_dict):
+    def _report_header(input_dict: dict) -> None:
 
         # Format header - centred and with lines above and below
         print('='*78)
         print('{:^78}'.format('Performance Analysis Report'))
         print('-'*78)
 
         # Contract traded on left and period covered on right
@@ -647,15 +663,18 @@
             input_dict['av_trade'],
             '',
             'Model Efficiency : %',
             input_dict['model_efficiency']))
 
 
     @staticmethod
-    def _report_trades(input_dict, win_run_dict, loss_run_dict):
+    def _report_trades(
+        input_dict: dict,
+        win_run_dict: dict,
+        loss_run_dict: dict) -> None:
 
         # Headers for # trades, Max, Min and Average with lines above and below
         print('-'*78)
         print('{:>16}:{:^10}:{:^17}:{:^17}:{:^14}'.format(
             '',
             '# Trades',
             'Maximum',
@@ -717,15 +736,15 @@
             input_dict['av_win_loss_ratio']))
 
         # Separating line
         print('-'*78)
 
 
     @staticmethod
-    def _report_equity(input_dict):
+    def _report_equity(input_dict: dict) -> None:
 
         # Open and Closed equity
         print('Open Equity.......... ${:>10}{:<6}{}{:>10}'.format(
             input_dict['open_equity'],
             '',
             'Closed Equity......... $',
             input_dict['closed_equity']))
@@ -807,15 +826,15 @@
             input_dict['long_only_pnl_spx'],
             '',
             'Long Only SPX Ann RoR. %',
             input_dict['annual_long_only_spx_ror']))
 
 
     @staticmethod
-    def _report_key_perf(input_dict):
+    def _report_key_perf(input_dict: dict) -> None:
 
         # Key Performance Measures
         print('-'*78)
         print('{:^78}'.format('Key Performance Measures'))
         print('-'*78)
 
         # Sharpe Ratio & Information Ratio
@@ -863,15 +882,15 @@
             input_dict['close_price_skewness'],
             '',
             'Kurtosis Price........  ',
             input_dict['close_price_kurtosis']))
 
 
     @staticmethod
-    def _report_data_dist(input_dict):
+    def _report_data_dist(input_dict: dict) -> None:
 
         # Return Distribution statistics
 
         # Mean & Standard Deviation of Returns
         print('Mean Return.......... %{:>10}{:<6}{}{:>10}'.format(
             input_dict['close_return_mean'],
             '',
@@ -893,15 +912,15 @@
             input_dict['close_return_ann_vol']))
 
         # Closing line
         print('='*78)
 
 
     @staticmethod
-    def _dict_format(input_dict):
+    def _dict_format(input_dict: dict) -> dict:
         """
         Format the performance dictionary so that the financial data is
         rounded to 2 decimal places and set values as strings
 
         Parameters
         ----------
         input_dict : Dict
```

## tradingsystems/signals.py

```diff
@@ -15,15 +15,18 @@
 class Signals():
     """
     Calculate entry signals
 
     """
 
     @classmethod
-    def raw_entry_signals(cls, tables, params):
+    def raw_entry_signals(
+        cls,
+        tables: dict,
+        params: dict) -> tuple[dict, dict, dict]:
         """
         Generate the initial raw entry signals, positions and trades
 
         Parameters
         ----------
         prices : DataFrame
             The OHLC data.
@@ -111,15 +114,18 @@
             input_dict=raw_trade_price_dict,
             title_modifier='raw_')
 
         return tables, params, raw_trade_price_dict
 
 
     @classmethod
-    def entry_signal(cls, tables, params):
+    def entry_signal(
+        cls,
+        tables: dict,
+        params: dict) -> tuple[pd.DataFrame, int, np.ndarray]:
         """
         Calculate trade entry signals
 
         Parameters
         ----------
         prices : DataFrame
             The OHLC data.
@@ -270,15 +276,18 @@
                     time_period=params['entry_period'],
                     threshold=params['entry_threshold'])
 
         return tables['prices'], start, signal
 
 
     @classmethod
-    def exit_and_stop_signals(cls, prices, params):
+    def exit_and_stop_signals(
+        cls,
+        prices: pd.DataFrame,
+        params: dict) -> pd.DataFrame:
         """
         Calculate trade exit and stop signals.
 
         Parameters
         ----------
         prices : DataFrame
             The OHLC data
@@ -342,15 +351,18 @@
         else:
             prices['stop_signal'] = np.array([0]*len(prices))
 
         return prices
 
 
     @classmethod
-    def _exit_signal(cls, prices, params):
+    def _exit_signal(
+        cls,
+        prices: pd.DataFrame,
+        params: dict) -> tuple[pd.DataFrame, np.ndarray]:
         """
         Calculate trade exit signals.
 
         Parameters
         ----------
         prices : DataFrame
             The OHLC data
@@ -455,15 +467,18 @@
                 prices=prices,
                 trigger_value=prices['exit_profit_target'])
 
         return prices, exit_
 
 
     @classmethod
-    def _stop_signal(cls, prices, params):
+    def _stop_signal(
+        cls,
+        prices: pd.DataFrame,
+        params: dict) -> tuple[pd.DataFrame, np.ndarray]:
         """
         Calculate trade stop signals
 
         Parameters
         ----------
         prices : DataFrame
             The OHLC data
@@ -534,15 +549,17 @@
                 prices=prices,
                 trigger_value=prices['stop_trailing_high_low'])
 
         return prices, stop
 
 
     @staticmethod
-    def final_signals(params, tables):
+    def final_signals(
+        params: dict,
+        tables: dict) -> dict:
         """
         Concatenate entry, exit and stop signals into a combined signal.
 
         Parameters
         ----------
         prices : DataFrame
             The OHLC data.
```

## tradingsystems/systems.py

```diff
@@ -2,14 +2,15 @@
 Calculate performance for various technical trading systems and display the
 results in table and graph form.
 
 """
 
 # Imports
 import copy
+import pandas as pd
 from tradingsystems.graphs import PerformanceGraph as perfgraph
 from tradingsystems.marketdata import Markets, NorgateFunctions
 from tradingsystems.positions import Positions
 from tradingsystems.pnl import Profit
 from tradingsystems.reports import PerfReport
 from tradingsystems.signals import Signals
 from tradingsystems.systems_params import system_params_dict
@@ -127,14 +128,18 @@
     """
 
     def __init__(self, **kwargs):
 
         # Import dictionary of default parameters
         self.default_dict = copy.deepcopy(system_params_dict)
 
+        self.params = {}
+        self.tables = {}
+        self.labels = {}
+
         # Longnames for Norgate Tickers
         self.norgate_name_dict = {}
 
         if kwargs.get('return_data', False):
             # Generate backtest
             self.run_backtest(**kwargs)
 
@@ -269,15 +274,15 @@
 
         self.params = params
         self.tables = tables
         self.labels = labels
 
 
     @staticmethod
-    def _init_params(inputs):
+    def _init_params(inputs: dict) -> dict:
         """
         Initialise parameter dictionary
 
         Parameters
         ----------
         inputs : Dict
             Dictionary of parameters supplied to the function.
@@ -340,48 +345,54 @@
                     if param in stop_signal_dict[types[2]].keys():
                         params[param] = stop_signal_dict[types[2]][str(param)]
 
         return params
 
 
     @classmethod
-    def prepare_data(cls, params, tables, market_data=None):
+    def prepare_data(
+        cls,
+        params: dict,
+        tables: dict,
+        market_data: pd.DataFrame | None = None) -> tuple[dict, dict]:
         """
         Get market data ready to be analysed
 
         Parameters
         ----------
-        params : TYPE
-            DESCRIPTION.
-        tables : TYPE
-            DESCRIPTION.
-        data : TYPE, optional
-            DESCRIPTION. The default is None.
+        params : Dict
+            Dictionary of parameters.
+        tables : Dict
+            Dictionary of tables.
+        data : DataFrame, optional
+            DataFrame of OHLC data. The default is None.
 
         Returns
         -------
-        params : TYPE
-            DESCRIPTION.
-        tables : TYPE
-            DESCRIPTION.
+        params : Dict
+            Dictionary of parameters.
+        tables : Dict
+            Dictionary of tables.
 
         """
         params = cls._prepare_dates(params=params, market_data=market_data)
 
         params, tables = cls._prepare_ticker_data(
             params=params, tables=tables, market_data=market_data)
 
         params, tables = cls._prepare_benchmark_data(
             params=params, tables=tables)
 
         return params, tables
 
 
     @staticmethod
-    def _prepare_dates(params, market_data=None):
+    def _prepare_dates(
+        params: dict,
+        market_data: pd.DataFrame | None = None) -> dict:
 
         if market_data is None:
             # Set the start and end dates if not provided
             params['start_date'], params['end_date'] = Dates.date_set(
                 start_date=params['start_date'], end_date=params['end_date'],
                 lookback=params['lookback'])
 
@@ -389,15 +400,18 @@
             params['start_date'] = str(market_data[0][1].index[0].date())
             params['end_date'] = str(market_data[0][1].index[-1].date())
 
         return params
 
 
     @staticmethod
-    def _prepare_ticker_data(params, tables, market_data=None):
+    def _prepare_ticker_data(
+        params: dict,
+        tables: dict,
+        market_data: pd.DataFrame | None = None) -> tuple[dict, dict]:
 
         if params['input_data'] == 'reset':
             # Reset the prices and benchmark tables to the source data
             tables, params = Markets.reset_data(tables, params)
 
         elif params['input_data'] == 'set':
             tables['prices'] = market_data
@@ -413,16 +427,19 @@
                     ticker=params['ticker'], prices=tables['prices'],
                     params=params)
             else:
                 params['contract_point_value'] = 1
 
         return params, tables
 
+
     @staticmethod
-    def _prepare_benchmark_data(tables, params):
+    def _prepare_benchmark_data(
+        params: dict,
+        tables: dict) -> tuple[dict, dict]:
 
         # Extract benchmark data for Beta calculation
         if params['ticker_source'] == 'norgate':
             tables['benchmark'], params = Markets.create_base_data(
                 ticker=params['bench_ticker'], source=params['bench_source'],
                 params=params)
         else:
@@ -447,15 +464,15 @@
         Prints the performance report to the console.
 
         """
         # Print out results
         PerfReport.report_table(input_dict=self.tables['perf_dict'])
 
 
-    def performance_graph(self, signals=None):
+    def performance_graph(self, signals: bool | None = None):
         """
         Graph the performance of the strategy
 
         Parameters
         ----------
         signals : Bool
             Whether to plot the Buy/Sell signals on the price chart.
@@ -506,15 +523,15 @@
     def __init__(self, **kwargs):
 
         #self.system_dict = self.run_individual_tests(**kwargs)
         self.system_dict = self.run_individual_tests_with_data(**kwargs)
 
 
     @staticmethod
-    def run_individual_tests(portfolio, **kwargs):
+    def run_individual_tests(portfolio: dict, **kwargs) -> dict:
         """
         Run backtests for each of the provided tickers.
 
         Parameters
         ----------
         portfolio : Dict
             Dictionary of lists of underlying tickers.
@@ -563,15 +580,15 @@
                 system_dict[underlying].update(
                     {'monthly_data':strat.tables['monthly_data']})
 
         return system_dict
 
 
     @staticmethod
-    def run_individual_tests_with_data(portfolio, **kwargs):
+    def run_individual_tests_with_data(portfolio: dict, **kwargs) -> dict:
         """
         Run backtests for each of the provided tickers.
 
         Parameters
         ----------
         portfolio : Dict
             Dictionary of lists of underlying tickers.
@@ -644,63 +661,75 @@
         system_dict['benchmark'] = NorgateFunctions.return_norgate_data(
             '$SPX', params)
 
         return system_dict
 
 
     @staticmethod
-    def prep_portfolio_list(data, portfolio, asset_class, num_tickers):
+    def prep_portfolio_list(
+        top_ticker_list: list,
+        portfolio: dict,
+        asset_class: str,
+        num_tickers: int) -> dict:
         """
         Prepare portfolio of tickers from top trend data
 
         Parameters
         ----------
-        data : TrendStrength object
-            Model containing the top trend data.
+        top_ticker list : list
+            List of top trending tickers obtained from TrendStrength
+            object: top_trends['top_ticker_list']
         portfolio : Dict
             Dictionary to contain asset classes and ticker lists.
         asset_class : Str
             String describing the asset class.
         num_tickers : Int
             The number of tickers to choose
 
         Returns
         -------
         portfolio : Dict
             Dictionary to contain asset classes and ticker lists..
 
         """
-        input_list = data.top_trends['top_ticker_list'][:num_tickers]
+        #input_list = data.top_trends['top_ticker_list'][:num_tickers]
+        input_list = top_ticker_list[:num_tickers]
         portfolio.update({asset_class:list(zip(*input_list))[0]})
 
         return portfolio
 
 
     @staticmethod
-    def prep_portfolio_dict(data, portfolio, asset_class, num_tickers):
+    def prep_portfolio_dict(
+        top_ticker_dict: dict,
+        portfolio: dict,
+        asset_class: str,
+        num_tickers: int) -> dict:
         """
         Prepare portfolio of tickers from top trend data
 
         Parameters
         ----------
-        data : TrendStrength object
-            Model containing the top trend data.
+        top_ticker_dict : dict
+            Dictionary of top trending tickers obtained from TrendStrength
+            object: top_trends['top_ticker_dict']
         portfolio : Dict
             Dictionary to contain asset classes and ticker lists.
         asset_class : Str
             String describing the asset class.
         num_tickers : Int
             The number of tickers to choose
 
         Returns
         -------
         portfolio : Dict
             Dictionary to contain asset classes and ticker lists..
 
         """
         input_dict = {}
-        for rank, pair in data.top_trends['top_ticker_dict'].items():
+        #for rank, pair in data.top_trends['top_ticker_dict'].items():
+        for rank, pair in top_ticker_dict.items():
             if rank < num_tickers:
                 input_dict[pair[0]] = pair[1]
         portfolio.update({asset_class:input_dict})
 
         return portfolio
```

## tradingsystems/systems_params.py

```diff
@@ -195,45 +195,46 @@
         'rsi_trail':{
             'exit_period':9,
             'exit_oversold':25,
             'entry_overbought':75
             },
         'key_reversal':{
             'exit_period':10
-            },
-        'trailing_stop':{
-            'exit_amount':3000.00
-            },
+            },        
         'volatility':{
             'exit_period':5,
             'exit_threshold':1
             },
         'stoch_cross':{
             'exit_period':14,
             'exit_oversold':25,
             'entry_overbought':75
             },
-        'profit_target':{
-            'exit_amount':3000.00
-            },
         'nday_range':{
             'exit_period':10
+            },
+        'random':{},    
+        'trailing_stop':{
+            'exit_amount':3000.00
+            },
+        'profit_target':{
+            'exit_amount':3000.00
             }
         },
 
     'df_stop_signal_dict':{
-        'initial_dollar':{
-            'stop_amount':1500.00
-            },
         'sup_res':{
             'stop_period':20
             },
         'immediate_profit':{
             'stop_period':5
             },
+        'initial_dollar':{
+            'stop_amount':1500.00
+            },
         'breakeven':{
             'stop_amount':1500.00
             },
         'trail_close':{
             'stop_amount':1500.00
             },
         'trail_high_low':{
```

## tradingsystems/targets.py

```diff
@@ -1,22 +1,26 @@
 """
 Trade exit triggers
 
 """
 
+import pandas as pd
 import numpy as np
 
 class TradeTargets():
     """
     Calculate profit targets, stop loss levels etc.
 
     """
     @classmethod
     def exit_and_stop_targets(
-            cls, prices, params, trade_price_dict):
+        cls,
+        prices: pd.DataFrame,
+        params: dict,
+        trade_price_dict: dict) -> pd.DataFrame:
         """
         Calculate exit and stop targets.
 
         Parameters
         ----------
         prices : DataFrame
             The OHLC data.
@@ -51,15 +55,19 @@
                 params=params)
 
         return prices
 
 
     @classmethod
     def _exit_targets(
-            cls, prices, exit_amount, trade_price_dict, params):
+        cls,
+        prices: pd.DataFrame,
+        exit_amount: float,
+        trade_price_dict: dict,
+        params: dict) -> pd.DataFrame:
         """
         Create 4 series of exit targets
 
         Parameters
         ----------
         prices : DataFrame
             The OHLC data.
@@ -85,15 +93,19 @@
                     params=params)
 
         return prices
 
 
     @classmethod
     def _stop_targets(
-            cls, prices, stop_amount, trade_price_dict, params):
+        cls,
+        prices: pd.DataFrame,
+        stop_amount: float,
+        trade_price_dict: dict,
+        params: dict) -> pd.DataFrame:
         """
         Create 4 series of stop targets
 
         Parameters
         ----------
         prices : DataFrame
             The OHLC data.
@@ -119,15 +131,18 @@
                     params=params)
 
         return prices
 
 
     @staticmethod
     def _pnl_targets(
-            prices, dollar_amount, trade_price_dict, params):
+        prices: pd.DataFrame,
+        dollar_amount: float,
+        trade_price_dict: dict,
+        params: dict) -> tuple[np.ndarray, np.ndarray, np.ndarray, np.ndarray]:
         """
         Create profit and loss stop and exit points
 
         Parameters
         ----------
         prices : DataFrame
             The OHLC data.
```

## tradingsystems/trades.py

```diff
@@ -1,21 +1,25 @@
 """
 Calculate trades data
 
 """
 
+import pandas as pd
 import numpy as np
 
 class Trades():
     """
     Calculate trade numbers, prices and combined trade signals
 
     """
     @staticmethod
-    def trade_numbers(prices, end_of_day_position, start):
+    def trade_numbers(
+        prices: pd.DataFrame,
+        end_of_day_position: pd.Series,
+        start: int) -> np.ndarray:
         """
         Calculate the trade numbers
 
         Parameters
         ----------
         prices : DataFrame
             The OHLC data.
@@ -27,42 +31,42 @@
         Returns
         -------
         trade_number : Series
             Array of trade numbers.
 
         """
         # Extract the end of day position from the OHLC Data
-        end_of_day_position = np.array(end_of_day_position)
+        eod_pos_np = np.array(end_of_day_position)
 
         # Create numpy array of zeros to store trade numbers
         trade_number = np.array([0]*len(prices))
 
         # Set initial trade count to zero
         trade_count = 0
 
         # For each valid row in the data
         for row in range(start + 1, len(prices)):
 
             # If today's position is zero
-            if end_of_day_position[row] == 0:
+            if eod_pos_np[row] == 0:
 
                 # If yesterday's position is zero
-                if end_of_day_position[row - 1] == 0:
+                if eod_pos_np[row - 1] == 0:
 
                     # There is no open trade so set trade number to zero
                     trade_number[row] = 0
 
                 # If yesterday's position is not zero
                 else:
 
                     # Set the trade number to the current trade count
                     trade_number[row] = trade_count
 
             # If today's position is the same as yesterday
-            elif end_of_day_position[row] == end_of_day_position[row - 1]:
+            elif eod_pos_np[row] == eod_pos_np[row - 1]:
 
                 # Set the trade number to yesterdays trade number
                 trade_number[row] = trade_number[row - 1]
 
             # If today's position is non-zero and different from yesterday
             else:
 
@@ -72,15 +76,17 @@
                 # Set the trade number to the current trade count
                 trade_number[row] = trade_count
 
         return trade_number
 
 
     @staticmethod
-    def trade_prices(prices, trade_number):
+    def trade_prices(
+        prices: pd.DataFrame,
+        trade_number: pd.Series) -> dict:
         """
         Calculate per trade entry, exit, high and low prices.
 
         Parameters
         ----------
         prices : DataFrame
             The OHLC data.
@@ -173,15 +179,18 @@
         trade_price_dict['trade_close_low_price'] = trade_close_low_price
 
         return trade_price_dict
 
 
     @staticmethod
     def signal_combine(
-            prices, start, end_of_day_position, trade_signals):
+        prices: pd.DataFrame,
+        start: int,
+        end_of_day_position: pd.Series,
+        trade_signals: pd.DataFrame) -> np.ndarray:
         """
         Combine Entry, Exit and Stop signals into a single composite signal.
 
         Parameters
         ----------
         prices : DataFrame
             The OHLC data
```

## tradingsystems/utils.py

```diff
@@ -11,15 +11,18 @@
 class Labels():
     """
     Create labels for the Entry, Exit and Stop Strategies.
 
     """
 
     @classmethod
-    def strategy_labels(cls, params=None, default_dict=None):
+    def strategy_labels(
+        cls,
+        params: dict,
+        default_dict: dict) -> tuple[str, str, str]:
         """
         Create label and price signal for chosen strategy
 
         Parameters
         ----------
         **kwargs : Various
             The input parameters necessary for the chosen strategy.
@@ -50,15 +53,17 @@
             stop_label = cls._stop_label(
                 params=params, default_dict=default_dict)
 
         return entry_label, exit_label, stop_label
 
 
     @staticmethod
-    def _entry_label(params=None, default_dict=None):
+    def _entry_label(
+        params: dict,
+        default_dict: dict) -> str:
 
         # Simple or Exponential Moving Average label
         if params['simple_ma']:
             ma_type_label = 'S'
         else:
             ma_type_label = 'E'
 
@@ -185,15 +190,17 @@
             raise ValueError("Please enter a valid entry type")
 
 
         return entry_label
 
 
     @staticmethod
-    def _exit_label(params=None, default_dict=None):
+    def _exit_label(
+        params: dict,
+        default_dict: dict) -> str:
 
         # Exit labels
 
         # Parabolic SAR
         if params['exit_type'] == 'sar':
 
             # Set the exit label
@@ -247,24 +254,34 @@
         elif params['exit_type'] in ['sup_res', 'key_reversal', 'nday_range']:
 
             # Set the exit label
             exit_label = (str(params['exit_period'])
                           +'-day '
                           +default_dict['df_exit_signal_labels'][
                               params['exit_type']])
+            
+        # Random exit
+        elif params['exit_type'] in ['random']:
+
+            # Set the exit label
+            exit_label = (default_dict['df_exit_signal_labels'][
+                params['exit_type']]
+                +' exit')     
 
         # Otherwise raise an error
         else:
             raise ValueError("Please enter a valid exit type")
 
         return exit_label
 
 
     @staticmethod
-    def _stop_label(params=None, default_dict=None):
+    def _stop_label(
+        params: dict,
+        default_dict: dict) -> str:
 
         # Stop labels
 
         # Initial Dollar, Breakeven, Trailing Close and Trailing High Low
         if params['stop_type'] in ['initial_dollar', 'breakeven',
                                    'trail_close', 'trail_high_low']:
 
@@ -291,15 +308,15 @@
             raise ValueError("Please enter a valid stop type")
 
 
         return stop_label
 
 
     @staticmethod
-    def position_size_label(params):
+    def position_size_label(params: dict) -> dict:
         """
         Create position size label
 
         Parameters
         ----------
         params : Dict
             Dictionary of parameters.
@@ -337,15 +354,18 @@
 class Dates():
     """
     Date calculation and formatting functions.
 
     """
 
     @staticmethod
-    def date_set(start_date, end_date, lookback):
+    def date_set(
+        start_date: str,
+        end_date: str,
+        lookback: int) -> tuple[str, str]:
         """
         Create start and end dates if not supplied
 
         Parameters
         ----------
         start_date : Str, optional
             Date to begin backtest. Format is YYYY-MM-DD. The default is 750
@@ -382,15 +402,17 @@
 
 class Reformat():
     """
     Functions for mapping / scaling data
     """
 
     @staticmethod
-    def position_scale(pos_dict, position_size):
+    def position_scale(
+        pos_dict: dict,
+        position_size: pd.Series) -> dict:
         """
         Scale raw positions by position size
 
         Parameters
         ----------
         raw_pos_dict : Dict
             Dictionary of start of day, end of day positions and trade actions.
@@ -426,15 +448,18 @@
         scaled_pos_dict['trade_action'] = np.array(trade_action)
         scaled_pos_dict['end_of_day_position'] = np.array(end_of_day_position)
 
         return scaled_pos_dict
 
 
     @staticmethod
-    def map_to_prices(prices, input_dict, title_modifier):
+    def map_to_prices(
+        prices: pd.DataFrame,
+        input_dict: dict,
+        title_modifier: str) -> pd.DataFrame:
         """
         Map dictionary of arrays to the OHLC data
 
         Parameters
         ----------
         prices : DataFrame
             The OHLC data.
```

## tradingsystems/winloss.py

```diff
@@ -9,15 +9,15 @@
 class Runs():
     """
     Calculate data on winning and losing trades and win/loss runs
 
     """
 
     @staticmethod
-    def trade_data(prices):
+    def trade_data(prices: pd.DataFrame) -> dict:
         """
         Create dictionary of trades, count of the number of trades and lists /
         dictionaries of winning and losing trades
 
         Parameters
         ----------
         prices : DataFrame
@@ -55,17 +55,17 @@
 
             # Assign this number (rounded to 2dp) to the trades dictionary
             trades[trade_number] = np.round(profit, 2)
 
         # Split winning and losing trades
         # Create empty win/loss dictionaries and lists
         trades_win_dict = {}
-        trades_win_list = list()
+        trades_win_list = []
         trades_loss_dict = {}
-        trades_loss_list = list()
+        trades_loss_list = []
 
         # for each trade and profit in the trades dictionary
         for key, value in trades.items():
 
             # If the profit is negative
             if value < 0:
 
@@ -89,15 +89,18 @@
             'trades_loss_list':trades_loss_list
             }
 
         return trade_data_dict
 
 
     @classmethod
-    def trade_runs(cls, input_trades_list, run_type):
+    def trade_runs(
+        cls,
+        input_trades_list: list,
+        run_type: str) -> dict:
         """
         Produce data for winning or losing runs of trades
 
         Parameters
         ----------
         input_trades_list : List
             List of winning or losing trades.
@@ -159,15 +162,15 @@
             name_dict['av_run_pnl_str']:av_run_pnl,
             name_dict['pnl_str']:pnl
             }
 
         return run_dict
 
     @staticmethod
-    def _calc_trade_runs(input_trades_list):
+    def _calc_trade_runs(input_trades_list: list) -> list[tuple[int, int]]:
 
         # Set initial values
         max_run_count = 1
         run_count = 1
         run_trades_list = []
         total_run_trades_list = []
         last_trade_count = 0
@@ -238,15 +241,17 @@
         # Tuple for each run of PNL and number of trades.
         pnl = sorted([(sum(x), len(x)) for x in total_run_trades_list])
 
         return pnl
 
 
     @staticmethod
-    def _calc_min_max_runs(pnl, run_type):
+    def _calc_min_max_runs(
+        pnl: list[tuple[int, int]],
+        run_type: str) -> dict[str, int]:
 
         # Values to select for winning runs
         if run_type == 'win':
 
             # If there are any winning trades
             if pnl:
                 max_run_pnl = pnl[-1][0]
@@ -285,15 +290,15 @@
             'min_run_count':min_run_count
             }
 
         return min_max_run_dict
 
 
     @staticmethod
-    def _calc_run_names(run_type):
+    def _calc_run_names(run_type: str) -> dict:
 
         max_run_pnl_str = 'max_'+run_type+'_run_pnl'
         max_run_count_str = 'max_'+run_type+'_run_count'
         min_run_pnl_str = 'min_'+run_type+'_run_pnl'
         min_run_count_str = 'min_'+run_type+'_run_count'
         num_runs_str = 'num_'+run_type+'_runs'
         av_run_count_str = 'av_'+run_type+'_run_count'
```

## Comparing `tradingsystems-0.5.9.dist-info/LICENSE` & `tradingsystems-0.6.3.dist-info/LICENSE`

 * *Files identical despite different names*

## Comparing `tradingsystems-0.5.9.dist-info/METADATA` & `tradingsystems-0.6.3.dist-info/METADATA`

 * *Files 0% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: tradingsystems
-Version: 0.5.9
+Version: 0.6.3
 Summary: End of day backtesting of Technical trading rules.
 Home-page: https://github.com/GBERESEARCH/tradingsystems
 Author: GBERESEARCH
 Author-email: gberesearch@gmail.com
 License: MIT
 Description-Content-Type: text/markdown
 License-File: LICENSE
```

