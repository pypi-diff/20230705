# Comparing `tmp/pdfCropMargins-2.0.2-py2.py3-none-any.whl.zip` & `tmp/pdfCropMargins-2.0.3-py2.py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,27 +1,27 @@
-Zip file size: 1840199 bytes, number of entries: 25
--rw-rw-r--  2.0 unx      215 b- defN 23-Jun-22 21:12 pdfCropMargins/__init__.py
+Zip file size: 1840612 bytes, number of entries: 25
+-rw-rw-r--  2.0 unx      215 b- defN 23-Jul-04 23:03 pdfCropMargins/__init__.py
 -rw-rw-r--  2.0 unx      197 b- defN 22-Dec-07 15:25 pdfCropMargins/__main__.py
--rw-rw-r--  2.0 unx    14131 b- defN 23-Jun-09 02:45 pdfCropMargins/calculate_bounding_boxes.py
+-rw-rw-r--  2.0 unx    14248 b- defN 23-Jun-29 02:19 pdfCropMargins/calculate_bounding_boxes.py
 -rw-rw-r--  2.0 unx      181 b- defN 22-Dec-07 15:25 pdfCropMargins/directory_locator.py
 -rw-rw-r--  2.0 unx    31255 b- defN 23-Jun-22 03:21 pdfCropMargins/external_program_calls.py
 -rw-rw-r--  2.0 unx     8731 b- defN 23-Jun-14 22:34 pdfCropMargins/get_window_sizing_info.py
--rw-rw-r--  2.0 unx    59855 b- defN 23-Jun-22 19:21 pdfCropMargins/gui.py
--rw-rw-r--  2.0 unx    70410 b- defN 23-Jun-22 21:11 pdfCropMargins/main_pdfCropMargins.py
+-rw-rw-r--  2.0 unx    59855 b- defN 23-Jun-29 02:22 pdfCropMargins/gui.py
+-rw-rw-r--  2.0 unx    54822 b- defN 23-Jul-04 21:28 pdfCropMargins/main_pdfCropMargins.py
 -rw-rw-r--  2.0 unx    49005 b- defN 23-Jun-22 20:58 pdfCropMargins/manpage_data.py
 -rw-rw-r--  2.0 unx     8298 b- defN 23-Jun-22 03:23 pdfCropMargins/pdfCropMargins.py
 -rw-rw-r--  2.0 unx     8924 b- defN 22-Dec-07 15:25 pdfCropMargins/prettified_argparse.py
--rw-rw-r--  2.0 unx    20211 b- defN 23-Jun-22 05:38 pdfCropMargins/pymupdf_routines.py
+-rw-rw-r--  2.0 unx    37098 b- defN 23-Jun-28 23:41 pdfCropMargins/pymupdf_routines.py
 -rw-rw-r--  2.0 unx     3669 b- defN 23-Jun-03 03:46 pdfCropMargins/tmp_test_metadata_setting.py
 -rw-rw-r--  2.0 unx        0 b- defN 17-Mar-05 00:20 pdfCropMargins/pdftoppm_windows_local/__init__.py
 -rw-rw-r--  2.0 unx        0 b- defN 19-Aug-19 00:10 pdfCropMargins/pdftoppm_windows_local/xpdf_tools_win_4_01_01/__init__.py
 -rw-rw-r--  2.0 unx        0 b- defN 19-Aug-19 00:32 pdfCropMargins/pdftoppm_windows_local/xpdf_tools_win_4_01_01/bin32/__init__.py
 -rwxr-xr--  2.0 unx  1690624 b- defN 19-Aug-19 00:06 pdfCropMargins/pdftoppm_windows_local/xpdf_tools_win_4_01_01/bin32/pdftoppm.exe
 -rw-rw-r--  2.0 unx        0 b- defN 19-Aug-19 00:32 pdfCropMargins/pdftoppm_windows_local/xpdf_tools_win_4_01_01/bin64/__init__.py
 -rwxr-xr--  2.0 unx  2090496 b- defN 19-Aug-19 00:06 pdfCropMargins/pdftoppm_windows_local/xpdf_tools_win_4_01_01/bin64/pdftoppm.exe
--rw-rw-r--  2.0 unx    35546 b- defN 23-Jun-22 21:18 pdfCropMargins-2.0.2.dist-info/LICENSE
--rw-rw-r--  2.0 unx    59924 b- defN 23-Jun-22 21:18 pdfCropMargins-2.0.2.dist-info/METADATA
--rw-rw-r--  2.0 unx      110 b- defN 23-Jun-22 21:18 pdfCropMargins-2.0.2.dist-info/WHEEL
--rw-rw-r--  2.0 unx      125 b- defN 23-Jun-22 21:18 pdfCropMargins-2.0.2.dist-info/entry_points.txt
--rw-rw-r--  2.0 unx       15 b- defN 23-Jun-22 21:18 pdfCropMargins-2.0.2.dist-info/top_level.txt
-?rw-rw-r--  2.0 unx     2485 b- defN 23-Jun-22 21:18 pdfCropMargins-2.0.2.dist-info/RECORD
-25 files, 4154407 bytes uncompressed, 1836039 bytes compressed:  55.8%
+-rw-rw-r--  2.0 unx    35546 b- defN 23-Jul-04 23:04 pdfCropMargins-2.0.3.dist-info/LICENSE
+-rw-rw-r--  2.0 unx    59924 b- defN 23-Jul-04 23:04 pdfCropMargins-2.0.3.dist-info/METADATA
+-rw-rw-r--  2.0 unx      110 b- defN 23-Jul-04 23:04 pdfCropMargins-2.0.3.dist-info/WHEEL
+-rw-rw-r--  2.0 unx      125 b- defN 23-Jul-04 23:04 pdfCropMargins-2.0.3.dist-info/entry_points.txt
+-rw-rw-r--  2.0 unx       15 b- defN 23-Jul-04 23:04 pdfCropMargins-2.0.3.dist-info/top_level.txt
+?rw-rw-r--  2.0 unx     2485 b- defN 23-Jul-04 23:04 pdfCropMargins-2.0.3.dist-info/RECORD
+25 files, 4155823 bytes uncompressed, 1836452 bytes compressed:  55.8%
```

## zipnote {}

```diff
@@ -51,26 +51,26 @@
 
 Filename: pdfCropMargins/pdftoppm_windows_local/xpdf_tools_win_4_01_01/bin64/__init__.py
 Comment: 
 
 Filename: pdfCropMargins/pdftoppm_windows_local/xpdf_tools_win_4_01_01/bin64/pdftoppm.exe
 Comment: 
 
-Filename: pdfCropMargins-2.0.2.dist-info/LICENSE
+Filename: pdfCropMargins-2.0.3.dist-info/LICENSE
 Comment: 
 
-Filename: pdfCropMargins-2.0.2.dist-info/METADATA
+Filename: pdfCropMargins-2.0.3.dist-info/METADATA
 Comment: 
 
-Filename: pdfCropMargins-2.0.2.dist-info/WHEEL
+Filename: pdfCropMargins-2.0.3.dist-info/WHEEL
 Comment: 
 
-Filename: pdfCropMargins-2.0.2.dist-info/entry_points.txt
+Filename: pdfCropMargins-2.0.3.dist-info/entry_points.txt
 Comment: 
 
-Filename: pdfCropMargins-2.0.2.dist-info/top_level.txt
+Filename: pdfCropMargins-2.0.3.dist-info/top_level.txt
 Comment: 
 
-Filename: pdfCropMargins-2.0.2.dist-info/RECORD
+Filename: pdfCropMargins-2.0.3.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## pdfCropMargins/__init__.py

```diff
@@ -1,9 +1,9 @@
 """
 pdfCropMargins
 """
 
-__version__ = "2.0.2" # major version, minor version, patch (see PEP440)
+__version__ = "2.0.3" # major version, minor version, patch (see PEP440)
 
 # The only function designed to be called from a user's Python code.
 from pdfCropMargins.pdfCropMargins import crop
```

## pdfCropMargins/calculate_bounding_boxes.py

```diff
@@ -278,19 +278,21 @@
         print("Error in renderPdfFileToImageFile: Unrecognized external program.",
               file=sys.stderr)
         ex.cleanup_and_exit(1)
 
 def get_image_list_mupdf(pdf_file_name):
     """Get the bounding boxes by rendering the pages with PyMuPDF and calculating
     them."""
+    # TODO: This seems inefficient since we already have a document open for GUI
     document_pages = pymupdf_routines.MuPdfDocument(args)
     num_pages = document_pages.open_document(pdf_file_name)
 
     # Note that the images here are PPM bytes objects.
     page_images = [document_pages.get_page_ppm_for_crop(i) for i in range(num_pages)]
+    document_pages.close_document()
     return page_images
 
 def calculate_bounding_box_from_image(im, curr_page_mediabox):
     """This function uses a Pillow routine to get the bounding box, in bp, of
     the rendered image."""
     x_max, y_max = im.size
     bounding_box = im.getbbox() # Note this uses ltrb convention.
```

## pdfCropMargins/main_pdfCropMargins.py

```diff
@@ -28,33 +28,36 @@
 
 Source code site: https://github.com/abarker/pdfCropMargins
 
 """
 
 # Might want an option to delete the XML save data.
 
+# TODO: Resource warning on socket is raised when delay introduced in
+# main_crop before handling options on file, but only when GUI also used.
+# Try in a simple pymupdf thing???
+
+# TODO: In get_image_list_mupdf in the calculate_bounding_boxes module try to pass
+# the current MuPdfDocument rather than creating a new one temporarily.
+
 # TODO: Maybe use _restored and restored_ prefix and suffix for restore ops???
 # Need a new option --stringRestored.
 
 # TODO: Maybe add option to see the MuPdf warnings, use
 # fitz.TOOLS.mupdf_warnings() first to empty warnings and then to get warnings,
 # see https://github.com/pymupdf/PyMuPDF/discussions/1501
 
 # TODO: Make --evenodd option equalize the page WIDTHS after separately
 # calculating the crops, just do the max over them.
 
 # TODO: Deleting metadata on restore doesn't seem to remove key like docs say.
 #       So restored document still registers as already cropped.
-#       See the `check_and_set_crop_metadata` function.
+#       See the `check_and_set_crop_metadata` method of the pymupdf wrapper.
 #       https://pymupdf.readthedocs.io/en/latest/recipes-low-level-interfaces.html#how-to-extend-pdf-metadata
 
-# TODO: Rename `get_full_page_box_list_assigning_media_and_crop` and its page
-# version to `get_full_page_box_list_saving_mediabox`, since cropbox no longer
-# reset, assuming the change is kept.
-
 # Some general notes, useful for reading the code.
 #
 # Margins are described as left, bottom, right, and top (lbrt). Boxes
 # in pypdf2 and PDF are defined by the lower-left point's x and y values
 # followed by the upper-right point's x and y values, which is equivalent
 # information (since x and y are implicit in the margin names).
 # The origin is at the lower left. The pymupdf program uses the top left
@@ -78,45 +81,36 @@
 # because it originally used pypdf2).  All values are converted by a wrapper
 # around the pymupdf routines, which are in the module pymupdf_routines.
 
 import sys
 import os
 import shutil
 import time
-from decimal import Decimal
 from warnings import warn
 
 try:
     import readline # Makes prompts go to stdout rather than stderr.
 except ImportError: # Not available on Windows.
     pass
 
 from . import __version__ # Get the version number from the __init__.py file.
 from .manpage_data import cmd_parser, DEFAULT_THRESHOLD_VALUE
 from .prettified_argparse import parse_command_line_arguments
-from .pymupdf_routines import (has_mupdf, MuPdfDocument, get_box, set_box, Rect,
-        intersect_pdf_boxes, fitz)
+from .pymupdf_routines import (has_mupdf, MuPdfDocument, intersect_pdf_boxes,
+                               mod_box_for_rotation, fitz)
 
 from . import external_program_calls as ex
 project_src_directory = ex.project_src_directory
 
 from .calculate_bounding_boxes import get_bounding_box_list
 
 ##
 ## Some data used by the program.
 ##
 
-# The string which is appended to Producer metadata in cropped PDFs.
-PRODUCER_MODIFIER = " (Cropped by pdfCropMargins.)" # String for older versions.
-PRODUCER_MODIFIER_2 = " (Cropped by pdfCropMargins>=2.0.)" # Added to Producer metadata.
-RESTORE_METADATA_KEY = "pdfCropMarginsRestoreData" # Key for XML dict restore data.
-
-# Limit precision to some reasonable amount to prevent problems in some PDF viewers.
-DECIMAL_PRECISION_FOR_MARGIN_POINT_VALUES = 8
-
 args = None # Global set during cmd-line processing (since almost all funs use it).
 
 ##
 ## Begin general function definitions.
 ##
 
 def generate_output_filepath(infile_path, is_cropped_file=True,
@@ -208,151 +202,14 @@
     if float_ratio == 0 or float_ratio == float("inf"):
         print("\nError in pdfCropMargins: Bad format in argument to "
               " setPageRatios.\nZero or infinite aspect ratios are not allowed.",
               file=sys.stderr)
         raise ValueError
     return float_ratio
 
-def mod_box_for_rotation(box, angle, undo=False):
-    """The user sees left, bottom, right, and top margins on a page, but inside
-    the PDF and in pyPdf the page may be rotated (such as in landscape mode).
-    In the case of 90 degree clockwise rotation the left really modifies the
-    top, the top really modifies right, and so forth.  In order for the options
-    like '--percentRetain4' and '--absoluteOffset4' to work as expected the
-    values need to be shifted to match any "hidden" rotations on any page.
-    The `box` argument is a 4-tuple of left, bottom, right, top values."""
-    def rotate_ninety_degrees_clockwise(box, n):
-        """The `n` here is the number of 90deg rotations to do."""
-        if n == 0:
-            return box
-        box = rotate_ninety_degrees_clockwise(box, n-1)
-        return [box[1], box[2], box[3], box[0]]
-
-    # These are for clockwise, swap do and undo to reverse.
-    do_map = {0: 0, 90: 1, 180: 2, 270: 3} # Map angle to num of 90deg rotations.
-    undo_map = {0: 0, 90: 3, 180: 2, 270: 1}
-
-    if not undo:
-        return rotate_ninety_degrees_clockwise(box, do_map[angle])
-    else:
-        return rotate_ninety_degrees_clockwise(box, undo_map[angle])
-
-def get_full_page_box_assigning_media_and_crop(page):
-    """This returns whatever PDF box was selected (by the user option
-    '--fullPageBox') to represent the full page size.  All cropping is done
-    relative to this box.  The default selection option is the MediaBox
-    intersected with the CropBox so multiple crops work as expected.
-
-    The argument page should be a pyPdf page object.
-
-    This function also sets the MediaBox and CropBox of the page to the
-    full-page size and saves the old values in the same page namespace, so it
-    should only be called once for each page.  It returns a `RectangleObject`
-    box."""
-
-    # Find the page rotation angle (degrees).
-    # Note rotation is clockwise, and four values are allowed: 0 90 180 270
-    rotation = page.rotation
-    while rotation >= 360:
-        rotation -= 360
-    while rotation < 0:
-        rotation += 360
-
-    # Save the rotation value in the page's namespace so we can restore it later.
-    page.rotationAngle = rotation
-
-    # Un-rotate the page, to a rotation of 0.
-    page.set_rotation(0)
-
-    # Save copies of some values in the page's namespace, to possibly restore later.
-    page.original_media_box = get_box(page, "mediabox")
-    #page.original_crop_box = get_box(page, "cropbox") # TODO, see other place where this was used.
-
-    # Note: The default value of empty args.fullPageBox are set when processing the
-    # command-line args.  Set to ["m", "c"] unless Ghostscript box-finding is selected.
-
-    first_loop = True
-    for box_string in args.fullPageBox:
-        if box_string == "m":
-            f_box = get_box(page, "mediabox")
-        if box_string == "c":
-            f_box = get_box(page, "cropbox")
-        if box_string == "t":
-            f_box = get_box(page, "trimbox")
-        if box_string == "a":
-            f_box = get_box(page, "artbox")
-        if box_string == "b":
-            f_box = get_box(page, "bleedbox")
-
-        # Take intersection over all chosen boxes.
-        if first_loop:
-            full_box = f_box
-        else:
-            full_box = intersect_pdf_boxes(full_box, f_box, page)
-
-        first_loop = False
-
-    return rotation, full_box, page
-
-def apply_precrop(rotation, full_box, page):
-    """Apply the precrop to the document's box settings."""
-    # Do any absolute pre-cropping specified for the page (after modifying any
-    # absolutePreCrop4 arguments to take into account rotations to the page).
-    precrop_box = mod_box_for_rotation(args.absolutePreCrop4, rotation)
-
-    full_box = [float(full_box[0]) + precrop_box[0],
-                float(full_box[1]) + precrop_box[1],
-                float(full_box[2]) - precrop_box[2],
-                float(full_box[3]) - precrop_box[3],
-                ]
-
-    # Note that MediaBox is set FIRST, since PyMuPDF will reset all other boxes
-    # when it is set.
-    set_box(page, "mediabox", full_box)
-    set_box(page, "cropbox", full_box)
-    return full_box
-
-def get_full_page_box_list_assigning_media_and_crop(input_doc_mupdf_wrapper, quiet=False):
-    """Get a list of all the full-page box values for each page.  The boxes on
-    the list are in the simple 4-float list format used by this program, not
-    `RectangleObject` format."""
-
-    full_page_box_list = []
-    rotation_list = []
-
-    if args.verbose and not quiet:
-        print(f"\nOriginal full page sizes (rounded to "
-              f"{DECIMAL_PRECISION_FOR_MARGIN_POINT_VALUES} digits) in PDF format (lbrt):")
-
-    for page_num in range(input_doc_mupdf_wrapper.num_pages):
-
-        # Get the current page and find the full-page box.
-        curr_page = input_doc_mupdf_wrapper.page_list[page_num]
-        rotation, full_box, page = get_full_page_box_assigning_media_and_crop(curr_page)
-
-        # Do any absolute pre-cropping specified for the page (after modifying any
-        # absolutePreCrop4 arguments to take into account rotations to the page).
-        full_page_box = apply_precrop(rotation, full_box, page)
-
-        if args.verbose and not quiet:
-            # want to display page num numbering from 1, so add one
-            rounded_box_string = ", ".join([str(round(f,
-                        DECIMAL_PRECISION_FOR_MARGIN_POINT_VALUES)) for f in full_page_box])
-            print(f"\t{str(page_num+1)}   rot = "
-                  f"{curr_page.rotationAngle}  \t [{rounded_box_string}]")
-
-        # Convert the `RectangleObject` to floats in an ordinary list and append.
-        ordinary_box = [float(b) for b in full_page_box]
-        full_page_box_list.append(ordinary_box)
-
-        # Append the rotation value to the rotation_list.
-        rotation_list.append(curr_page.rotationAngle)
-
-    return full_page_box_list, rotation_list
-
 def calculate_crop_list(full_page_box_list, bounding_box_list, angle_list,
                                                                page_nums_to_crop):
     """Given a list of full-page boxes (media boxes) and a list of tight
     bounding boxes for each page, calculate and return another list giving the
     list of bounding boxes to crop down to.  The parameter `angle_list` is
     a list of rotation angles which correspond to the pages.  The pages
     selected to crop are in the set `page_nums_to_crop`."""
@@ -651,218 +508,14 @@
                 top_weight /= total_tb_weight
                 ratio_set_crop_list.append((left, bottom - difference * bottom_weight,
                                            right, top + difference * top_weight))
         final_crop_list = ratio_set_crop_list
 
     return final_crop_list, delta_page_nums
 
-def check_and_set_crop_metadata(document_wrapper_class, metadata_info):
-    """First check the producer metadata attribute to see if this program was
-    cropped document before.  Returns the variable
-    `already_cropped_by_this_program` which is either `False` or has the value
-    string `"<2.0"` or `">=2.0".
-
-    The "Producer" metadata then has a string appended (if not already there)
-    to indicate that this program modified the file."""
-    def has_xml_restore_data():
-        """This function is a workaround because setting the XML metadata key
-        to "null" doesn't seem to delete the key itself like the docs say.  Need
-        to look at the value to determine if there is data there to determine
-        `already_cropped_by_this_program` since value is set null on restore."""
-        # TODO: Should be able to just check key with `doc_wrap.has_xml_metadata_key`
-        # but doesn't work.
-        data_value, has_xml_metadata, has_key = document_wrapper_class.get_xml_metadata_value(
-                                                                         RESTORE_METADATA_KEY)
-        if has_key:
-            return data_value[0] == "["
-        return False
-
-    if metadata_info:
-        old_producer_string = metadata_info["producer"]
-    else:
-        return PRODUCER_MODIFIER, False # Can't read metadata, but maybe can set it.
-
-    if has_xml_restore_data(): # See note in function.
-        if args.verbose:
-            print("\nThe document was already cropped at least once by pdfCropMargins>=2.0.")
-        already_cropped_by_this_program = ">=2.0"
-
-    elif old_producer_string and old_producer_string.endswith(PRODUCER_MODIFIER):
-        if args.verbose:
-            print("\nThe document was already cropped at least once by pdfCropMargins<2.0.")
-        already_cropped_by_this_program = "<2.0"
-        # Update the Producer suffix to the the new PRODUCER_MODIFIER_2.
-        new_producer_string = old_producer_string.replace(PRODUCER_MODIFIER, PRODUCER_MODIFIER_2)
-        metadata_info["producer"] = new_producer_string
-
-    else:
-        if args.verbose:
-            print("\nThe document was not previously cropped by pdfCropMargins.")
-        metadata_info["producer"] = metadata_info["producer"] + PRODUCER_MODIFIER_2
-        already_cropped_by_this_program = False
-
-    document_wrapper_class.set_standard_metadata(metadata_info)
-    return already_cropped_by_this_program
-
-def serialize_boxlist(boxlist):
-    """Return the string for the list of boxes."""
-    return str([list(b) for b in boxlist])
-
-def deserialize_boxlist(boxlist_string):
-    """Return the string for the list of boxes."""
-    if boxlist_string[0] != "[" or boxlist_string[-1] != "]":
-        return None
-    boxlist_string = boxlist_string[2:-2]
-    split_list = boxlist_string.split("], [")
-    deserialized_boxlist = []
-    for box in split_list:
-        values = box.split(",")
-        try:
-            deserialized_boxlist.append([float(v) for v in values])
-        except ValueError:
-            return None
-    return deserialized_boxlist
-
-def save_old_boxes_for_restore(input_doc_mupdf_wrapper, original_mediabox_list,
-                               original_cropbox_list, original_artbox_list,
-                               already_cropped_by_this_program):
-    """Save the intersection of the cropbox and the mediabox."""
-    if already_cropped_by_this_program == "<2.0":
-        old_boxes_to_save_list = original_artbox_list
-    else:
-        old_boxes_to_save_list = [] # Save list of old boxes to possibly save for later restore.
-        for page_num in range(input_doc_mupdf_wrapper.document.page_count):
-            curr_page = input_doc_mupdf_wrapper.page_list[page_num]
-
-            # Do the save for later restore if that option is chosen and Producer is not set.
-            box = intersect_pdf_boxes(original_mediabox_list[page_num],
-                                      original_cropbox_list[page_num], curr_page)
-            old_boxes_to_save_list.append(box)
-
-    serialized_saved_boxes_list = serialize_boxlist(old_boxes_to_save_list)
-    input_doc_mupdf_wrapper.set_xml_metadata_item(RESTORE_METADATA_KEY,
-                                                        serialized_saved_boxes_list)
-
-def apply_crop_list(crop_list, input_doc_mupdf_wrapper, page_nums_to_crop,
-                    already_cropped_by_this_program):
-    """Apply the crop list to the pages of the input document."""
-    if args.writeCropDataToFile:
-        args.writeCropDataToFile = ex.get_expanded_path(args.writeCropDataToFile)
-        f = open(args.writeCropDataToFile, "w")
-    else:
-        f = None
-
-    if args.verbose:
-        print("\nNew full page sizes after cropping, in PDF format (lbrt):")
-
-    # Set the appropriate PDF boxes on each page.
-    for page_num in range(input_doc_mupdf_wrapper.document.page_count):
-        curr_page = input_doc_mupdf_wrapper.page_list[page_num]
-
-        # Restore any rotation which was originally on the page.
-        curr_page.set_rotation(curr_page.rotationAngle)
-
-        # Reset the CropBox and MediaBox to their saved original values (they
-        # were saved by `get_full_page_box_assigning_media_and_crop` in the
-        # `curr_page` object's namespace).  Restore the MediaBox and CropBox to
-        # the saved values.  Note that MediaBox is set FIRST, since PyMuPDF
-        # will reset all other boxes when it is set.
-        set_box(curr_page, "mediabox", curr_page.original_media_box)
-        # TODO: Below causes problems to reset the old one, inconsistent sometimes...,
-        # but not really needed since setting MediaBox in PyMuPDF now resets it anyway...
-        # Delete where it is set, also, if deleting this code.  Maybe need a copy when set?
-        # Note that --boxesToUse was updated to say that only MediaBox is set (to
-        # intersection of old MediaBox and CropBox).
-        #set_box(curr_page, "cropbox", curr_page.original_crop_box)
-
-        # Copy the original page without further mods if it wasn't in the range
-        # selected for cropping.
-        if page_num not in page_nums_to_crop:
-            continue
-
-        rounded_values = [round(f, DECIMAL_PRECISION_FOR_MARGIN_POINT_VALUES)
-                                for f in crop_list[page_num]]
-        new_cropped_box = rounded_values
-
-        if args.verbose:
-            print("\t"+str(page_num+1)+"\t", list(new_cropped_box)) # page numbering from 1
-        if args.writeCropDataToFile:
-            print("\t"+str(page_num+1)+"\t", list(new_cropped_box), file=f)
-
-        if not args.boxesToSet:
-            args.boxesToSet = ["m", "c"]
-
-        # Now set any boxes which were selected to be set via the '--boxesToSet' option.
-        if "m" in args.boxesToSet:
-            # Note the MediaBox is always set FIRST, since it resets the other boxes.
-            set_box(curr_page, "mediabox", new_cropped_box)
-        if "c" in args.boxesToSet:
-            set_box(curr_page, "cropbox", new_cropped_box)
-        if "t" in args.boxesToSet:
-            set_box(curr_page, "trimbox", new_cropped_box)
-        if "a" in args.boxesToSet:
-            set_box(curr_page, "artbox", new_cropped_box)
-        if "b" in args.boxesToSet:
-            set_box(curr_page, "bleedbox", new_cropped_box)
-
-    if args.writeCropDataToFile:
-        f.close()
-        ex.cleanup_and_exit(0)
-
-def apply_restore_operation(already_cropped_by_this_program, input_doc_mupdf_wrapper,
-                            original_artbox_list):
-    """Restore the saved page boxes to the document."""
-    if args.writeCropDataToFile:
-        args.writeCropDataToFile = ex.get_expanded_path(args.writeCropDataToFile)
-        f = open(args.writeCropDataToFile, "w")
-    else:
-        f = None
-
-    if already_cropped_by_this_program == ">=2.0":
-        saved_boxes, has_xml_metadata, xml_metadata_has_key = (
-                input_doc_mupdf_wrapper.get_xml_metadata_value(RESTORE_METADATA_KEY))
-        saved_boxes_list = deserialize_boxlist(saved_boxes)
-        if not saved_boxes_list:
-            print("\nError in pdfCropMargins: Could not deserialize the data saved for the"
-                    "\nrestore operation.  Deleting the key and the data.", file=sys.stderr)
-            input_doc_mupdf_wrapper.delete_xml_metadata_item(RESTORE_METADATA_KEY)
-
-    elif already_cropped_by_this_program == "<2.0":
-        saved_boxes_list = original_artbox_list
-
-    if not saved_boxes_list or len(saved_boxes_list) != input_doc_mupdf_wrapper.num_pages:
-        print("\nError in pdfCropMargins: The number of pages in the saved restore"
-              "\ndata is not the same as the number of pages in the document.  The"
-              "\nrestore operation will be ignored.", file=sys.stderr)
-        return
-
-    for page_num in range(input_doc_mupdf_wrapper.document.page_count):
-        curr_page = input_doc_mupdf_wrapper.page_list[page_num]
-
-        # Restore any rotation which was originally on the page.
-        curr_page.set_rotation(curr_page.rotationAngle)
-
-        # Restore the MediaBox and CropBox to the saved values.  Note that
-        # MediaBox is set FIRST, since PyMuPDF will reset all other boxes
-        # when it is set.
-        # TODO: Should restore respect the --boxesToSet option?
-        set_box(curr_page, "mediabox", saved_boxes_list[page_num])
-        set_box(curr_page, "cropbox", saved_boxes_list[page_num])
-        if args.writeCropDataToFile:
-            print("\t"+str(page_num+1)+"\t", saved_boxes_list[page_num], file=f)
-
-    # The saved restore data is no longer needed.
-    if args.verbose:
-        print("\nDeleting the saved restore metadata since it is no longer needed.")
-    input_doc_mupdf_wrapper.delete_xml_metadata_item(RESTORE_METADATA_KEY)
-
-    if args.writeCropDataToFile:
-        f.close()
-        ex.cleanup_and_exit(0)
-
 ##############################################################################
 #
 # Functions implementing the major operations.
 #
 ##############################################################################
 
 def process_command_line_arguments(parsed_args, cmd_parser):
@@ -1194,22 +847,23 @@
     # with the earlier PyPDF restore option.
     original_mediabox_list = input_doc_mupdf_wrapper.get_box_list("mediabox")
     original_cropbox_list = input_doc_mupdf_wrapper.get_box_list("cropbox")
     original_artbox_list = input_doc_mupdf_wrapper.get_box_list("artbox")
     #original_trimbox_list = input_doc_mupdf_wrapper.get_box_list("trimbox")
     #original_bleedbox_list = input_doc_mupdf_wrapper.get_box_list("bleedbox")
 
-    already_cropped_by_this_program = check_and_set_crop_metadata(input_doc_mupdf_wrapper,
-                                                                  metadata_info)
+    already_cropped_by_this_program = input_doc_mupdf_wrapper.check_and_set_crop_metadata(
+                                                                            metadata_info)
 
     if not args.noundosave:
         if already_cropped_by_this_program == "<2.0" or not already_cropped_by_this_program:
-            save_old_boxes_for_restore(input_doc_mupdf_wrapper, original_mediabox_list,
-                                       original_cropbox_list, original_artbox_list,
-                                       already_cropped_by_this_program)
+            input_doc_mupdf_wrapper.save_old_boxes_for_restore(original_mediabox_list,
+                                                               original_cropbox_list,
+                                                               original_artbox_list,
+                                                               already_cropped_by_this_program)
 
     if args.prevCropped:
         input_doc_mupdf_wrapper.close_document()
         if already_cropped_by_this_program:
             #print("code 0")
             exit_code = 0
         else:
@@ -1241,16 +895,15 @@
     ## Get a list with the full-page boxes for each page: (left,bottom,right,top)
     ## This function also sets the MediaBox and CropBox of the pages to the
     ## chosen full-page size as a side-effect, saving the old boxes.  Any absolute
     ## pre-crop is also applied here (so it is rendered that way for the later
     ## bounding-box-finding operation).
     ##
 
-    full_page_box_list, rotation_list = get_full_page_box_list_assigning_media_and_crop(
-                                              input_doc_mupdf_wrapper)
+    full_page_box_list, rotation_list = input_doc_mupdf_wrapper.get_full_page_box_list_assigning_media_and_crop()
 
     ##
     ## Write out the PDF document again, with the CropBox and MediaBox reset.
     ## This temp document version is ONLY used for calculating the bounding boxes of
     ## pages.
     ##
 
@@ -1303,19 +956,19 @@
 
         if not already_cropped_by_this_program:
             print("\nWarning from pdfCropMargins: The Producer string and metadata indicate"
                   "\nthat either this document was not previously cropped by pdfCropMargins"
                   "\nor else it was modified by another program after that and cannot"
                   "\nbe restored.  Ignoring the restore operation.", file=sys.stderr)
         else:
-            apply_restore_operation(already_cropped_by_this_program,
-                                    input_doc_mupdf_wrapper, original_artbox_list)
+            input_doc_mupdf_wrapper.apply_restore_operation(already_cropped_by_this_program,
+                                                            original_artbox_list)
 
     else:
-        apply_crop_list(crop_list, input_doc_mupdf_wrapper, page_nums_to_crop,
+        input_doc_mupdf_wrapper.apply_crop_list(crop_list, page_nums_to_crop,
                         already_cropped_by_this_program)
 
     ##
     ## Write the final PDF out to a file.
     ##
 
     input_doc_mupdf_wrapper.save_document(output_doc_pathname)
@@ -1341,17 +994,18 @@
                   "\nto modify the original file after the viewer is launched in the"
                   "\nbackground...\n")
             do_preview(output_doc_pathname)
             # Give preview time to start; it may write startup garbage to the terminal...
             query_wait_time = 2 # seconds
             time.sleep(query_wait_time)
             print()
-        while True:
+
+        while True: # Loop until we get an allowed response.
             query_string = "\nModify the original file to the cropped file " \
-                "(saving the original)? [yn] "
+                           "(saving the original)? [yn] "
             query_result = input(query_string).strip()
             if query_result in ["y", "Y"]:
                 args.modifyOriginal = True
                 print("\nModifying the original file.")
                 break
             elif query_result in ["n", "N"]:
                 print("\nNot modifying the original file.  The cropped file is saved"
@@ -1429,16 +1083,19 @@
         if args.verbose:
             print("\nWaiting for the GUI...")
 
         did_crop, bounding_box_list, delta_page_nums = create_gui(input_doc_pathname,
                               fixed_input_doc_pathname, output_doc_pathname,
                               cmd_parser, parsed_args)
         if did_crop:
+            #time.sleep(8)  # TODO: This alone causes resource bug!! queryModifyOriginal wait does the same.
+            #               # But only in combination with the gui...  May be fixed now?
             handle_options_on_cropped_file(input_doc_pathname, output_doc_pathname)
     else:
         bounding_box_list, delta_page_nums = process_pdf_file(input_doc_pathname,
                                                               fixed_input_doc_pathname,
                                                               output_doc_pathname)
+        #time.sleep(8)  # TODO: This doesn't cause the error...
         handle_options_on_cropped_file(input_doc_pathname, output_doc_pathname)
 
     return output_doc_pathname
```

## pdfCropMargins/pymupdf_routines.py

```diff
@@ -37,36 +37,40 @@
 Some of this code is heavily modified from the GPL example/demo code found here:
 https://github.com/PySimpleGUI/PySimpleGUI/blob/master/DemoPrograms/Demo_PDF_Viewer.py
 
 """
 
 import sys
 import warnings
-import copy
 from . import external_program_calls as ex
 
 has_mupdf = True
 
 try: # Extra dependencies for the GUI version.  Make sure they are installed.
     with warnings.catch_warnings():
         #warnings.filterwarnings("ignore",category=DeprecationWarning)
         import fitz
-        from fitz import Rect
-        import os
-        import tempfile # Maybe later write to the regular tmp dir...
     # Need at least 1.19.4 for setting MediaBox resetting all other boxes behavior.
     # Version 1.19.6 is the last one supporting Python 3.6.
     if not [int(i) for i in fitz.VersionBind.split(".")] >= [1, 19, 4]:
         has_mupdf = False
         MuPdfDocument = None
 
 except ImportError:
     has_mupdf = False
     MuPdfDocument = None
 
+# The string which is appended to Producer metadata in cropped PDFs.
+PRODUCER_MODIFIER = " (Cropped by pdfCropMargins.)" # String for older versions.
+PRODUCER_MODIFIER_2 = " (Cropped by pdfCropMargins>=2.0.)" # Added to Producer metadata.
+RESTORE_METADATA_KEY = "pdfCropMarginsRestoreData" # Key for XML dict restore data.
+
+# Limit precision to some reasonable amount to prevent problems in some PDF viewers.
+DECIMAL_PRECISION_FOR_MARGIN_POINT_VALUES = 8
+
 #
 # Utility functions.
 #
 
 def intersect_pdf_boxes(box1, box2, page):
     """Return the intersection of PDF-style boxes by converting to
     pymupdf `Rect`, using its intersection function, and then
@@ -131,14 +135,57 @@
     try:
         set_box_method(converted_box)
     except ValueError as e:
         print(f"\nWarning in pdfCropMargins: The {boxstring} could not be written"
               f" to page {page.number}.  The error is:\n   {str(e)}",
               file=sys.stdout)
 
+def mod_box_for_rotation(box, angle, undo=False):
+    """The user sees left, bottom, right, and top margins on a page, but inside
+    the PDF and in pyPdf the page may be rotated (such as in landscape mode).
+    In the case of 90 degree clockwise rotation the left really modifies the
+    top, the top really modifies right, and so forth.  In order for the options
+    like '--percentRetain4' and '--absoluteOffset4' to work as expected the
+    values need to be shifted to match any "hidden" rotations on any page.
+    The `box` argument is a 4-tuple of left, bottom, right, top values."""
+    def rotate_ninety_degrees_clockwise(box, n):
+        """The `n` here is the number of 90deg rotations to do."""
+        if n == 0:
+            return box
+        box = rotate_ninety_degrees_clockwise(box, n-1)
+        return [box[1], box[2], box[3], box[0]]
+
+    # These are for clockwise, swap do and undo to reverse.
+    do_map = {0: 0, 90: 1, 180: 2, 270: 3} # Map angle to num of 90deg rotations.
+    undo_map = {0: 0, 90: 3, 180: 2, 270: 1}
+
+    if not undo:
+        return rotate_ninety_degrees_clockwise(box, do_map[angle])
+    else:
+        return rotate_ninety_degrees_clockwise(box, undo_map[angle])
+
+def serialize_boxlist(boxlist):
+    """Return the string for the list of boxes."""
+    return str([list(b) for b in boxlist])
+
+def deserialize_boxlist(boxlist_string):
+    """Return the string for the list of boxes."""
+    if boxlist_string[0] != "[" or boxlist_string[-1] != "]":
+        return None
+    boxlist_string = boxlist_string[2:-2]
+    split_list = boxlist_string.split("], [")
+    deserialized_boxlist = []
+    for box in split_list:
+        values = box.split(",")
+        try:
+            deserialized_boxlist.append([float(v) for v in values])
+        except ValueError:
+            return None
+    return deserialized_boxlist
+
 #
 # The main class.
 #
 
 class MuPdfDocument:
     """Holds `pyMuPDF` document and PyMuPDF pages of the document for the GUI
     to display.  Has methods to get rendered images.  Note that the page numbering
@@ -253,16 +300,16 @@
         # See here:
         #    https://pymupdf.readthedocs.io/en/latest/document.html#Document.save
         self.document.save(file_path)
 
     def close_document(self):
         """Close the document and clear its pages."""
         self.page_list = []
-        self.document.close()
         self.clear_cache()
+        self.document.close()
 
     def get_page_ppm_for_crop(self, page_num, cache=False):
         """Return an unscaled and unclipped `.ppm` file suitable for cropping the page.
         Not indended for displaying in the GUI."""
         # NOTE: The calculated bounding boxes are already saved in GUI, so
         # there is no need to cache these.  After crops the PDF is written
         # out and re-read, which would clear the cache, anyway.
@@ -289,15 +336,15 @@
         # TODO: Above page also lists a faster way than getting ppm first.
 
         # Pillow Image: https://pillow.readthedocs.io/en/stable/reference/Image.html
         # Pillow modes: https://pillow.readthedocs.io/en/stable/handbook/concepts.html#concept-modes
         # PyMuPDF Pixmap: https://pymupdf.readthedocs.io/en/latest/pixmap.html#Pixmap.__init__
         # PyMuPDF get_pixmap: https://pymupdf.readthedocs.io/en/latest/page.html#Page.getPixmap
 
-        mat_0 = fitz.Matrix(1, 1)
+        #mat_0 = fitz.Matrix(1, 1)
         # New in PyMuPDF version 1.16.0, annots kwarg for whether to ignore them.
         pixmap = page_crop_display_list.get_pixmap(matrix=fitz.Identity,
                                                   colorspace=colorspace,
                                                   clip=None, alpha=False)
         if self.args:
             # TODO: Is this working right?  Here, you change matrix in get_pixmap:
             # https://stackoverflow.com/questions/63821179/extract-images-from-pdf-in-high-resolution-with-python
@@ -359,23 +406,184 @@
 
         #image_png = pixmap.tobytes()  # get the PNG image
         image_height, image_width = pixmap.height, pixmap.width
         image_ppm = pixmap.tobytes("png")  # Make PPM image from pixmap for tkinter.
         image_tl = clip.tl # Clip position (top left).
         return image_ppm, image_tl, image_height, image_width
 
+    def get_full_page_box_list_assigning_media_and_crop(self, quiet=False):
+        """Get a list of all the full-page box values for each page.  The boxes on
+        the list are in the simple 4-float list format used by this program, not
+        `RectangleObject` format."""
+
+        def get_full_page_box_assigning_media_and_crop(page):
+            """This returns whatever PDF box was selected (by the user option
+            '--fullPageBox') to represent the full page size.  All cropping is done
+            relative to this box.  The default selection option is the MediaBox
+            intersected with the CropBox so multiple crops work as expected.
+
+            The argument page should be a pyPdf page object.
+
+            This function also sets the MediaBox and CropBox of the page to the
+            full-page size and saves the old values in the same page namespace, so it
+            should only be called once for each page.  It returns a `RectangleObject`
+            box."""
+
+            # Find the page rotation angle (degrees).
+            # Note rotation is clockwise, and four values are allowed: 0 90 180 270
+            rotation = page.rotation
+            while rotation >= 360:
+                rotation -= 360
+            while rotation < 0:
+                rotation += 360
+
+            # Save the rotation value in the page's namespace so we can restore it later.
+            page.rotationAngle = rotation
+
+            # Un-rotate the page, to a rotation of 0.
+            page.set_rotation(0)
+
+            # Save copies of some values in the page's namespace, to possibly restore later.
+            page.original_media_box = get_box(page, "mediabox")
+            #page.original_crop_box = get_box(page, "cropbox") # TODO, see other place where this was used.
+
+            # Note: The default value of empty args.fullPageBox are set when processing the
+            # command-line args.  Set to ["m", "c"] unless Ghostscript box-finding is selected.
+
+            first_loop = True
+            for box_string in self.args.fullPageBox:
+                if box_string == "m":
+                    f_box = get_box(page, "mediabox")
+                if box_string == "c":
+                    f_box = get_box(page, "cropbox")
+                if box_string == "t":
+                    f_box = get_box(page, "trimbox")
+                if box_string == "a":
+                    f_box = get_box(page, "artbox")
+                if box_string == "b":
+                    f_box = get_box(page, "bleedbox")
+
+                # Take intersection over all chosen boxes.
+                if first_loop:
+                    full_box = f_box
+                else:
+                    full_box = intersect_pdf_boxes(full_box, f_box, page)
+
+                first_loop = False
+
+            return rotation, full_box, page
+
+        def apply_precrop(rotation, full_box, page):
+            """Apply the precrop to the document's box settings."""
+            # Do any absolute pre-cropping specified for the page (after modifying any
+            # absolutePreCrop4 arguments to take into account rotations to the page).
+            precrop_box = mod_box_for_rotation(self.args.absolutePreCrop4, rotation)
+
+            full_box = [float(full_box[0]) + precrop_box[0],
+                        float(full_box[1]) + precrop_box[1],
+                        float(full_box[2]) - precrop_box[2],
+                        float(full_box[3]) - precrop_box[3],
+                        ]
+
+            # Note that MediaBox is set FIRST, since PyMuPDF will reset all other boxes
+            # when it is set.
+            set_box(page, "mediabox", full_box)
+            set_box(page, "cropbox", full_box)
+            return full_box
+
+        full_page_box_list = []
+        rotation_list = []
+
+        if self.args.verbose and not quiet:
+            print(f"\nOriginal full page sizes (rounded to "
+                  f"{DECIMAL_PRECISION_FOR_MARGIN_POINT_VALUES} digits) in PDF format (lbrt):")
+
+        for page_num in range(self.num_pages):
+
+            # Get the current page and find the full-page box.
+            curr_page = self.page_list[page_num]
+            rotation, full_box, page = get_full_page_box_assigning_media_and_crop(curr_page)
+
+            # Do any absolute pre-cropping specified for the page (after modifying any
+            # absolutePreCrop4 arguments to take into account rotations to the page).
+            full_page_box = apply_precrop(rotation, full_box, page)
+
+            if self.args.verbose and not quiet:
+                # want to display page num numbering from 1, so add one
+                rounded_box_string = ", ".join([str(round(f,
+                            DECIMAL_PRECISION_FOR_MARGIN_POINT_VALUES)) for f in full_page_box])
+                print(f"\t{str(page_num+1)}   rot = "
+                      f"{curr_page.rotationAngle}  \t [{rounded_box_string}]")
+
+            # Convert the `RectangleObject` to floats in an ordinary list and append.
+            ordinary_box = [float(b) for b in full_page_box]
+            full_page_box_list.append(ordinary_box)
+
+            # Append the rotation value to the rotation_list.
+            rotation_list.append(curr_page.rotationAngle)
+
+        return full_page_box_list, rotation_list
+
     def get_standard_metadata(self):
         """Return the standard metadata from the document."""
         metadata_info = self.document.metadata
         return metadata_info
 
     def set_standard_metadata(self, metadata_dict):
         """Set the standard metadata dict for the document."""
         self.document.set_metadata(metadata_dict)
 
+    def check_and_set_crop_metadata(self, metadata_info):
+        """First check the producer metadata attribute to see if this program was
+        cropped document before.  Returns the variable
+        `already_cropped_by_this_program` which is either `False` or has the value
+        string `"<2.0"` or `">=2.0".
+
+        The "Producer" metadata then has a string appended (if not already there)
+        to indicate that this program modified the file."""
+        def has_xml_restore_data():
+            """This function is a workaround because setting the XML metadata key
+            to "null" doesn't seem to delete the key itself like the docs say.  Need
+            to look at the value to determine if there is data there to determine
+            `already_cropped_by_this_program` since value is set null on restore."""
+            # TODO: Should be able to just check key with `doc_wrap.has_xml_metadata_key`
+            # but doesn't work.
+            data_value, has_xml_metadata, has_key = self.get_xml_metadata_value(
+                                                                RESTORE_METADATA_KEY)
+            if has_key:
+                return data_value[0] == "["
+            return False
+
+        if metadata_info:
+            old_producer_string = metadata_info["producer"]
+        else:
+            return PRODUCER_MODIFIER, False # Can't read metadata, but maybe can set it.
+
+        if has_xml_restore_data(): # See note in function.
+            if self.args.verbose:
+                print("\nThe document was already cropped at least once by pdfCropMargins>=2.0.")
+            already_cropped_by_this_program = ">=2.0"
+
+        elif old_producer_string and old_producer_string.endswith(PRODUCER_MODIFIER):
+            if self.args.verbose:
+                print("\nThe document was already cropped at least once by pdfCropMargins<2.0.")
+            already_cropped_by_this_program = "<2.0"
+            # Update the Producer suffix to the the new PRODUCER_MODIFIER_2.
+            new_producer_string = old_producer_string.replace(PRODUCER_MODIFIER, PRODUCER_MODIFIER_2)
+            metadata_info["producer"] = new_producer_string
+
+        else:
+            if self.args.verbose:
+                print("\nThe document was not previously cropped by pdfCropMargins.")
+            metadata_info["producer"] = metadata_info["producer"] + PRODUCER_MODIFIER_2
+            already_cropped_by_this_program = False
+
+        self.set_standard_metadata(metadata_info)
+        return already_cropped_by_this_program
+
     def has_xml_metadata_key(self, key):
         """Return a boolean indicating if the XML metadata dict has the key `key`."""
         data_type, value = self.document.xref_get_key(-1, "Info")  # /Info key in the trailer
         if data_type != "xref":
             return None # No metadata at all.
         else:
             xref = int(value.replace("0 R", ""))  # Extract the metadata xref.
@@ -434,7 +642,145 @@
 
     def delete_xml_metadata_item(self, key):
         """Delete the key `key` and the data associated with it."""
         # TODO: This doesn't seem to delete the key like the docs say, only the metadata.
         # https://pymupdf.readthedocs.io/en/latest/recipes-low-level-interfaces.html#how-to-extend-pdf-metadata
         self.set_xml_metadata_item(key, "null")
 
+    def save_old_boxes_for_restore(self, original_mediabox_list,
+                                   original_cropbox_list, original_artbox_list,
+                                   already_cropped_by_this_program):
+        """Save the intersection of the cropbox and the mediabox."""
+        if already_cropped_by_this_program == "<2.0":
+            old_boxes_to_save_list = original_artbox_list
+        else:
+            old_boxes_to_save_list = [] # Save list of old boxes to possibly save for later restore.
+            for page_num in range(self.document.page_count):
+                curr_page = self.page_list[page_num]
+
+                # Do the save for later restore if that option is chosen and Producer is not set.
+                box = intersect_pdf_boxes(original_mediabox_list[page_num],
+                                          original_cropbox_list[page_num], curr_page)
+                old_boxes_to_save_list.append(box)
+
+        serialized_saved_boxes_list = serialize_boxlist(old_boxes_to_save_list)
+        self.set_xml_metadata_item(RESTORE_METADATA_KEY,
+                                                            serialized_saved_boxes_list)
+
+    def apply_restore_operation(self, already_cropped_by_this_program, original_artbox_list):
+        """Restore the saved page boxes to the document."""
+        if self.args.writeCropDataToFile:
+            self.args.writeCropDataToFile = ex.get_expanded_path(self.args.writeCropDataToFile)
+            f = open(self.args.writeCropDataToFile, "w")
+        else:
+            f = None
+
+        if already_cropped_by_this_program == ">=2.0":
+            saved_boxes, has_xml_metadata, xml_metadata_has_key = (
+                    self.get_xml_metadata_value(RESTORE_METADATA_KEY))
+            saved_boxes_list = deserialize_boxlist(saved_boxes)
+            if not saved_boxes_list:
+                print("\nError in pdfCropMargins: Could not deserialize the data saved for the"
+                        "\nrestore operation.  Deleting the key and the data.", file=sys.stderr)
+                self.delete_xml_metadata_item(RESTORE_METADATA_KEY)
+
+        elif already_cropped_by_this_program == "<2.0":
+            saved_boxes_list = original_artbox_list
+
+        if not saved_boxes_list or len(saved_boxes_list) != self.num_pages:
+            print("\nError in pdfCropMargins: The number of pages in the saved restore"
+                  "\ndata is not the same as the number of pages in the document.  The"
+                  "\nrestore operation will be ignored.", file=sys.stderr)
+            return
+
+        for page_num in range(self.document.page_count):
+            curr_page = self.page_list[page_num]
+
+            # Restore any rotation which was originally on the page.
+            curr_page.set_rotation(curr_page.rotationAngle)
+
+            # Restore the MediaBox and CropBox to the saved values.  Note that
+            # MediaBox is set FIRST, since PyMuPDF will reset all other boxes
+            # when it is set.
+            # TODO: Should restore respect the --boxesToSet option?
+            set_box(curr_page, "mediabox", saved_boxes_list[page_num])
+            set_box(curr_page, "cropbox", saved_boxes_list[page_num])
+            if self.args.writeCropDataToFile:
+                print("\t"+str(page_num+1)+"\t", saved_boxes_list[page_num], file=f)
+
+        # The saved restore data is no longer needed.
+        if self.args.verbose:
+            print("\nDeleting the saved restore metadata since it is no longer needed.")
+        self.delete_xml_metadata_item(RESTORE_METADATA_KEY)
+
+        if self.args.writeCropDataToFile:
+            f.close()
+            ex.cleanup_and_exit(0)
+
+    def apply_crop_list(self, crop_list, page_nums_to_crop, already_cropped_by_this_program):
+        """Apply the crop list to the pages of the input document."""
+        args = self.args
+
+        if args.writeCropDataToFile:
+            args.writeCropDataToFile = ex.get_expanded_path(args.writeCropDataToFile)
+            f = open(args.writeCropDataToFile, "w")
+        else:
+            f = None
+
+        if args.verbose:
+            print("\nNew full page sizes after cropping, in PDF format (lbrt):")
+
+        # Set the appropriate PDF boxes on each page.
+        for page_num in range(self.document.page_count):
+            curr_page = self.page_list[page_num]
+
+            # Restore any rotation which was originally on the page.
+            curr_page.set_rotation(curr_page.rotationAngle)
+
+            # Reset the CropBox and MediaBox to their saved original values (they
+            # were saved by `get_full_page_box_assigning_media_and_crop` in the
+            # `curr_page` object's namespace).  Restore the MediaBox and CropBox to
+            # the saved values.  Note that MediaBox is set FIRST, since PyMuPDF
+            # will reset all other boxes when it is set.
+            set_box(curr_page, "mediabox", curr_page.original_media_box)
+            # TODO: Below causes problems to reset the old one, inconsistent sometimes...,
+            # but not really needed since setting MediaBox in PyMuPDF now resets it anyway...
+            # Delete where it is set, also, if deleting this code.  Maybe need a copy when set?
+            # Note that --boxesToUse was updated to say that only MediaBox is set (to
+            # intersection of old MediaBox and CropBox).
+            #set_box(curr_page, "cropbox", curr_page.original_crop_box)
+
+            # Copy the original page without further mods if it wasn't in the range
+            # selected for cropping.
+            if page_num not in page_nums_to_crop:
+                continue
+
+            rounded_values = [round(f, DECIMAL_PRECISION_FOR_MARGIN_POINT_VALUES)
+                                    for f in crop_list[page_num]]
+            new_cropped_box = rounded_values
+
+            if args.verbose:
+                print("\t"+str(page_num+1)+"\t", list(new_cropped_box)) # page numbering from 1
+            if args.writeCropDataToFile:
+                print("\t"+str(page_num+1)+"\t", list(new_cropped_box), file=f)
+
+            if not args.boxesToSet:
+                args.boxesToSet = ["m", "c"]
+
+            # Now set any boxes which were selected to be set via the '--boxesToSet' option.
+            if "m" in args.boxesToSet:
+                # Note the MediaBox is always set FIRST, since it resets the other boxes.
+                set_box(curr_page, "mediabox", new_cropped_box)
+            if "c" in args.boxesToSet:
+                set_box(curr_page, "cropbox", new_cropped_box)
+            if "t" in args.boxesToSet:
+                set_box(curr_page, "trimbox", new_cropped_box)
+            if "a" in args.boxesToSet:
+                set_box(curr_page, "artbox", new_cropped_box)
+            if "b" in args.boxesToSet:
+                set_box(curr_page, "bleedbox", new_cropped_box)
+
+        if args.writeCropDataToFile:
+            f.close()
+            ex.cleanup_and_exit(0)
+
+
```

## Comparing `pdfCropMargins-2.0.2.dist-info/LICENSE` & `pdfCropMargins-2.0.3.dist-info/LICENSE`

 * *Files identical despite different names*

## Comparing `pdfCropMargins-2.0.2.dist-info/METADATA` & `pdfCropMargins-2.0.3.dist-info/METADATA`

 * *Files 0% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: pdfCropMargins
-Version: 2.0.2
+Version: 2.0.3
 Summary: A command-line program to crop the margins of PDF files, with many options.
 Home-page: https://github.com/abarker/pdfCropMargins
 Author: Allen Barker
 Author-email: Allen.L.Barker@gmail.com
 License: GPL
 Keywords: pdf,crop,margins,resize
 Platform: UNKNOWN
```

## Comparing `pdfCropMargins-2.0.2.dist-info/RECORD` & `pdfCropMargins-2.0.3.dist-info/RECORD`

 * *Files 6% similar despite different names*

```diff
@@ -1,25 +1,25 @@
-pdfCropMargins/__init__.py,sha256=zW9mpuVTw4iIk2LCR3u_WV-_8HAuaBQaRqVqNyK77lc,215
+pdfCropMargins/__init__.py,sha256=ptm5EmNEzI9qrMm0Nfz6ntCX-Bhb7YUC57vSpKyy9oU,215
 pdfCropMargins/__main__.py,sha256=eqembSzHFaMzW0tHq9tLGzlVhpaTnGd7WEDBYFw-ynk,197
-pdfCropMargins/calculate_bounding_boxes.py,sha256=n_PY4xzJgc-8ZaH1O1ida2W1L6heH32BbzLKHVCEeLE,14131
+pdfCropMargins/calculate_bounding_boxes.py,sha256=pGhp3OVt8z7l-943790BCUBAUqSXdTfVwXZEHmItmYU,14248
 pdfCropMargins/directory_locator.py,sha256=L3vgSdGVtBDJf8RVAVX0WxcDhqR8j5O3uv37X96lxmg,181
 pdfCropMargins/external_program_calls.py,sha256=OlZuD4gf4Rro3UF1D3mfPal66ryAFRwoq6CL7YQDO70,31255
 pdfCropMargins/get_window_sizing_info.py,sha256=Nnnx-dGtX9x-c831TOVTHyZ5or7ltQXkOP27i0HQnoY,8731
 pdfCropMargins/gui.py,sha256=abVEHVrA0e9rYfzkG40_ezxNszFZJ2ZTLdLtSubGpRU,59855
-pdfCropMargins/main_pdfCropMargins.py,sha256=6KiwyaZcqfPpxgqVKfS6dm3I6aHUhy3oF4iYemTI7Z0,70410
+pdfCropMargins/main_pdfCropMargins.py,sha256=3d1NfgKFxAg9NCOam5uI08gvnG2FugXgue2FPkwx1ZQ,54822
 pdfCropMargins/manpage_data.py,sha256=RdB0sgxL5pI5Nzyc_EbaJVlSggGNeuTt83VZ9wuGgRo,49005
 pdfCropMargins/pdfCropMargins.py,sha256=oo73_ftdFvxd7Meea2zlcLaZhzkT6VsVgnzVgBHwaCE,8298
 pdfCropMargins/prettified_argparse.py,sha256=OxtStEDN8UdU7OkSBeGxudJ_McwYArYmupVqiAfXK74,8924
-pdfCropMargins/pymupdf_routines.py,sha256=MMfEvX3wvs0fpaHe93QVo9nT-_9KCl3tmvYetpAXE-U,20211
+pdfCropMargins/pymupdf_routines.py,sha256=hylsh2rEkbauzBMKwh8ZkbIwbwfKGx0qErY6YFYBE3o,37098
 pdfCropMargins/tmp_test_metadata_setting.py,sha256=RLc-98lX0XYBHvBY5N_1z69s_75FK8dXU0AR6ly9ADU,3669
 pdfCropMargins/pdftoppm_windows_local/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 pdfCropMargins/pdftoppm_windows_local/xpdf_tools_win_4_01_01/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 pdfCropMargins/pdftoppm_windows_local/xpdf_tools_win_4_01_01/bin32/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 pdfCropMargins/pdftoppm_windows_local/xpdf_tools_win_4_01_01/bin32/pdftoppm.exe,sha256=paogYneEsikm1y6Q8wRcYxAGYwbZYMi5v0KctOSsQwI,1690624
 pdfCropMargins/pdftoppm_windows_local/xpdf_tools_win_4_01_01/bin64/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 pdfCropMargins/pdftoppm_windows_local/xpdf_tools_win_4_01_01/bin64/pdftoppm.exe,sha256=SIlcH87t54NMT_9s8RWV4x4CCMnlKLURNsKVVUbzI7Y,2090496
-pdfCropMargins-2.0.2.dist-info/LICENSE,sha256=Je6hz-X3DSxDtjXaCDoczW7YB4RuX2zpU0PPiD410us,35546
-pdfCropMargins-2.0.2.dist-info/METADATA,sha256=_kpJLJZArzwvY_Rc7emefM1WWYl85yKUuunY9oZmjDY,59924
-pdfCropMargins-2.0.2.dist-info/WHEEL,sha256=Z-nyYpwrcSqxfdux5Mbn_DQ525iP7J2DG3JgGvOYyTQ,110
-pdfCropMargins-2.0.2.dist-info/entry_points.txt,sha256=BAuD78hKbj7Par2JQxg5x_1KRI_Op3LXjRZMKR-bkOY,125
-pdfCropMargins-2.0.2.dist-info/top_level.txt,sha256=8xlp0kBdEXsm3mBVRnpsjvl5VIxXhjw8xKOq3q2iFjI,15
-pdfCropMargins-2.0.2.dist-info/RECORD,,
+pdfCropMargins-2.0.3.dist-info/LICENSE,sha256=Je6hz-X3DSxDtjXaCDoczW7YB4RuX2zpU0PPiD410us,35546
+pdfCropMargins-2.0.3.dist-info/METADATA,sha256=_5h4TDPpLUG3NycObuBL8i53dL19WOAhPfQHaZo9jZo,59924
+pdfCropMargins-2.0.3.dist-info/WHEEL,sha256=Z-nyYpwrcSqxfdux5Mbn_DQ525iP7J2DG3JgGvOYyTQ,110
+pdfCropMargins-2.0.3.dist-info/entry_points.txt,sha256=BAuD78hKbj7Par2JQxg5x_1KRI_Op3LXjRZMKR-bkOY,125
+pdfCropMargins-2.0.3.dist-info/top_level.txt,sha256=8xlp0kBdEXsm3mBVRnpsjvl5VIxXhjw8xKOq3q2iFjI,15
+pdfCropMargins-2.0.3.dist-info/RECORD,,
```

