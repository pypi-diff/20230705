# Comparing `tmp/finlab-0.4.4-cp39-cp39-win_amd64.whl.zip` & `tmp/finlab-0.4.5-cp39-cp39-win_amd64.whl.zip`

## zipinfo {}

```diff
@@ -1,56 +1,56 @@
-Zip file size: 418842 bytes, number of entries: 54
--rw-rw-rw-  2.0 fat     2522 b- defN 23-May-23 09:53 finlab/__init__.py
--rw-rw-rw-  2.0 fat    22853 b- defN 23-May-23 09:53 finlab/backtest.py
--rw-rw-rw-  2.0 fat     1424 b- defN 23-May-23 09:53 finlab/backtest_old.py
--rw-rw-rw-  2.0 fat      915 b- defN 23-May-23 09:53 finlab/cells.py
--rw-rw-rw-  2.0 fat    29964 b- defN 23-May-23 09:53 finlab/data.py
--rw-rw-rw-  2.0 fat    30989 b- defN 23-May-23 09:53 finlab/dataframe.py
--rw-rw-rw-  2.0 fat    80750 b- defN 23-May-23 09:53 finlab/ffn_core.py
--rw-rw-rw-  2.0 fat     6292 b- defN 23-May-23 09:53 finlab/market_info.py
--rw-rw-rw-  2.0 fat    36351 b- defN 23-May-23 09:53 finlab/plot.py
--rw-rw-rw-  2.0 fat     5246 b- defN 23-May-23 09:53 finlab/utils.py
--rw-rw-rw-  2.0 fat     7316 b- defN 23-May-23 09:53 finlab/analysis/__init__.py
--rw-rw-rw-  2.0 fat     2110 b- defN 23-May-23 09:53 finlab/analysis/alphaBetaAnalysis.py
--rw-rw-rw-  2.0 fat     1449 b- defN 23-May-23 09:53 finlab/analysis/drawdownAnalysis.py
--rw-rw-rw-  2.0 fat     5007 b- defN 23-May-23 09:53 finlab/analysis/inequalityAnalysis.py
--rw-rw-rw-  2.0 fat     4735 b- defN 23-May-23 09:53 finlab/analysis/liquidityAnalysis.py
--rw-rw-rw-  2.0 fat    12329 b- defN 23-May-23 09:53 finlab/analysis/maeMfeAnalysis.py
--rw-rw-rw-  2.0 fat     7481 b- defN 23-May-23 09:53 finlab/analysis/periodStatsAnalysis.py
--rw-rw-rw-  2.0 fat        2 b- defN 23-May-23 09:53 finlab/core/__init__.py
--rw-rw-rw-  2.0 fat   206336 b- defN 23-May-23 09:58 finlab/core/aes.cp39-win_amd64.pyd
--rw-rw-rw-  2.0 fat    19593 b- defN 23-May-23 09:53 finlab/core/aes.pyx
--rw-rw-rw-  2.0 fat   134656 b- defN 23-May-23 09:58 finlab/core/backtest_core.cp39-win_amd64.pyd
--rw-rw-rw-  2.0 fat    18552 b- defN 23-May-23 09:53 finlab/core/backtest_core.pyx
--rw-rw-rw-  2.0 fat    71680 b- defN 23-May-23 09:58 finlab/core/mae_mfe.cp39-win_amd64.pyd
--rw-rw-rw-  2.0 fat      485 b- defN 23-May-23 09:53 finlab/core/mae_mfe.pxd
--rw-rw-rw-  2.0 fat     6119 b- defN 23-May-23 09:53 finlab/core/mae_mfe.pyx
--rw-rw-rw-  2.0 fat   169472 b- defN 23-May-23 09:58 finlab/core/report.cp39-win_amd64.pyd
--rw-rw-rw-  2.0 fat    19675 b- defN 23-May-23 09:53 finlab/core/report.pyx
--rw-rw-rw-  2.0 fat    19968 b- defN 23-May-23 09:58 finlab/core/utils_core.cp39-win_amd64.pyd
--rw-rw-rw-  2.0 fat       88 b- defN 23-May-23 09:53 finlab/core/utils_core.pyx
--rw-rw-rw-  2.0 fat      704 b- defN 23-May-23 09:53 finlab/ml/__init__.py
--rw-rw-rw-  2.0 fat     3912 b- defN 23-May-23 09:53 finlab/ml/alphalens.py
--rw-rw-rw-  2.0 fat     5160 b- defN 23-May-23 09:53 finlab/ml/cpcv.py
--rw-rw-rw-  2.0 fat    14448 b- defN 23-May-23 09:53 finlab/ml/feature.py
--rw-rw-rw-  2.0 fat     5180 b- defN 23-May-23 09:53 finlab/ml/label.py
--rw-rw-rw-  2.0 fat    18139 b- defN 23-May-23 09:53 finlab/ml/qlib.py
--rw-rw-rw-  2.0 fat     3131 b- defN 23-May-23 09:53 finlab/ml/utils.py
--rw-rw-rw-  2.0 fat        0 b- defN 23-May-23 09:53 finlab/online/__init__.py
--rw-rw-rw-  2.0 fat     8155 b- defN 23-May-23 09:53 finlab/online/base_account.py
--rw-rw-rw-  2.0 fat    12766 b- defN 23-May-23 09:53 finlab/online/binance_account.py
--rw-rw-rw-  2.0 fat     7264 b- defN 23-May-23 09:53 finlab/online/dashboard.py
--rw-rw-rw-  2.0 fat      263 b- defN 23-May-23 09:53 finlab/online/enums.py
--rw-rw-rw-  2.0 fat    12844 b- defN 23-May-23 09:53 finlab/online/fugle_account.py
--rw-rw-rw-  2.0 fat    17131 b- defN 23-May-23 09:53 finlab/online/order_executor.py
--rw-rw-rw-  2.0 fat    13122 b- defN 23-May-23 09:53 finlab/online/panel.py
--rw-rw-rw-  2.0 fat     8674 b- defN 23-May-23 09:53 finlab/online/sinopac_account.py
--rw-rw-rw-  2.0 fat     3158 b- defN 23-May-23 09:53 finlab/online/test.py
--rw-rw-rw-  2.0 fat     5303 b- defN 23-May-23 09:53 finlab/online/utils.py
--rw-rw-rw-  2.0 fat        0 b- defN 23-May-23 09:53 finlab/optimize/__init__.py
--rw-rw-rw-  2.0 fat     9160 b- defN 23-May-23 09:53 finlab/optimize/combinations.py
--rw-rw-rw-  2.0 fat    35823 b- defN 23-May-23 09:58 finlab-0.4.4.dist-info/LICENSE
--rw-rw-rw-  2.0 fat     3879 b- defN 23-May-23 09:58 finlab-0.4.4.dist-info/METADATA
--rw-rw-rw-  2.0 fat      100 b- defN 23-May-23 09:58 finlab-0.4.4.dist-info/WHEEL
--rw-rw-rw-  2.0 fat        7 b- defN 23-May-23 09:58 finlab-0.4.4.dist-info/top_level.txt
--rw-rw-r--  2.0 fat     4441 b- defN 23-May-23 09:58 finlab-0.4.4.dist-info/RECORD
-54 files, 1117123 bytes uncompressed, 411892 bytes compressed:  63.1%
+Zip file size: 424289 bytes, number of entries: 54
+-rw-rw-rw-  2.0 fat     2522 b- defN 23-Jul-04 01:07 finlab/__init__.py
+-rw-rw-rw-  2.0 fat    23142 b- defN 23-Jul-04 01:07 finlab/backtest.py
+-rw-rw-rw-  2.0 fat     1424 b- defN 23-Jul-04 01:07 finlab/backtest_old.py
+-rw-rw-rw-  2.0 fat      915 b- defN 23-Jul-04 01:07 finlab/cells.py
+-rw-rw-rw-  2.0 fat    37372 b- defN 23-Jul-04 01:07 finlab/data.py
+-rw-rw-rw-  2.0 fat    31084 b- defN 23-Jul-04 01:07 finlab/dataframe.py
+-rw-rw-rw-  2.0 fat    80750 b- defN 23-Jul-04 01:07 finlab/ffn_core.py
+-rw-rw-rw-  2.0 fat     7264 b- defN 23-Jul-04 01:07 finlab/market_info.py
+-rw-rw-rw-  2.0 fat    35607 b- defN 23-Jul-04 01:07 finlab/plot.py
+-rw-rw-rw-  2.0 fat     5270 b- defN 23-Jul-04 01:07 finlab/utils.py
+-rw-rw-rw-  2.0 fat     7398 b- defN 23-Jul-04 01:07 finlab/analysis/__init__.py
+-rw-rw-rw-  2.0 fat     2110 b- defN 23-Jul-04 01:07 finlab/analysis/alphaBetaAnalysis.py
+-rw-rw-rw-  2.0 fat     1449 b- defN 23-Jul-04 01:07 finlab/analysis/drawdownAnalysis.py
+-rw-rw-rw-  2.0 fat     5007 b- defN 23-Jul-04 01:07 finlab/analysis/inequalityAnalysis.py
+-rw-rw-rw-  2.0 fat     4735 b- defN 23-Jul-04 01:07 finlab/analysis/liquidityAnalysis.py
+-rw-rw-rw-  2.0 fat    12357 b- defN 23-Jul-04 01:07 finlab/analysis/maeMfeAnalysis.py
+-rw-rw-rw-  2.0 fat     7502 b- defN 23-Jul-04 01:07 finlab/analysis/periodStatsAnalysis.py
+-rw-rw-rw-  2.0 fat        2 b- defN 23-Jul-04 01:07 finlab/core/__init__.py
+-rw-rw-rw-  2.0 fat   206336 b- defN 23-Jul-04 01:11 finlab/core/aes.cp39-win_amd64.pyd
+-rw-rw-rw-  2.0 fat    19593 b- defN 23-Jul-04 01:07 finlab/core/aes.pyx
+-rw-rw-rw-  2.0 fat   134656 b- defN 23-Jul-04 01:11 finlab/core/backtest_core.cp39-win_amd64.pyd
+-rw-rw-rw-  2.0 fat    18752 b- defN 23-Jul-04 01:07 finlab/core/backtest_core.pyx
+-rw-rw-rw-  2.0 fat    71680 b- defN 23-Jul-04 01:11 finlab/core/mae_mfe.cp39-win_amd64.pyd
+-rw-rw-rw-  2.0 fat      485 b- defN 23-Jul-04 01:07 finlab/core/mae_mfe.pxd
+-rw-rw-rw-  2.0 fat     6119 b- defN 23-Jul-04 01:07 finlab/core/mae_mfe.pyx
+-rw-rw-rw-  2.0 fat   172032 b- defN 23-Jul-04 01:11 finlab/core/report.cp39-win_amd64.pyd
+-rw-rw-rw-  2.0 fat    19902 b- defN 23-Jul-04 01:07 finlab/core/report.pyx
+-rw-rw-rw-  2.0 fat    19968 b- defN 23-Jul-04 01:11 finlab/core/utils_core.cp39-win_amd64.pyd
+-rw-rw-rw-  2.0 fat       88 b- defN 23-Jul-04 01:07 finlab/core/utils_core.pyx
+-rw-rw-rw-  2.0 fat      704 b- defN 23-Jul-04 01:07 finlab/ml/__init__.py
+-rw-rw-rw-  2.0 fat     7369 b- defN 23-Jul-04 01:07 finlab/ml/alphalens.py
+-rw-rw-rw-  2.0 fat     5160 b- defN 23-Jul-04 01:07 finlab/ml/cpcv.py
+-rw-rw-rw-  2.0 fat    14448 b- defN 23-Jul-04 01:07 finlab/ml/feature.py
+-rw-rw-rw-  2.0 fat     5180 b- defN 23-Jul-04 01:07 finlab/ml/label.py
+-rw-rw-rw-  2.0 fat    18202 b- defN 23-Jul-04 01:07 finlab/ml/qlib.py
+-rw-rw-rw-  2.0 fat     3131 b- defN 23-Jul-04 01:07 finlab/ml/utils.py
+-rw-rw-rw-  2.0 fat        0 b- defN 23-Jul-04 01:07 finlab/online/__init__.py
+-rw-rw-rw-  2.0 fat     8155 b- defN 23-Jul-04 01:07 finlab/online/base_account.py
+-rw-rw-rw-  2.0 fat    12766 b- defN 23-Jul-04 01:07 finlab/online/binance_account.py
+-rw-rw-rw-  2.0 fat     7264 b- defN 23-Jul-04 01:07 finlab/online/dashboard.py
+-rw-rw-rw-  2.0 fat      263 b- defN 23-Jul-04 01:07 finlab/online/enums.py
+-rw-rw-rw-  2.0 fat    14064 b- defN 23-Jul-04 01:07 finlab/online/fugle_account.py
+-rw-rw-rw-  2.0 fat    18092 b- defN 23-Jul-04 01:07 finlab/online/order_executor.py
+-rw-rw-rw-  2.0 fat    13122 b- defN 23-Jul-04 01:07 finlab/online/panel.py
+-rw-rw-rw-  2.0 fat    10011 b- defN 23-Jul-04 01:07 finlab/online/sinopac_account.py
+-rw-rw-rw-  2.0 fat     5260 b- defN 23-Jul-04 01:07 finlab/online/test.py
+-rw-rw-rw-  2.0 fat     5303 b- defN 23-Jul-04 01:07 finlab/online/utils.py
+-rw-rw-rw-  2.0 fat        0 b- defN 23-Jul-04 01:07 finlab/optimize/__init__.py
+-rw-rw-rw-  2.0 fat     9542 b- defN 23-Jul-04 01:07 finlab/optimize/combinations.py
+-rw-rw-rw-  2.0 fat    35823 b- defN 23-Jul-04 01:11 finlab-0.4.5.dist-info/LICENSE
+-rw-rw-rw-  2.0 fat     6068 b- defN 23-Jul-04 01:11 finlab-0.4.5.dist-info/METADATA
+-rw-rw-rw-  2.0 fat      100 b- defN 23-Jul-04 01:11 finlab-0.4.5.dist-info/WHEEL
+-rw-rw-rw-  2.0 fat        7 b- defN 23-Jul-04 01:11 finlab-0.4.5.dist-info/top_level.txt
+-rw-rw-r--  2.0 fat     4442 b- defN 23-Jul-04 01:11 finlab-0.4.5.dist-info/RECORD
+54 files, 1139997 bytes uncompressed, 417339 bytes compressed:  63.4%
```

## zipnote {}

```diff
@@ -141,23 +141,23 @@
 
 Filename: finlab/optimize/__init__.py
 Comment: 
 
 Filename: finlab/optimize/combinations.py
 Comment: 
 
-Filename: finlab-0.4.4.dist-info/LICENSE
+Filename: finlab-0.4.5.dist-info/LICENSE
 Comment: 
 
-Filename: finlab-0.4.4.dist-info/METADATA
+Filename: finlab-0.4.5.dist-info/METADATA
 Comment: 
 
-Filename: finlab-0.4.4.dist-info/WHEEL
+Filename: finlab-0.4.5.dist-info/WHEEL
 Comment: 
 
-Filename: finlab-0.4.4.dist-info/top_level.txt
+Filename: finlab-0.4.5.dist-info/top_level.txt
 Comment: 
 
-Filename: finlab-0.4.4.dist-info/RECORD
+Filename: finlab-0.4.5.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## finlab/__init__.py

```diff
@@ -7,15 +7,15 @@
 from getpass import getpass
 
 
 # Get an instance of a logger
 logging.basicConfig(level=logging.INFO)
 logger = logging.getLogger(__name__)
 
-__version__ = '0.4.4'
+__version__ = '0.4.5'
 
 
 class LoginPanel():
 
     def __init__(self):
         pass
```

## finlab/backtest.py

```diff
@@ -150,22 +150,40 @@
 
         stop_loss (float):
             停損基準，預設為None，不執行停損。範例：0.1，代表從再平衡開始，虧損 10% 時產生出場訊號。
 
         take_profit (float):
             停利基準，預設為None，不執行停利。範例：0.1，代表從再平衡開始， 10% 時產生出場訊號。
 
-        touched_exit (bool): 是否在回測時，使用觸價停損停利？預設為 False
-        stop_trading_next_period (bool): 當期已經停損停利，則下一期不買入，預設為 True。
-        live_performance_start (bool): 策略建構的日期，例如 `2022-01-01` 此日期之前，策略未撰寫，此日期之後則視為與實單有類似效果，實際不影響回測的結果，單純紀錄而已。
-        mae_mfe_window (int): 計算mae_mfe於進場後於不同持有天數下的數據變化，主要應用為edge_ratio (優勢比率)計算。預設為0，則Report.display_mae_mfe_analysis(...)中的edge_ratio不會顯現。
-        mae_mfe_window_step (int): 與mae_mfe_window參數做搭配，為時間間隔設定，預設為1。若mae_mfe_window設20，mae_mfe_window_step設定為2，相當於python的range(0,20,2)，以2日為間距計算mae_mfe。
-        market (str or MarketInfo): 可選擇`'TW_STOCK', 'CRYPTO'`，分別為台股或加密貨幣，
-                                                              或繼承 finlab.market_info.MarketInfo 開發回測市場類別。
-        upload (bool): 上傳策略至finlab網站，預設為True，上傳策略。範例： False，不上傳，可用 finlab.backtest.sim(position, upload=False, ...).display() 快速檢視策略績效。
+        touched_exit (bool):
+            是否在回測時，使用觸價停損停利？預設為 False
+
+        retain_cost_when_rebalance (bool): 
+            預設回測時，會將進場股票進場成本更新到到新的 rebalance 的當天價格，假如希望保留原本的進場價格當成停損停利的依據，可以設定為 `True`
+
+        stop_trading_next_period (bool): 
+            當期已經停損停利，則下一期不買入，預設為 True。
+
+        live_performance_start (bool): 
+            策略建構的日期，例如 `2022-01-01` 此日期之前，策略未撰寫，此日期之後則視為與實單有類似效果，實際不影響回測的結果，單純紀錄而已。
+
+        mae_mfe_window (int): 
+            計算mae_mfe於進場後於不同持有天數下的數據變化，主要應用為edge_ratio (優勢比率)計算。預設為0，則Report.display_mae_mfe_analysis(...)中的edge_ratio不會顯現。
+
+        mae_mfe_window_step (int): 
+            與mae_mfe_window參數做搭配，為時間間隔設定，預設為1。若mae_mfe_window設20，mae_mfe_window_step設定為2，相當於python的range(0,20,2)，以2日為間距計算mae_mfe。
+
+        market (str or MarketInfo):
+            可選擇`'TW_STOCK', 'CRYPTO'`，分別為台股或加密貨幣，
+            或繼承 finlab.market_info.MarketInfo 開發回測市場類別。
+
+        upload (bool):
+            上傳策略至finlab網站，預設為True，上傳策略。
+            範例： False，不上傳，可用 finlab.backtest.sim(position, upload=False, ...).display() 快速檢視策略績效。
+
     Returns:
         (finlab.analysis.Report):回測數據報告
     Examples:
         Assume the history of portfolio is construct as follows: When market close on 2021-12-31, the portfolio {B: 0.2, C: 0.4} is calculated. When market close on 2022-03-31, the portfolio {A:1} is calculated.
 
         |            | Stock 2330 | Stock 1101 | Stock 2454 |
         |------------|------------|------------|------------|
@@ -240,15 +258,14 @@
     if position.abs().sum().sum() == 0 or len(position.index) == 0:
         raise Exception('Position is empty and zero stock is selected.')
 
     # format position index
     if isinstance(position.index[0], str):
         position = FinlabDataFrame(position).index_str_to_date()
 
-    position.values[0, :] = 0
     assert isinstance(position.index, pd.DatetimeIndex)
 
     # if position date is very close to price end date, run all backtesting dates
     assert len(position.shape) >= 2
     delta_time_rebalance = position.index[-1] - position.index[-3]
     backtest_to_end = position.index[-1] + \
         delta_time_rebalance > price.index[-1]
```

## finlab/data.py

```diff
@@ -229,15 +229,15 @@
 
 class universe():
     def __init__(self, market='ALL', category='ALL'):
         """當呼叫 `data.get` 或是 `data.indicator` 時，返回產業相關類股。
 
         Args:
             market (str): Universe market type. ex: `ALL`, `TSE`, `OTC`, `TSE_OTC`, `ETF`, `STOCK_FUTURE`
-            category (str): Stock categories, can be either a string or a list. ex: `光電業`, `其他`, `其他電子業`, `化學工業`, `半導體`, `塑膠工業`, `存託憑證`, `建材營造`, `文化創意業`, `橡膠工業`, `水泥工業`,`汽車工業`, `油電燃氣業`, `玻璃陶瓷`, `生技醫療`, `生技醫療業`, `紡織纖維`, `航運業`, `觀光事業`, `貿易百貨`, `資訊服務業`, `農業科技`, `通信網路業`, `造紙工業`, `金融`, `鋼鐵工業`, `電器電纜`, `電子商務`, `電子通路業`, `電子零組件`, `電機機械`, `電腦及週邊`, `食品工業`
+            category (str or list)): Stock categories. ex: `光電業`, `其他`, `其他電子業`, `化學工業`, `半導體`, `塑膠工業`, `存託憑證`, `建材營造`, `文化創意業`, `橡膠工業`, `水泥工業`,`汽車工業`, `油電燃氣業`, `玻璃陶瓷`, `生技醫療`, `生技醫療業`, `紡織纖維`, `航運業`, `觀光事業`, `貿易百貨`, `資訊服務業`, `農業科技`, `通信網路業`, `造紙工業`, `金融`, `鋼鐵工業`, `電器電纜`, `電子商務`, `電子通路業`, `電子零組件`, `電機機械`, `電腦及週邊`, `食品工業`
 
         Examples:
 
             想要當鋼鐵人、航海王，可以用以下方法將這些類股一次選出來
             ``` py
             with universe('TSE_OTC', ['鋼鐵工業', '航運業']):
                 close_subset = data.get('price:收盤價')
@@ -264,15 +264,15 @@
         return self
 
     def __exit__(self, type, value, traceback):
         global universe_stocks
         universe_stocks = self._previous_stocks
 
 
-def set_universe(market: str = 'ALL', category='ALL'):
+def set_universe(market: str = 'ALL', category='ALL', industry='All'):
     """Set subset of stock ids when retrieve data using data.get or data.indicator
 
     Args:
         market (str): universe market type. ex: 'ALL', 'TSE', 'OTC', 'TSE_OTC', 'ETF', 'STOCK_FUTURE'
         category (str): stock categories, can be either a string or a list. ex: '光電業', '其他', '其他電子業',
    '化學工業', '半導體', '塑膠工業', '存託憑證', '建材營造', '文化創意業', '橡膠工業', '水泥工業',
    '汽車工業', '油電燃氣業', '玻璃陶瓷', '生技醫療', '生技醫療業', '紡織纖維', '航運業', '觀光事業', '貿易百貨',
@@ -318,14 +318,165 @@
                 set([c for c in all_categories if isinstance(c, str) and re.search(ca, c)]))
         category_match = categories.category.isin(matched_categories)
 
     global universe_stocks
     universe_stocks = set(categories.stock_id[market_match & category_match])
 
 
+class us_universe:
+    def __init__(self, market='ALL', sector='ALL', industry='ALL', exchange='ALL'):
+        """當呼叫 `data.get` 或是 `data.indicator` 時，返回美股產業相關類股。
+
+        Args:
+            market (str): Universe market type.
+                          ex: `Common Stock`, `Preferred Stock`, `Domestic`, `Domestic Common Stock`, `ADR`
+            sector (str or list): The sector the stock belongs to.
+                                  ex:`Basic Materials`,`Communication Services`,`Consumer Cyclical`,`Consumer Defensive`,`Energy`,`Financial Services`,`Healthcare`,`Industrials`,`Real Estate`,`Technology`,`Utilities`
+            industry (str or list): The industry the stock belongs to.See industry list from `set(data.get('us_tickers')['industry'])`.ex:`Steel`,`Software - Application`...
+            exchange (str or list): The exchange the stock belongs to.
+                                   ex:`BATS`, `INDEX`, `NASDAQ`, `NYSE`, `NYSEARCA`, `NYSEMKT`, `OTC`
+
+        Examples:
+
+            想選出美股普通股中的科技類股
+            ``` py
+            with us_universe('Common Stock', ['Technology']):
+                close_subset = data.get('us_price:close')
+                print(close_subset)
+            ```
+
+            | date       |   AAOI  |  AAPL |   ..   |   ABCO |   NVDA |
+            |:-----------|-------:|-------:|-------:|-------:|-------:|
+            | 2017-01-03 |  39.65 |  38.3  |   ..   |   7.8  |  17.55 |
+            | 2017-01-04 |  39.85 |  38.85 |   ..   |   8.34 |  17.5  |
+            | 2017-01-05 |  39.25 |  38.1  |   ..   |   8.25 |  17.3  |
+            | 2017-01-06 |  39    |  37.85 |   ..   |   8.2  |  17.3  |
+            | 2017-01-09 |  38.2  |  37.2  |   ..   |   7.88 |  16.6  |
+
+            想選出美股特別股中的基礎原物料和能源類股
+            ``` py
+            with data.us_universe('Preferred Stock', ['Basic Materials','Energy']):
+                close_subset = data.get('us_price:close')
+                print(close_subset)
+            ```
+
+            | date       |   AEUA |  ALIN-PA |  ..  | ALIN-PB | ALIN-PE |
+            |:-----------|-------:|-------:|-------:|-------:|-------:|
+            | 2017-01-03 |  39.65 |  38.3  |   ..   |   7.8  |  17.55 |
+            | 2017-01-04 |  39.85 |  38.85 |   ..   |   8.34 |  17.5  |
+            | 2017-01-05 |  39.25 |  38.1  |   ..   |   8.25 |  17.3  |
+            | 2017-01-06 |  39    |  37.85 |   ..   |   8.2  |  17.3  |
+            | 2017-01-09 |  38.2  |  37.2  |   ..   |   7.88 |  16.6  |
+
+            想從美股 NASDAQ 交易所的普通股中篩選出軟體類股
+            ``` py
+            with data.us_universe('Common Stock', industry='Software', exchange='NASDAQ'):
+                close_subset = data.get('us_price:close')
+                print(close_subset)
+            ```
+
+            | date       |   ACIW |  ACVA |  ..  | ZI | ZS |
+            |:-----------|-------:|-------:|-------:|-------:|-------:|
+            | 2017-01-03 |  39.65 |  38.3  |   ..   |   7.8  |  17.55 |
+            | 2017-01-04 |  39.85 |  38.85 |   ..   |   8.34 |  17.5  |
+            | 2017-01-05 |  39.25 |  38.1  |   ..   |   8.25 |  17.3  |
+            | 2017-01-06 |  39    |  37.85 |   ..   |   8.2  |  17.3  |
+            | 2017-01-09 |  38.2  |  37.2  |   ..   |   7.88 |  16.6  |
+
+
+            檢視有哪些產業可選擇
+            ``` py
+            print(set(data.get('us_tickers')['industry']))
+            ```
+            ```
+            {'Advertising Agencies',
+             'Aerospace & Defense',
+             'Agricultural Inputs',
+             'Airlines',
+             'Airports & Air Services',
+             'Aluminum',
+             ...}
+            ```
+
+        """
+        self._market = market
+        self._sector = sector
+        self._industry = industry
+        self._exchange = exchange
+        self._previous_stocks = set()
+
+    def __enter__(self):
+        global universe_stocks
+        self._previous_stocks = universe_stocks
+        set_us_universe(self._market, self._sector, self._industry, self._exchange)
+        return self
+
+    def __exit__(self, type, value, traceback):
+        global universe_stocks
+        universe_stocks = self._previous_stocks
+
+
+def set_us_universe(market: str = 'ALL', sector='ALL', industry='All', exchange='ALL'):
+    """Set subset of us stock ids when retrieve data using data.get or data.indicator
+
+    Args:
+        market (str): Universe market type.
+                      ex: `Common Stock`, `Preferred Stock`, `Domestic`, `Domestic Common Stock`, `ADR`
+        sector (str or list): The sector the stock belongs to.
+                              ex:`Basic Materials`,`Communication Services`,`Consumer Cyclical`,`Consumer Defensive`,`Energy`,`Financial Services`,`Healthcare`,`Industrials`,`Real Estate`,`Technology`,`Utilities`
+        industry (str or list): The industry the stock belongs to.See industry list from `set(data.get('us_tickers')['industry'])`.ex:`Steel`,`Software - Application`...
+        exchange (str or list): The exchange the stock belongs to.
+                               ex:`BATS`, `INDEX`, `NASDAQ`, `NYSE`, `NYSEARCA`, `NYSEMKT`, `OTC`
+    """
+
+    categories = get('us_tickers')
+    market_range = ['ADR Common Stock',
+                    'ADR Common Stock Primary Class',
+                    'ADR Common Stock Secondary Class',
+                    'ADR Preferred Stock',
+                    'Domestic Common Stock',
+                    'Domestic Common Stock Primary Class',
+                    'Domestic Common Stock Secondary Class',
+                    'Domestic Preferred Stock', ]
+
+    if market == 'ALL':
+        market_match = categories.category.isin(market_range)
+    else:
+        market_match = categories.category.isin([m for m in market_range if market in m])
+
+    def match_ids(column, item):
+        category_match = pd.Series(True, categories.index)
+        if item == 'ALL':
+            pass
+        else:
+            if isinstance(item, str):
+                item = [item]
+            matched_categories = set()
+            all_categories = set(categories[column])
+            for ca in item:
+                matched_categories |= (
+                    set([c for c in all_categories if isinstance(c, str) and re.search(ca, c)]))
+            category_match = categories[column].isin(matched_categories)
+        return category_match
+
+    sector_match = match_ids('sector', sector)
+    industry_match = match_ids('industry', industry)
+
+    exchange_match = pd.Series(True, categories.index)
+    if exchange == 'ALL':
+        pass
+    else:
+        if isinstance(exchange, str):
+            exchange = [exchange]
+        exchange_match = categories.exchange.isin(exchange)
+
+    global universe_stocks
+    universe_stocks = set(categories.stock_id[market_match & sector_match & industry_match & exchange_match])
+
+
 def get(dataset: str, save_to_storage: bool = True, force_download=False):
     """下載歷史資料
 
     請至[歷史資料目錄](https://ai.finlab.tw/database) 來獲得所有歷史資料的名稱，即可使用此函式來獲取歷史資料。
     假設 `save_to_storage` 為 `True` 則，程式會自動在本地複製一份，以避免重複下載大量數據。
 
     Args:
@@ -362,16 +513,16 @@
     not_available_universe_stocks = [
         'benchmark_return', 'institutional_investors_trading_all_market_summary',
         'margin_balance', 'intraday_trading_stat',
         'stock_index_price', 'stock_index_vol',
         'taiex_total_index', 'broker_info',
         'rotc_monthly_revenue', 'rotc_price',
         'world_index', 'rotc_broker_trade_record',
-        'us_price', 'us_sp500',
-        'us_tickers', 'security_categories',
+        'security_categories', 'finlab_tw_stock_market_ind',
+        'us_tickers',
         ]
 
     def refine_stock_id(ret):
 
         if dataset.split(':')[0] in not_available_universe_stocks:
             return ret
         if ':' in dataset:
@@ -380,15 +531,15 @@
             return ret if not universe_stocks else ret.loc[ret['stock_id'].isin(universe_stocks)]
 
         return ret
 
     # not expired
     time_expired = _storage.get_time_expired(dataset)
     if time_expired and time_expired > CacheStorage.now() and not force_download:
-        return refine_stock_id(_storage.get_dataframe(dataset))
+        return refine_stock_id(finlab.dataframe.FinlabDataFrame(_storage.get_dataframe(dataset)))
 
     # request for auth url
     url = 'https://asia-east2-fdata-299302.cloudfunctions.net/auth_generate_data_url'
     params = {
         'api_token': finlab.get_token(),
         'bucket_name': 'finlab_tw_stock_item',
         'blob_name': dataset.replace(':', '#') \
@@ -405,23 +556,23 @@
     try:
         url_data = res.json()
     except:
         raise Exception("Cannot get response from data server.")
 
     # use cache
     global has_print_free_user_warning
-    if has_print_free_user_warning \
+    if not has_print_free_user_warning \
             and 'role' in url_data \
             and url_data['role'] == 'free':
-        logger.warning('Due to your status as a free user, \
-            the most recent data has been shortened or limited.')
+        logger.warning('Due to your status as a free user,'
+            'the most recent data has been shortened or limited.')
         has_print_free_user_warning = True
 
     if 'url' in url_data and url_data['url'] == '':
-        return refine_stock_id(_storage.get_dataframe(dataset))
+        return refine_stock_id(finlab.dataframe.FinlabDataFrame(_storage.get_dataframe(dataset)))
 
     if 'quota' in url_data:
         logger.warning(
             f'{dataset} -- Daily usage: {url_data["quota"]:.1f} / {url_data["limit_size"]} MB')
 
 
 
@@ -436,16 +587,20 @@
             return get(dataset, save_to_storage)
 
         raise Exception(f"**Error: {url_data['error']}")
 
     assert 'url' in url_data
 
     if 'pyodide' in sys.modules:
-        res = requests.getBytes(url_data['url'])
-        df = pd.read_pickle(BytesIO(res), compression='gzip')
+        if hasattr(requests, 'getBytes'):
+            res = requests.getBytes(url_data['url'])
+            df = pd.read_pickle(BytesIO(res), compression='gzip')
+        else:
+            res = requests.get(url_data['url'])
+            df = pd.read_pickle(BytesIO(res.content), compression='gzip')
     else:
         res = requests.get(url_data['url'])
         df = pd.read_feather(BytesIO(res.content))
 
     # set market type on column name
 
     if ':' in dataset:
@@ -518,14 +673,15 @@
     Args:
         indname (str): 指標名稱，
             以 TA-Lib 舉例，例如 SMA, STOCH, RSI 等，可以參考 [talib 文件](https://mrjbq7.github.io/ta-lib/doc_index.html)。
 
             以 Pandas-ta 舉例，例如 supertrend, ssf 等，可以參考 [Pandas-ta 文件](https://twopirllc.github.io/pandas-ta/#indicators-by-category)。
         adjust_price (bool): 是否使用還原股價計算。
         resample (str): 技術指標價格週期，ex: `D` 代表日線, `W` 代表週線, `M` 代表月線。
+        market (str): 市場選擇，ex: `TW_STOCK` 代表台股, `US_STOCK` 代表美股。
         **kwargs (dict): 技術指標的參數設定，TA-Lib 中的 RSI 為例，調整項為計算週期 `timeperiod=14`。
     建議使用者可以先參考以下範例，並且搭配 talib官方文件，就可以掌握製作技術指標的方法了。
     """
     package = None
 
     try:
         from talib import abstract
```

## finlab/dataframe.py

```diff
@@ -287,19 +287,21 @@
       if not hasattr(self.columns, 'name'):
           self.columns.name = 'symbol'
 
       col_name = self.columns.name
 
       unstacked = self.unstack()
 
-      ret = (pd.DataFrame({
+      ret = pd.DataFrame({
           'value': unstacked.values,
           'disclosures': disclosure_dates.values,
         }, unstacked.index)
-        .reset_index(names=[col_name, 'date'])
+      ret.index.names = [col_name, 'date']
+      ret = (ret
+        .reset_index()
         .drop_duplicates(['disclosures', col_name])
         .pivot(index='disclosures', columns=col_name, values='value').ffill()
         .pipe(lambda df: df.loc[df.index.notna()])
         .pipe(lambda df: FinlabDataFrame(df))
         .rename_axis('date')
       )
 
@@ -666,14 +668,16 @@
 
         if rank is not None:
             rank = rank.reindex(
                 union_index, columns=intersect_col, method='ffill')
         else:
             rank = pd.DataFrame(1, index=union_index, columns=intersect_col)
 
+        rank = rank.replace([np.inf, -np.inf], np.nan)
+
         max_rank = rank.max().max()
         min_rank = rank.min().min()
         rank = (rank - min_rank) / (max_rank - min_rank)
         rank.fillna(0, inplace=True)
 
         def rotate_stocks(ret, entry, exit, nstocks_limit, stop_loss=-np.inf, take_profit=np.inf, price=None, ranking=None):
```

## finlab/market_info.py

```diff
@@ -150,38 +150,67 @@
 
             price = finlab.data.get(f'{table_name}{price_name}')
             return price
 
         raise Exception(f'**ERROR: trade_at_price is not allowed (accepted types: pd.DataFrame, pd.Series, str).')
 
 
+class USAllMarketInfo(USMarketInfo):
+    @staticmethod
+    def get_price(trade_at_price, adj=True):
+        if isinstance(trade_at_price, pd.Series):
+            return trade_at_price.to_frame()
+
+        if isinstance(trade_at_price, pd.DataFrame):
+            return trade_at_price
+
+        if isinstance(trade_at_price, str):
+            if trade_at_price == 'volume':
+                return finlab.data.get('us_price_all:volume')
+
+            if adj:
+                table_name = 'us_price_all:adj_'
+                price_name = trade_at_price
+            else:
+                table_name = 'us_price_all:'
+                price_name = trade_at_price
+
+            price = finlab.data.get(f'{table_name}{price_name}')
+            return price
+
+        raise Exception(f'**ERROR: trade_at_price is not allowed (accepted types: pd.DataFrame, pd.Series, str).')
+
+
 def get_market_info(df:Union[None, pd.DataFrame, pd.Series]=None, 
                     user_market_info:Union[None, str, MarketInfo]='AUTO') -> Optional[MarketInfo]:
 
     
     # return market info base on user_market_info
     if user_market_info == 'TW_STOCK':
         return TWMarketInfo()
 
     if user_market_info == 'US_STOCK':
         return USMarketInfo()
 
+    if user_market_info == 'US_STOCK_ALL':
+        return USAllMarketInfo()
+
     if user_market_info != 'AUTO':
         return user_market_info
 
     # deal with user_market_info == 'AUTO'
     if df is not None:
         ids = set([df.name]) if isinstance(df, pd.Series) else set(df.columns)
         for market in [TWMarketInfo(), USMarketInfo()]:
             market_ids = set(market.get_asset_id_to_name().keys())
             id_not_found = ids - market_ids
 
             if len(id_not_found) / len(ids) < 0.5:
                 if len(id_not_found):
-                    logging.warn(f"Symbols {str(id_not_found)[:30]}... not found in MarketInfo.")
+                    logging.warning(f"Symbols {str(id_not_found)[:30]}... not found in MarketInfo.")
                 return market
 
     raise Exception("Market cannot be determined automatically. "
                     "Please set the market argument to either "
                     "'TW_STOCK' for Taiwan stock market, 'US_STOCK' "
                     "for US stock market, or use subclass of MarketInfo"
                     " to specify a different market.")
```

## finlab/plot.py

```diff
@@ -7,14 +7,15 @@
 from finlab.utils import logger
 import itertools
 
 """
 Candles
 """
 
+
 def str_to_indicator(s, df):
     from talib import abstract
     import talib
 
     params = {}
     if '(' in s:
         params = 'dict(' + s.split('(')[-1][:-1] + ')'
@@ -26,15 +27,14 @@
 
     abstract_input = list(func.input_names.values())[0]
     if isinstance(abstract_input, str):
         abstract_input = [abstract_input]
 
     pos_paras = [df[k] for k in abstract_input]
 
-    
     ret = real_func(*pos_paras, **params)
 
     if isinstance(ret, np.ndarray):
         ret = pd.Series(ret, index=df.index)
 
     if isinstance(ret, pd.Series):
         return ret.to_frame(s)
@@ -46,31 +46,14 @@
         yield i
 
 
 def average(series, n):
     return series.rolling(n, min_periods=int(n / 2)).mean()
 
 
-def create_bias_df(df, ma_value=20, bias_multiple=2):
-    bias_df = pd.DataFrame()
-    ma_col_name = f'ma{ma_value}'
-    bias_df[ma_col_name] = average(df['close'], ma_value)
-    std = df['close'].rolling(ma_value, min_periods=int(ma_value / 2)).std()
-    bias_df['upper_band'] = bias_df[ma_col_name] + std * bias_multiple
-    bias_df['lower_band'] = bias_df[ma_col_name] - std * bias_multiple
-    return bias_df
-
-
-def create_stoch_df(df, **kwargs):
-    from talib import abstract
-    kd = abstract.STOCH(df['high'], df['low'], df['close'], **kwargs)
-    kd = pd.DataFrame({'k': kd[0], 'd': kd[1]}, index=df.index)
-    return kd
-
-
 def evaluate_to_df(node, stock_id, df):
     if callable(node):
         node = node(df)
 
     if isinstance(node, str):
         node = str_to_indicator(node, df)
 
@@ -138,18 +121,24 @@
             'close': 'last',
             'open': 'first',
             'high': 'max',
             'low': 'min',
             'volume': 'sum'})
 
     if overlay_func is None:
-        overlay_func = create_bias_df(df)
+        upperband, middleband, lowerband = data.indicator('BBANDS')
+        overlay_func = {
+            'upperband': upperband,
+            'middleband': middleband,
+            'lowerband': lowerband,
+        }
 
     if technical_func is None:
-        technical_func = create_stoch_df(df)
+        k, d = data.indicator('STOCH')
+        technical_func = [{'K': k, 'D': d}]
 
     overlay_indicator = format_indicators(overlay_func, stock_id, df)
 
     # merge overlay indicator if it has multiple plots
     if len(overlay_indicator) > 1:
         overlay_indicator = [pd.concat(overlay_indicator, axis=1)]
         overlay_indicator[0].columns = range(len(overlay_indicator[0].columns))
@@ -169,19 +158,27 @@
         technical_indicator[i] = t_ind
 
     technical_func_num = len(technical_indicator)
     index_value = close.index
 
     nrows = 1 + len(technical_indicator)
 
+    fig_titles = ['']
+    if isinstance(technical_func, list):
+        for t in technical_func:
+            fig_titles.append(','.join(list(t.keys())))
+    elif isinstance(technical_func, dict):
+        fig_titles.append(','.join(list(technical_func.keys())))
+
     fig = make_subplots(
         rows=nrows,
         specs=[[{"secondary_y": True}]] * nrows,
         shared_xaxes=True,
         vertical_spacing=0.05,
+        subplot_titles=fig_titles,
         row_heights=[0.4] + [0.1] * (nrows - 1))
 
     fig.add_trace(
         go.Bar(x=df.index, y=df.volume, opacity=0.3, name="volume", marker={'color': 'gray', 'line_width': 0}),
         row=1, col=1
     )
 
@@ -199,30 +196,26 @@
     # overlay plot
     if overlay_indicator:
         fig_overlay = px.line(overlay_indicator[0])
         for o in fig_overlay.data:
             fig.add_trace(go.Scatter(x=o['x'], y=o['y'], name=o['name'], line=dict(color=next(c)), legendgroup="1"),
                           row=1, col=1, secondary_y=True)
 
-    fig_titles = []
-
     for num, tech_ind in enumerate(technical_indicator):
         fig_tech = px.line(tech_ind)
         for t in fig_tech.data:
             color = next(c)
 
             fig.add_trace(
                 go.Scatter(x=t['x'], y=t['y'], name=t['name'], line=dict(color=color),
                            legendgroup=str(2 + num),
 
                            ),
                 row=2 + num, col=1)
 
-        fig_titles.append(" , ".join([t.name for t in fig_tech.data]))
-
     # hide holiday
     if resample == 'D':
         dt_all = pd.date_range(start=index_value[0], end=index_value[-1])
         # retrieve the dates that are in the original dataset
         dt_obs = [d.strftime("%Y-%m-%d") for d in pd.to_datetime(index_value)]
         # define dates with missing values
         dt_breaks = [d for d in dt_all.strftime("%Y-%m-%d").tolist() if d not in dt_obs]
@@ -258,18 +251,14 @@
     )
 
     fig.update_layout(**{
         'xaxis1_rangeslider_visible': False,
         f'xaxis': dict(
             rangeselector=dict(
                 buttons=list([
-                    #                 dict(count=3,
-                    #                      label="3m",
-                    #                      step="month",
-                    #                      stepmode="backward"),
                     dict(count=6,
                          label="6m",
                          step="month",
                          stepmode="backward"),
                     dict(count=1,
                          label="YTD",
                          step="year",
@@ -291,21 +280,15 @@
             type="date",
         ),
     })
 
     # fig.update_traces(xaxis='x2')
     fig.update_xaxes(showspikes=True)
     fig.update_yaxes(showspikes=True, spikemode="across")
-
     fig.update_layout(showlegend=False)
-
-    fig.update_layout({f'xaxis{i + 1}': {'title': t, 'side': 'right'} for i, t in enumerate(fig_titles)})
-    fig.update_layout({f'yaxis{i * 2 + 4}': {'showticklabels': False} for i, t in enumerate(fig_titles)})
-    fig.update_layout({f'yaxis{i * 2 + 4}': {'showticklabels': False} for i, t in enumerate(fig_titles)})
-
     fig.update_layout(plot_bgcolor="white")
     fig.update_xaxes(showline=True, linecolor='#ddd')
     fig.update_yaxes(showline=True, linecolor='#ddd')
     fig.update_yaxes(titlefont=dict(
         color="#777"
     ),
         tickfont=dict(
@@ -665,20 +648,24 @@
                  'fundamental_features:現金流量比率', 'fundamental_features:負債比率']
         plot_tw_stock_radar(portfolio=["9939"], feats=feats, mode="line_polar", line_polar_fill='toself', cut_bins=8)
         ```
         ![單檔標的子選指標雷達圖](img/plot/radar_single.png)
     """
     if custom_data is None:
         if feats is None:
-            feats = ['fundamental_features:營業毛利率', 'fundamental_features:營業利益率', 'fundamental_features:稅後淨利率',
-                     'fundamental_features:ROA綜合損益', 'fundamental_features:ROE綜合損益', 'fundamental_features:業外收支營收率',
+            feats = ['fundamental_features:營業毛利率', 'fundamental_features:營業利益率',
+                     'fundamental_features:稅後淨利率',
+                     'fundamental_features:ROA綜合損益', 'fundamental_features:ROE綜合損益',
+                     'fundamental_features:業外收支營收率',
                      'fundamental_features:現金流量比率', 'fundamental_features:負債比率',
-                     'fundamental_features:流動比率', 'fundamental_features:速動比率', 'fundamental_features:存貨週轉率',
+                     'fundamental_features:流動比率', 'fundamental_features:速動比率',
+                     'fundamental_features:存貨週轉率',
                      'fundamental_features:營收成長率', 'fundamental_features:營業毛利成長率',
-                     'fundamental_features:營業利益成長率', 'fundamental_features:稅前淨利成長率', 'fundamental_features:稅後淨利成長率',
+                     'fundamental_features:營業利益成長率', 'fundamental_features:稅前淨利成長率',
+                     'fundamental_features:稅後淨利成長率',
                      'fundamental_features:資產總額成長率', 'fundamental_features:淨值成長率'
                      ]
         df = get_rank_df(feats, period=period, cut_bins=cut_bins)
     else:
         df = custom_data.copy()
 
     col_name = df.columns
@@ -793,15 +780,15 @@
 
     def process_position(self, s_name, s_weight=1):
         if s_name == '現金':
             result = pd.DataFrame({'return': 0, 'weight': 1, 'category': '現金', 'market': '現金'}, index=['現金'])
             result.index.name = 'stock_id'
         else:
             df = pd.DataFrame(self.s_data[s_name]['positions'])
-            df = df.drop(columns=['last_updated', 'next_trading_date', 'trade_at', 'update_date'])
+            df = df[[c for c in df.columns if ' ' in c]]
             df = df.T
             df['weight'] = df['weight'].apply(lambda s: abs(pd.to_numeric(s, errors='coerce')))
             df = df[df['weight'] > 0]
             if len(df) == 0:
                 df['weight'] = 0
             df.index.name = 'stock_id'
             old_security_categories = data.get('security_categories')
```

## finlab/utils.py

```diff
@@ -189,15 +189,15 @@
             return _finlab_global_objects[name]
         else:
             return None
 
     def set_global(name, obj):
         nonlocal _finlab_global_objects
         _finlab_global_objects[name] = obj
-        if "pyodide" in sys.modules:
+        if "pyodide" in sys.modules and "js" in sys.modules:
             import js
             from pyodide import ffi
             js.postMessage(ffi.to_js({'content': name, 'finish': False, 'type': 'py_global_update', 'id': js._pyodide_execution_id}))
 
 
     return get_global, set_global
```

## finlab/analysis/__init__.py

```diff
@@ -116,26 +116,15 @@
         """
         return super().get_mae_mfe()
 
     def get_trades(self):
         """取得回測逐筆交易紀錄
 
         Returns:
-          (pd.DataFrame): 交易紀錄
-        """
-        return super().get_trades()
-
-    def get_stats(self, resample='1d', riskfree_rate=0.02):
-        """取得策略統計數據
-        取得數據如夏普率、索提諾比率、最大回檔、近期報酬率統計...
-        Args:
-            resample (str): 報酬率檢測週期，其他常用數值為 W、 M 、Q（每週、每月、每季換股）。
-            riskfree_rate (float): 無風險利率。
-        Returns:
-            (dict): 策略指標數據，包含：
+          (pd.DataFrame): 交易紀錄，欄位包含：
 
             * entry_sig_date:進場訊號產生日。
             * exit_sig_date:出場訊號產生日。
             * entry_date:進場日。
             * exit_date:出場日。
             * position:持有佔比。
             * period:持有天數。
@@ -144,14 +133,25 @@
             * trade_price@exit_date:出場價。
             * mae:持有期間最大不利報酬率幅度。
             * gmfe:持有期間最大有利報酬率幅度。
             * bmfe:mae發生前的最大有利報酬率幅度。
             * mdd:持有期間最大回撤。
             * pdays:處於獲利時的天數。
         """
+        return super().get_trades()
+
+    def get_stats(self, resample='1d', riskfree_rate=0.02):
+        """取得策略統計數據
+        取得數據如：年化報酬、勝率、夏普率、索提諾比率、最大回檔、近期各年月報酬率統計、alpha_beta...
+        Args:
+            resample (str): 報酬率檢測週期，其他常用數值為 W、 M 、Q（每週、每月、每季換股）。
+            riskfree_rate (float): 無風險利率，與夏普率計算有關。
+        Returns:
+            (dict): 策略指標數據
+        """
         return super().get_stats(resample, riskfree_rate)
 
     def run_analysis(self, analysis, display=True, **kwargs):
         """執行策略分析外掛模組
         Args:
           analysis (str or object): `finlab.analysis`內的分析模組名稱，ex:`'liquidityAnalysis'`。
           display (bool): 是否顯示模組分析圖表。
```

## finlab/analysis/maeMfeAnalysis.py

```diff
@@ -86,15 +86,15 @@
         if len(mae_mfe_window_col) == 0:
             edge_ratio = pd.DataFrame({'time_scale': [1], 'mean_edge_ratio': [1]})
         else:
             edge_ratio = pd.DataFrame(
                 [{'time_scale': m, 
                   'mean_edge_ratio': (
                       (mae_mfe[m]['gmfe']).sum()) / (abs(mae_mfe[m]['mae']).sum())} 
-                        for m in mae_mfe_window_col])
+                        for m in mae_mfe_window_col]).sort_values(['time_scale'])
 
         # mdd_gmfe:use for trailing stop
         mdd_gmfe = trade_record[(trade_record['mdd'] > trade_record['gmfe'])]
         pl_count = trade_record.groupby(['profit_loss'])['mdd'].count()
         breakeven_safe_pct = abs(round((len(mdd_gmfe) / len(trade_record) - 1) * 100))
         missed_profits_pct = round(len(mdd_gmfe[mdd_gmfe['profit_loss'] == 'profit']) / pl_count['profit'] * 100)
```

## finlab/analysis/periodStatsAnalysis.py

```diff
@@ -1,8 +1,9 @@
 import numpy as np
+import pandas as pd
 from finlab.analysis import Analysis
 
 class PeriodStatsAnalysis(Analysis):
 
     def __init__(self):
         """分析台股策略的不同時期與大盤指標作比較
```

## finlab/core/backtest_core.pyx

```diff
@@ -198,15 +198,15 @@
   # 當天是否需要更新上述 pos_id，也就是 current_position_id != pos_id 之時
   cdef bool new_pos = False
 
   # 回測未實現和已實現損益，為所有的 cash + pos 的部位
   cdef double balance = 1
 
   # 判斷當天是否要進行再平衡
-  cdef bool should_rebalance = False
+  cdef bool should_rebalance = True
 
   # 回測每天的淨資產部位
   cdef np.ndarray[double, ndim=1] creturn = org_np.empty(price_index.size, dtype=org_np.float64)
 
   # 回測當下的各個資產的損益 1.1 代表獲利 10%
   cdef np.ndarray[double, ndim=1] cr = org_np.ones(pos_values[0].size)
 
@@ -511,14 +511,21 @@
 
   latest_weight_sum = max(1, latest_weight_sum)
 
   for key in stock_operations['weights']:
     stock_operations['weights'][key] /= latest_weight_sum
 
   for sid, val1 in enumerate(pos_values[pos_id]):
+    
+    # skip if the stock is already exited in current round
+    if stop_trading_next_period:
+        for exited_s in exited_stocks:
+            if exited_s == sid:
+                continue
+
     if val1 != 0:
       stock_operations["next_weights"][sid] = val1
 
   stock_operations['weights'] = normalize_weight(stock_operations['weights'], position_limit)
 
   stock_operations['next_weights'] = normalize_weight(stock_operations['next_weights'], position_limit)
```

## finlab/core/report.pyx

```diff
@@ -9,14 +9,19 @@
 import os
 import finlab
 from finlab import ffn_core
 from finlab import get_token
 from finlab.utils import logger, requests
 from finlab import market_info
 
+def is_in_vscode():
+    for k in os.environ.keys():
+        if 'VSCODE' in k:
+            return True
+    return False
 
 class Report(object):
 
     def __init__(self, creturn, position, fee_ratio, tax_ratio, trade_at, next_trading_date, market_info):
         # cumulative return
         self.creturn = creturn
         self.daily_creturn = self.creturn.resample('1d').last().dropna().ffill().rebase()
@@ -315,20 +320,23 @@
             print('error message', result['message'])
             return {'status': 'error', 'message': result['status']}
 
         if not display:
             return {'status': 'success'}
 
         try:
-            from IPython.display import IFrame, display
-            url = 'https://ai.finlab.tw/strategy/?uid=' + \
-                  result['uid'] + '&sid=' + result['strategy_id']
+            if is_in_vscode():
+                self.display()
+            else:
+                from IPython.display import IFrame, display
+                url = 'https://ai.finlab.tw/strategy/?uid=' + \
+                      result['uid'] + '&sid=' + result['strategy_id']
 
-            iframe = IFrame(url, width='100%', height=600)
-            display(iframe)
+                iframe = IFrame(url, width='100%', height=600)
+                display(iframe)
 
         except Exception as e:
             print(e)
             print('Install ipython to show the complete backtest results.')
 
         return {'status': 'success'}
```

## finlab/ml/alphalens.py

```diff
@@ -1,8 +1,9 @@
 import matplotlib.pyplot as plt
+import numpy as np
 import pandas as pd
 from typing import List
 from alphalens.tears import GridFigure
 
 from alphalens import plotting
 from alphalens import performance as perf
 from alphalens import utils
@@ -67,15 +68,99 @@
         )
 
     plt.show()
     gf.close()
 
 alphalens.tears.create_turnover_tear_sheet = create_turnover_tear_sheet
 
-def create_factor_data(factor:pd.DataFrame, adj_close:pd.DataFrame, days:List[int]=[1,5,10]):
+
+def factor_weights(factor_data,
+                   demeaned=True,
+                   group_adjust=False,
+                   equal_weight=False):
+    """
+    Computes asset weights by factor values and dividing by the sum of their
+    absolute value (achieving gross leverage of 1). Positive factor values will
+    results in positive weights and negative values in negative weights.
+
+    Parameters
+    ----------
+    factor_data : pd.DataFrame - MultiIndex
+        A MultiIndex DataFrame indexed by date (level 0) and asset (level 1),
+        containing the values for a single alpha factor, forward returns for
+        each period, the factor quantile/bin that factor value belongs to, and
+        (optionally) the group the asset belongs to.
+        - See full explanation in utils.get_clean_factor_and_forward_returns
+    demeaned : bool
+        Should this computation happen on a long short portfolio? if True,
+        weights are computed by demeaning factor values and dividing by the sum
+        of their absolute value (achieving gross leverage of 1). The sum of
+        positive weights will be the same as the negative weights (absolute
+        value), suitable for a dollar neutral long-short portfolio
+    group_adjust : bool
+        Should this computation happen on a group neutral portfolio? If True,
+        compute group neutral weights: each group will weight the same and
+        if 'demeaned' is enabled the factor values demeaning will occur on the
+        group level.
+    equal_weight : bool, optional
+        if True the assets will be equal-weighted instead of factor-weighted
+        If demeaned is True then the factor universe will be split in two
+        equal sized groups, top assets with positive weights and bottom assets
+        with negative weights
+
+    Returns
+    -------
+    returns : pd.Series
+        Assets weighted by factor value.
+    """
+
+    def to_weights(group, _demeaned, _equal_weight):
+
+        if _equal_weight:
+            group = group.copy()
+
+            if _demeaned:
+                # top assets positive weights, bottom ones negative
+                group = group - group.median()
+
+            negative_mask = group < 0
+            group[negative_mask] = -1.0
+            positive_mask = group > 0
+            group[positive_mask] = 1.0
+
+            if _demeaned:
+                # positive weights must equal negative weights
+                if negative_mask.any():
+                    group[negative_mask] /= negative_mask.sum()
+                if positive_mask.any():
+                    group[positive_mask] /= positive_mask.sum()
+
+        elif _demeaned:
+            group = group - group.mean()
+
+        return group / group.abs().sum()
+
+    grouper = ['date']
+    if group_adjust:
+        grouper.append('group')
+
+    weights = factor_data.groupby(grouper, group_keys=False)['factor'] \
+        .apply(to_weights, demeaned, equal_weight)
+
+    if group_adjust:
+        weights = weights.groupby(level='date', group_keys=False).apply(to_weights, False, False)
+
+    return weights
+
+from alphalens import performance
+performance.factor_weights = factor_weights
+
+
+def create_factor_data(factor:pd.DataFrame, adj_close:pd.DataFrame, 
+                       days:List[int]=[5,10,20, 60]):
 
     '''create factor data, which contains future return
     Args:
         factor (pd.DataFrame): factor data where index is datetime and columns is asset id
         adj_close (pd.DataFrame): adj close where index is datetime and columns is asset id
         days (List[int]): future return considered
     Return:
@@ -95,28 +180,29 @@
         alphalens.tears.create_full_tear_sheet(factor_data.dropna(), long_short=False,
                                                group_neutral=False, by_group=False)
 
         ```
 
     '''
 
-
-
     adj_close = adj_close.loc[factor.index[0]:factor.index[-1]]
     factor = factor.reindex(adj_close.index, method='ffill').loc[factor.index[0]:factor.index[-1]]
 
     sids = adj_close.columns.intersection(factor.columns)
     adj_close = adj_close[sids]
     factor = factor[sids]
 
     ret = {}
-    ret['factor'] = factor
-    ret['factor_quantile'] = (factor.rank(axis=1, pct=True) // 0.2)
+    ret['factor'] = factor.unstack().values
+    ret['factor_quantile'] = (factor.rank(axis=1, pct=True) // 0.2).unstack().values
 
-    days = [1, 5, 10]
-    for d in days:
-        ret[f"{d}D"] = adj_close.shift(-d-1) / adj_close.shift(-1) - 1
+    total_index = None
 
-    ret = combine(ret)
-    ret.index = ret.index.rename(['date', 'asset'])
+    for d in days:
+        temp = (adj_close.shift(-d-1) / adj_close.shift(-1) - 1).unstack()
+        ret[f"{d}D"] = temp.values
+        total_index = temp.index
+    ret = pd.DataFrame(ret, index=total_index.swaplevel(0, 1))\
+        .replace([-np.inf, np.inf], np.nan)\
+        .dropna()
+    ret.index.names = ['date', 'asset']
     return ret
-
```

## finlab/ml/qlib.py

```diff
@@ -434,15 +434,16 @@
         tmin = X.index.get_level_values('datetime').min()
         tmax = X.index.get_level_values('datetime').max()
 
         tsplit = (tmax - tmin) * train_test_split + tmin
 
         segments = dict(
             train=(tmin, tsplit),
-            valid=(tsplit + datetime.timedelta(days=1), tmax)
+            valid=(tsplit + datetime.timedelta(days=1), tmax),
+            test=(tsplit + datetime.timedelta(days=1), tmax)
         )
         dl = CustomDataLoader(d)
         return DatasetH(handler=DataHandlerLP(data_loader=dl, learn_processors=_DEFAULT_LEARN_PROCESSORS), segments=segments)
 
 
     x = X.copy()
     x.columns = pd.MultiIndex.from_tuples([('feature', x) for x in x.columns])
```

## finlab/online/fugle_account.py

```diff
@@ -50,23 +50,19 @@
         self.sdk = sdk
 
         self.market_api_key = market_api_key
 
         self.trades = {}
         self.thread = None
 
-    def create_order(self, action, stock_id, quantity, price=None, odd_lot=False, best_price_limit=False, market_order=False, order_cond=OrderCondition.CASH):
+    def create_order(self, action, stock_id, quantity, price=None, odd_lot=False, best_price_limit=False, market_order=False, order_cond=OrderCondition.CASH, extra_bid_pct=0):
 
         if quantity <= 0:
             raise ValueError("quantity should be larger than zero")
 
-        if best_price_limit and market_order:
-            raise ValueError(
-                "The flags best_price_limit and  market_order should not both be True")
-
         fugle_action = fugleAction.Buy if action == Action.BUY else fugleAction.Sell
 
         price_flag = PriceFlag.Limit if price else PriceFlag.Flat
 
         if market_order:
             price = None
             if action == Action.BUY:
@@ -76,14 +72,16 @@
 
         elif best_price_limit:
             price = None
             if action == Action.BUY:
                 price_flag = PriceFlag.LimitDown
             elif action == Action.SELL:
                 price_flag = PriceFlag.LimitUp
+        elif extra_bid_pct > 0:
+            price = calculate_price_with_extra_bid(price, extra_bid_pct, action)
 
         order_cond = {
             OrderCondition.CASH: Trade.Cash,
             OrderCondition.MARGIN_TRADING: Trade.Margin,
             OrderCondition.SHORT_SELLING: Trade.Short,
             # OrderCondition.DAY_TRADING_LONG: Trade.DayTrading,
             OrderCondition.DAY_TRADING_SHORT: Trade.DayTradingSell,
@@ -223,18 +221,20 @@
         for i in inv:
 
             # removed: position of stk_dats is not completed
             # total_qty = sum([int(d['qty']) for d in i['stk_dats']]) / 1000
             total_qty = (int(i['qty_l']) +
                          int(i['qty_bm']) - int(i['qty_sm'])) / 1000
 
+            o = order_condition[i['trade']]
+
             if total_qty != 0:
                 ret.append({
                     'stock_id': i['stk_no'],
-                    'quantity': total_qty,
+                    'quantity': total_qty if o != OrderCondition.SHORT_SELLING else -total_qty,
                     'order_condition': order_condition[i['trade']]
                 })
 
         return Position.from_list(ret)
 
     def get_total_balance(self):
         # get bank balance
@@ -342,7 +342,37 @@
         open=r['data']['quote']['priceOpen']['price'] if has_volume else np.nan,
         bid_price=bids[0]['price'] if bids else np.nan,
         ask_price=asks[0]['price'] if asks else np.nan,
         bid_volume=bids[0]['volume'] if bids else 0,
         ask_volume=asks[0]['volume'] if asks else 0,
     )
 
+def calculate_price_with_extra_bid(price, extra_bid_pct, action):
+    if action == Action.BUY:
+        result = price * (1 + extra_bid_pct)
+        if result <= 10:
+            result = math.floor(round(result, 3) * 100) / 100
+        elif result <= 50:
+            result = math.floor(result * 20) / 20
+        elif result <= 100:
+            result = math.floor(result * 10) / 10
+        elif result <= 500:
+            result = math.floor(result * 2) / 2
+        elif result <= 1000:
+            result = math.floor(result)
+        else:
+            result = math.floor(result / 5) * 5
+    elif action == Action.SELL:
+        result = price * (1 - extra_bid_pct)
+        if result <= 10:
+            result = math.ceil(round(result, 3) * 100) / 100
+        elif result <= 50:
+            result = math.ceil(result * 20) / 20
+        elif result <= 100:
+            result = math.ceil(result * 10) / 10
+        elif result <= 500:
+            result = math.ceil(result * 2) / 2
+        elif result <= 1000:
+            result = math.ceil(result)
+        else:
+            result = math.ceil(result / 5) * 5
+    return result
```

## finlab/online/order_executor.py

```diff
@@ -201,15 +201,15 @@
         tz = datetime.timezone(datetime.timedelta(hours=8))
         next_trading_time = report.next_trading_date.tz_localize(tz) + datetime.timedelta(hours=16)
 
         if datetime.datetime.now(tz) >= next_trading_time:
             w = report.next_weights
         else:
             w = report.weights.copy()
-            w.loc[report.actions[report.actions == 'sl_tp_exit'].index] = 0
+            w.loc[report.actions[report.actions.isin(['sl', 'tp'])].index] = 0
 
         w = w.groupby(w.index).last()
 
         return cls.from_weight(w, fund, **kwargs)
 
     def to_json(self, path):
         with open(path, 'w') as f:
@@ -342,22 +342,27 @@
     def cancel_orders(self):
         """刪除所有未實現委託單"""
         orders = self.account.get_orders()
         for oid, o in orders.items():
             if o.status == OrderStatus.NEW or o.status == OrderStatus.PARTIALLY_FILLED:
                 self.account.cancel_order(oid)
 
-    def create_orders(self, market_order=False, best_price_limit=False, view_only=False):
+    def create_orders(self, market_order=False, best_price_limit=False, view_only=False, extra_bid_pct=0):
         """產生委託單，將部位同步成 self.target_position
         預設以該商品最後一筆成交價設定為限價來下單
         Attributes:
             market_order (bool): 以類市價盡量即刻成交：所有買單掛漲停價，所有賣單掛跌停價
             best_price_limit (bool): 掛芭樂價：所有買單掛跌停價，所有賣單掛漲停價
-            view_only (bool): 預設為 False，會實際下單。若設為 True，不會下單，只會回傳欲執行的委託單資料(dict)。
+            view_only (bool): 預設為 False，會實際下單。若設為 True，不會下單，只會回傳欲執行的委託單資料(dict)
+            extra_bid_pct (float): 以該百分比值乘以價格進行追價下單，如設定為 0.1 時，將以超出(低於)昨日收盤價之10%漲停(跌停)價格下單。參數有效範圍為 0 到 0.1 內
         """
+        if [market_order, best_price_limit, bool(extra_bid_pct)].count(True) > 1:
+            raise ValueError("Only one of 'market_order', 'best_price_limit', or 'extra_bid_pct' can be set.")
+        if extra_bid_pct < 0 or extra_bid_pct > 0.1:
+            raise ValueError("The extra_bid_pct parameter is out of the valid range 0 to 0.1")
 
         present_position = self.account.get_position()
         orders = (self.target_position - present_position).position
 
         if view_only:
             return orders
 
@@ -379,45 +384,52 @@
             if best_price_limit:
                 price_string = 'LOWEST' if action == Action.BUY else 'HIGHEST'
             elif market_order:
                 price_string = 'HIGHEST' if action == Action.BUY else 'LOWEST'
             else:
                 price_string = str(price)
 
+            extra_bid_text = ''
+            if extra_bid_pct > 0:
+                extra_bid_text = f'with extra bid {extra_bid_pct*100}%'
+
             print('execute', action, o['stock_id'], 'X', abs(
-                o['quantity']), '@', price_string, o['order_condition'])
+                o['quantity']), '@', price_string, extra_bid_text, o['order_condition'])
 
             quantity = abs(o['quantity'])
             board_lot_quantity = int(abs(quantity // 1))
             odd_lot_quantity = int(abs(round(1000 * (quantity % 1))))
 
             if self.account.sep_odd_lot_order():
                 if odd_lot_quantity != 0:
                     self.account.create_order(action=action,
                                               stock_id=o['stock_id'],
                                               quantity=odd_lot_quantity,
                                               price=price, market_order=market_order,
                                               order_cond=o['order_condition'],
                                               odd_lot=True,
-                                              best_price_limit=best_price_limit)
+                                              best_price_limit=best_price_limit,
+                                              extra_bid_pct=extra_bid_pct)
 
                 if board_lot_quantity != 0:
                     self.account.create_order(action=action,
                                               stock_id=o['stock_id'],
                                               quantity=board_lot_quantity,
                                               price=price, market_order=market_order,
                                               order_cond=o['order_condition'],
-                                              best_price_limit=best_price_limit)
+                                              best_price_limit=best_price_limit,
+                                              extra_bid_pct=extra_bid_pct)
             else:
                 self.account.create_order(action=action,
                                           stock_id=o['stock_id'],
                                           quantity=quantity,
                                           price=price, market_order=market_order,
                                           order_cond=o['order_condition'],
-                                          best_price_limit=best_price_limit)
+                                          best_price_limit=best_price_limit,
+                                          extra_bid_pct=extra_bid_pct)
 
     def update_order_price(self):
         """更新委託單，將委託單的限價調整成當天最後一筆價格。
         （讓沒成交的限價單去追價）"""
         orders = self.account.get_orders()
         sids = set([o.stock_id for i, o in orders.items()])
         stocks = self.account.get_stocks(sids)
```

## finlab/online/sinopac_account.py

```diff
@@ -1,12 +1,13 @@
 import shioaji as sj
 import datetime
 import time
 import os
 import re
+import math
 
 from finlab.online.base_account import Account, Stock, Order, Position
 from finlab.online.enums import *
 
 pattern = re.compile(r'(?<!^)(?=[A-Z])')
 
 
@@ -37,39 +38,41 @@
 
         self.api.activate_ca(
             ca_path=certificate_path,
             ca_passwd=certificate_password,
             person_id=certificate_person_id,
         )
 
-    def create_order(self, action, stock_id, quantity, price=None, odd_lot=False, market_order=False, best_price_limit=False, order_cond=OrderCondition.CASH):
+    def create_order(self, action, stock_id, quantity, price=None, odd_lot=False, market_order=False, best_price_limit=False, order_cond=OrderCondition.CASH, extra_bid_pct=0):
 
         contract = self.api.Contracts.Stocks.get(stock_id)
 
         assert quantity > 0
         assert contract is not None
 
         if price == None:
             price = self.api.snapshots([contract])[0].close
 
-        if market_order:
-            price_type = sj.constant.StockPriceType.MKT
-        else:
-            price_type = sj.constant.StockPriceType.LMT
+        price_type = sj.constant.StockPriceType.LMT
 
         if market_order:
-            if action == Action.BUY:
-                price = contract.limit_up
-            elif action == Action.SELL:
-                price = contract.limit_down
+            if odd_lot:
+                price = calculate_price_with_extra_bid(price, 0.1, action)
+            else: 
+                if action == Action.BUY:
+                    price = contract.limit_up
+                elif action == Action.SELL:
+                    price = contract.limit_down
         elif best_price_limit:
             if action == Action.BUY:
                 price = contract.limit_down
             elif action == Action.SELL:
                 price = contract.limit_up
+        elif extra_bid_pct > 0:
+            price = calculate_price_with_extra_bid(price, extra_bid_pct, action)
 
         if action == Action.BUY:
             action = 'Buy'
         elif action == Action.SELL:
             action = 'Sell'
 
         daytrade_short = order_cond == OrderCondition.DAY_TRADING_SHORT
@@ -219,7 +222,38 @@
 
 
 def snapshot_to_stock(snapshot):
     """將 shioaji 股價行情轉換成 finlab 格式"""
     d = snapshot
     return Stock(stock_id=d.code, open=d.open, high=d.high, low=d.low, close=d.close,
                bid_price=d.buy_price, ask_price=d.sell_price, bid_volume=d.buy_volume, ask_volume=d.sell_volume)
+
+def calculate_price_with_extra_bid(price, extra_bid_pct, action):
+    if action == Action.BUY:
+        result = price * (1 + extra_bid_pct)
+        if result <= 10:
+            result = math.floor(round(result, 3) * 100) / 100
+        elif result <= 50:
+            result = math.floor(result * 20) / 20
+        elif result <= 100:
+            result = math.floor(result * 10) / 10
+        elif result <= 500:
+            result = math.floor(result * 2) / 2
+        elif result <= 1000:
+            result = math.floor(result)
+        else:
+            result = math.floor(result / 5) * 5
+    elif action == Action.SELL:
+        result = price * (1 - extra_bid_pct)
+        if result <= 10:
+            result = math.ceil(round(result, 3) * 100) / 100
+        elif result <= 50:
+            result = math.ceil(result * 20) / 20
+        elif result <= 100:
+            result = math.ceil(result * 10) / 10
+        elif result <= 500:
+            result = math.ceil(result * 2) / 2
+        elif result <= 1000:
+            result = math.ceil(result)
+        else:
+            result = math.ceil(result / 5) * 5
+    return result
```

## finlab/online/test.py

```diff
@@ -15,16 +15,19 @@
   time.sleep(11)
   oe.create_orders(**args_for_creating_orders)
   orders = oe.account.get_orders()
 
   stock_orders = {o['stock_id']: o for o in view_orders}
   stock_quantity = {o.stock_id: 0 for oid, o in orders.items()}
 
+
   for oid, o in orders.items():
-    if o.status == OrderStatus.CANCEL:
+    if o.status == OrderStatus.CANCEL\
+        or o.stock_id not in stock_orders\
+        or o.status == OrderStatus.FILLED:
         continue
 
     # get stock id
     sid = o.stock_id
 
     # check order condition and action
     expect_action = Action.BUY if stock_orders[sid]['quantity'] > 0 else Action.SELL
@@ -108,7 +111,34 @@
 
       pos = Position({"2330": 2}, day_trading_long=True)
       pos.fall_back_cash()
       assert pos.position[0]['stock_id'] == '2330'
       assert pos.position[0]['quantity'] == 2
       assert pos.position[0]['order_condition'] == OrderCondition.CASH
 
+class CalculatePriceWithExtraBidTest(unittest.TestCase):
+    def test_calculate_price_with_extra_bid(self):
+        from fugle_account import calculate_price_with_extra_bid, Action
+        test_data = {
+            'test_1': {'price': 5.2, 'extra_bid_pct': 0.06, 'action': Action.BUY, 'expected_result': 5.51},
+            'test_2': {'price': 7.4, 'extra_bid_pct': 0.02, 'action': Action.SELL, 'expected_result': 7.26},
+            'test_3': {'price': 25.65, 'extra_bid_pct': 0.1, 'action': Action.BUY, 'expected_result': 28.20},
+            'test_4': {'price': 11.05, 'extra_bid_pct': 0.1, 'action': Action.SELL, 'expected_result': 9.95},
+            'test_5': {'price': 87.0, 'extra_bid_pct': 0.04, 'action': Action.BUY, 'expected_result': 90.4},
+            'test_6': {'price': 73.0, 'extra_bid_pct': 0.06, 'action': Action.SELL, 'expected_result': 68.7},
+            'test_7': {'price': 234.0, 'extra_bid_pct': 0.08, 'action': Action.BUY, 'expected_result': 252.5},
+            'test_8': {'price': 234.0, 'extra_bid_pct': 0.08, 'action': Action.SELL, 'expected_result': 215.5},
+            'test_9': {'price': 650.0, 'extra_bid_pct': 0.05, 'action': Action.BUY, 'expected_result': 682},
+            'test_10': {'price': 756.0, 'extra_bid_pct': 0.055, 'action': Action.SELL, 'expected_result': 715},
+            'test_11': {'price': 1990.0, 'extra_bid_pct': 0.035, 'action': Action.BUY, 'expected_result': 2055},
+            'test_12': {'price': 1455.0, 'extra_bid_pct': 0.088, 'action': Action.SELL, 'expected_result': 1330},
+        }
+
+        for test_name, test_case in test_data.items():
+            price = test_case['price']
+            extra_bid_pct = test_case['extra_bid_pct']
+            action = test_case['action']
+            expected_result = test_case['expected_result']
+
+            with self.subTest(test_name=test_name):
+                result = calculate_price_with_extra_bid(price, extra_bid_pct, action)
+                self.assertEqual(result, expected_result)
```

## finlab/optimize/combinations.py

```diff
@@ -1,12 +1,13 @@
 from itertools import combinations
 import pandas as pd
 from finlab.backtest import sim
 from finlab.core.report import Report
 from finlab.utils import logger
+from finlab.dataframe import FinlabDataFrame
 
 
 def sim_conditions(conditions, hold_until={}, *args, **kwargs):
     """取得回測報告集合
 
     將選股條件排出所有的組合並進行回測，方便找出最好條件的交集結果。
 
@@ -67,26 +68,36 @@
 
         `report_collection.plot_stats('heatmap')`
 
         繪製指標分級熱力圖，數值越大為排名越前面，avg_score為指標平均分數，分數越高為評價較正向的策略。
 
         ![heatmap](img/optimize/report_collection_stats_heatmap.png)
     """
+
     key_dataset = []
     conditions.pop('__builtins__', None)
-    for i in range(1, len(conditions) + 1):
-        key_dataset.extend(list(combinations(conditions.keys(), i)))
+    new_conditions = {}
+    for k, v in conditions.items():
+        try:
+            v = FinlabDataFrame(v)
+            if isinstance(v.index[0], str):
+                v = v.index_str_to_date()
+            new_conditions[k] = v
+        except:
+            logger.error(f'{k} data formaat must be dataframe.')
+    for i in range(1, len(new_conditions) + 1):
+        key_dataset.extend(list(combinations(new_conditions.keys(), i)))
     conditions_combinations = [' & '.join(k) for k in key_dataset]
 
     reports = {}
     for k in conditions_combinations:
         if hold_until:
-            position = eval(k, conditions).hold_until(**hold_until)
+            position = eval(k, new_conditions).hold_until(**hold_until)
         else:
-            position = eval(k, conditions)
+            position = eval(k, new_conditions)
         try:
             reports[k] = sim(position, *args, **kwargs)
         except Exception as error:
             logger.error(f'{k}:{error}')
             pass
 
     return ReportCollection(reports)
```

## Comparing `finlab-0.4.4.dist-info/LICENSE` & `finlab-0.4.5.dist-info/LICENSE`

 * *Files identical despite different names*

## Comparing `finlab-0.4.4.dist-info/RECORD` & `finlab-0.4.5.dist-info/RECORD`

 * *Files 16% similar despite different names*

```diff
@@ -1,54 +1,54 @@
-finlab/__init__.py,sha256=EpabuEYUhvTgRbbtlFnBNOPsXDPyJqWzAyonsSRRv8E,2522
-finlab/backtest.py,sha256=PGfO-SoplIsyTNcYFHBTrRb0tCiWn8V9atxxXg4bRzE,22853
+finlab/__init__.py,sha256=JVDPtbZVifWC38o8plefaDJEjzoqqQ6jxRf-HkfSmJ8,2522
+finlab/backtest.py,sha256=9GvsDvDo4AUcvDLQXkzxSfa31GKnRBSf-VvLSbvYDZQ,23142
 finlab/backtest_old.py,sha256=7K66Z0BkT1zsLc4F6POlLrVF7khPVhLXL69wRgE3ay8,1424
 finlab/cells.py,sha256=nRlhr8mvdViA7P8d9rHtCYe8tqbY8gVHzHsvzhY9TCo,915
-finlab/data.py,sha256=uSv0ISG-Sdq5OqNCekmakSbi4Gt725m2bDC4JKq0bCs,29964
-finlab/dataframe.py,sha256=pBdH5zm22U7dvzyRvCzs3f6EqEwYe8FfcsK2tp2Dwx0,30989
+finlab/data.py,sha256=gkobahb5yLuK8t32oTFK2sYwYVTATc-S9Vd_Kn8_qmY,37372
+finlab/dataframe.py,sha256=8dt97v-HV8wk692NSkZbXBcvaCkIlQumJuJ3EvT9Q_A,31084
 finlab/ffn_core.py,sha256=LTHkl6HVzkhUlMPqNGqEkN92ux7Q7VOXlljWIM41N0o,80750
-finlab/market_info.py,sha256=acngPwRIOrXY9XSRcjhTZST_Oi52SU6O42Qh-dLXCxI,6292
-finlab/plot.py,sha256=9zw5FatGSbRJqH5U86vlHN5-aCyCRYHDMl4k5OHXiF8,36351
-finlab/utils.py,sha256=QBax4udoR1QCRAJsMNSLPx8naekatZYLwFIgyUZn2Yk,5246
-finlab/analysis/__init__.py,sha256=Hhfp2KNKcxwDWehLKgqP51cZnnrYH5n6juZnylRT0Og,7316
+finlab/market_info.py,sha256=kaYdc7OhFcU7cdzzfD3mxsVudS6m1S1fHT8wI9I0cg4,7264
+finlab/plot.py,sha256=W6cymYzZIbEW-LSLxWnL9QbBFzW5QTPL6vUyRJLTBN4,35607
+finlab/utils.py,sha256=VBT49OmcdyOz6iHzeR9Mop4Dt2J1Xlc7Q2l-htrUkBc,5270
+finlab/analysis/__init__.py,sha256=EZGvoARsdFKq8x6vkZPSnShdcGUvoPTK4hdeufubH3w,7398
 finlab/analysis/alphaBetaAnalysis.py,sha256=ZNv3LwMlnb8JT1--AnMCUPcDPvMVHeKN0A_2oWN8k6E,2110
 finlab/analysis/drawdownAnalysis.py,sha256=B9lhGVwBkwbJCfg8ac0xVk9EoaErB1x0prmz9q7_A7s,1449
 finlab/analysis/inequalityAnalysis.py,sha256=PuE11Eloz22SSBlLURmzO9CBAx5fnEX1_qa5IKUp70Q,5007
 finlab/analysis/liquidityAnalysis.py,sha256=jWHGZPuN4Kym-1ZixQB7i4FfCsGhnMKOmnlpOno_hCc,4735
-finlab/analysis/maeMfeAnalysis.py,sha256=6XMmwqUmyzH4hm_GDzGLUVzaNonntGQAJDmo9mfXn5A,12329
-finlab/analysis/periodStatsAnalysis.py,sha256=-rlw6O4cde4OnazMCAFzsi-WDyrSGU_TYvvQRh_opCI,7481
+finlab/analysis/maeMfeAnalysis.py,sha256=xNdtMAR9YtREB2ykHaekxlZffgAJ2GHQiHnnSfRtX4Y,12357
+finlab/analysis/periodStatsAnalysis.py,sha256=p9Z5dMU8CdueRVhprO15qYEM16plMQbZSRYg5p1CkJg,7502
 finlab/core/__init__.py,sha256=frcCV1k9oG9oKj3dpUqdJg1PxRT2RSN_XKdLCPjaYaY,2
-finlab/core/aes.cp39-win_amd64.pyd,sha256=cTPoG1GQ0AnBT7FLbJLkdjML0yGPQypNM75hvO7NMD0,206336
+finlab/core/aes.cp39-win_amd64.pyd,sha256=9Q2NMcvf_hmJN8-OnK31_mwkJcIgTtTVNJJK-a28-0s,206336
 finlab/core/aes.pyx,sha256=pM0HmpHkhwrrHCO3Ttu8u30awg3afwl85FHWxEZSXNs,19593
-finlab/core/backtest_core.cp39-win_amd64.pyd,sha256=PXmumIRvTQ1HTEr2WSsvf5DdaB_a5M6hBfjsphYa7gw,134656
-finlab/core/backtest_core.pyx,sha256=ZowiXOff9zya4vbk7zJz2_xBg-0xX-9nISjCip8spsk,18552
-finlab/core/mae_mfe.cp39-win_amd64.pyd,sha256=_ID_OaaqI_igb59d-CdGk8ZiRAreXUh230EoTKRgshg,71680
+finlab/core/backtest_core.cp39-win_amd64.pyd,sha256=cMuG4okFT1TvG2G6a9GZdAOSw8r4hLHXp5pfGnk1YiE,134656
+finlab/core/backtest_core.pyx,sha256=M_XcLGyOzGJV_tjMHdPEoRavL1sCok7wy4MwJ04MGdo,18752
+finlab/core/mae_mfe.cp39-win_amd64.pyd,sha256=WMT6E0c3awlXIDviQa24TAf61rUs2Dcf1GNhugLbRZM,71680
 finlab/core/mae_mfe.pxd,sha256=QhQ5XrKji18sjmw6JX2ivD-I4amt0lhGIPgQch0MFjY,485
 finlab/core/mae_mfe.pyx,sha256=cJ8vHLggaRABKL3gYtyooCbusXjySPU3ukt76LB_Cbc,6119
-finlab/core/report.cp39-win_amd64.pyd,sha256=KZ7YfabYAl4MGKRxyuL-X348VK4gv2Qn3K8xdzkilRI,169472
-finlab/core/report.pyx,sha256=eG2oRzLTqBexZoaXmISRqvcRjTkBqDFbX3uiIsxfEno,19675
-finlab/core/utils_core.cp39-win_amd64.pyd,sha256=ukYqfjIUwM5wly58b0FkMV_RWyvO2TE0dBRdICfylN0,19968
+finlab/core/report.cp39-win_amd64.pyd,sha256=Yg0Hd3cqk1E4jy5VzU07JpvrZZrQEeSp6_dobGzPpJM,172032
+finlab/core/report.pyx,sha256=ndq2Dnuk7ZYiTpNcnaapNThPsrcarZFldvRRRZP4BPQ,19902
+finlab/core/utils_core.cp39-win_amd64.pyd,sha256=uPFOb9eX5RsPjCZuRrEImHihMWIhDmXyzlknG0B6dEQ,19968
 finlab/core/utils_core.pyx,sha256=o51-Oucjoip7tIsMle-lRryUhSHpX1afY2m-AovIQAM,88
 finlab/ml/__init__.py,sha256=oV4GCvyk_mXbfhR0cH5CzDn970EVlYhS8sSUh0KIkpY,704
-finlab/ml/alphalens.py,sha256=XUpG9So0W8q8cqfjT9FKO6AOQeX9qXMAjUGxe6fKGww,3912
+finlab/ml/alphalens.py,sha256=5vm5nP5EcXr0Y2uXGv80yOUYbMoU69-z88p1Ry7AUlE,7369
 finlab/ml/cpcv.py,sha256=Uua_tfkLTuHltAsCUsTeSKH8Jw-gnU1PJV1ddgQip6s,5160
 finlab/ml/feature.py,sha256=NGNQBW_laSGWANP0Z-_Vh-gFOfYyqyTfZkaitMog2-w,14448
 finlab/ml/label.py,sha256=8SGADra4aIl3kF7duhjDLaqpTAJasxLq5_CK4jVCvks,5180
-finlab/ml/qlib.py,sha256=7E00dP5FcDu36ELQRdsGe2zzBm0T3oSOAAGkt_0JaKM,18139
+finlab/ml/qlib.py,sha256=cWXFLVengrbwirheAT-8kE7Vp-3iOwOxFkJMgGNwqF8,18202
 finlab/ml/utils.py,sha256=UiKIfL69zREH9GrOP_MRQxUA162D9PzHRqXSEj64odI,3131
 finlab/online/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 finlab/online/base_account.py,sha256=PiIQjIgjTf6fcYtlbWevwZ_T40qvwpBjesdecvWd1ok,8155
 finlab/online/binance_account.py,sha256=bxTsx1sI1BDnx1OKWAxTvWm96-BGsWCrxQNOHszJ1Xg,12766
 finlab/online/dashboard.py,sha256=hhLoQDgytda4xW_wOLb3rlOO_j_W5aILlwjNrKwX2QI,7264
 finlab/online/enums.py,sha256=7X5VmoaffdVDFNiRF-EIeRBtroGmLGEryVlxLmurWro,263
-finlab/online/fugle_account.py,sha256=Dvk6TA6FLWFXDWnY3034kG1n8BLu0dcepo-jUw0RJNA,12844
-finlab/online/order_executor.py,sha256=D4n_4SqtzySZEaC21OC0T4FBK0oQRYpncUxYsA8aCIM,17131
+finlab/online/fugle_account.py,sha256=m3Xqmo4DpJLzL3oiCtsvVEttBmAUk-u7O_YrZnspIZI,14064
+finlab/online/order_executor.py,sha256=a1TJUvaMOL3Vk5SnpXYm7MvoW9WAPHrK5HjgVat-pHo,18092
 finlab/online/panel.py,sha256=pL7vHsZfmNYI0LqZN-2amZgPXyViznUqNCzQTZVz170,13122
-finlab/online/sinopac_account.py,sha256=BxXO8UmjQvReBMGMXZQHsaD8fHurWOunicaY4juceQw,8674
-finlab/online/test.py,sha256=aJpQ_j8RAhPrbC4JkuuXoHaOWrkzxKZOcIkbPaO0uRM,3158
+finlab/online/sinopac_account.py,sha256=YZ0az64PfdVxQWkNTZt_GJ4CY44pIJF3HN9DclrYXUM,10011
+finlab/online/test.py,sha256=dUV-d7U2fPRNiRpNPfMe10HyJiKRNnDru3a3LdC7ldQ,5260
 finlab/online/utils.py,sha256=Yv_wf_icMkmKTOOSNqjK7jIbue53ZhfR--xOyFhftns,5303
 finlab/optimize/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
-finlab/optimize/combinations.py,sha256=8tONNTmeXAoay4xPNhKSjJuvec6ikSIjUrqkuBd8KU4,9160
-finlab-0.4.4.dist-info/LICENSE,sha256=IwGE9guuL-ryRPEKi6wFPI_zOhg7zDZbTYuHbSt_SAk,35823
-finlab-0.4.4.dist-info/METADATA,sha256=wJSYXBNbu0XTSv79KJOQEU_1mirN9_2ThwVmElohzZU,3879
-finlab-0.4.4.dist-info/WHEEL,sha256=eep6QWEFiQfg2wcclssb_WY-D33AnLYLnEKGA9Rn-VU,100
-finlab-0.4.4.dist-info/top_level.txt,sha256=m5gMT8MS1RxoL-WPzxP83LozK_ubRB3AN7d9shpXNIQ,7
-finlab-0.4.4.dist-info/RECORD,,
+finlab/optimize/combinations.py,sha256=yrj4il4rH_NBQSUGVwuIMQERzyRDod7ukEN6tT5fWf0,9542
+finlab-0.4.5.dist-info/LICENSE,sha256=IwGE9guuL-ryRPEKi6wFPI_zOhg7zDZbTYuHbSt_SAk,35823
+finlab-0.4.5.dist-info/METADATA,sha256=gQrDAyN-irg_0VIEFtsrVAg3d0VVhMgiD2N_BxMcnHg,6068
+finlab-0.4.5.dist-info/WHEEL,sha256=eep6QWEFiQfg2wcclssb_WY-D33AnLYLnEKGA9Rn-VU,100
+finlab-0.4.5.dist-info/top_level.txt,sha256=m5gMT8MS1RxoL-WPzxP83LozK_ubRB3AN7d9shpXNIQ,7
+finlab-0.4.5.dist-info/RECORD,,
```

