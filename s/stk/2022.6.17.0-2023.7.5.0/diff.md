# Comparing `tmp/stk-2022.6.17.0.tar.gz` & `tmp/stk-2023.7.5.0.tar.gz`

## filetype from file(1)

```diff
@@ -1 +1 @@
-gzip compressed data, was "stk-2022.6.17.0.tar", last modified: Fri Jun 17 11:10:33 2022, max compression
+gzip compressed data, was "stk-2023.7.5.0.tar", last modified: Wed Jul  5 15:50:04 2023, max compression
```

## Comparing `stk-2022.6.17.0.tar` & `stk-2023.7.5.0.tar`

### file list

```diff
@@ -1,400 +1,341 @@
-drwxr-xr-x   0 root         (0) root         (0)        0 2022-06-17 11:10:33.590122 stk-2022.6.17.0/
--rw-r--r--   0 root         (0) root         (0)      188 2022-06-17 11:10:33.590122 stk-2022.6.17.0/PKG-INFO
--rw-r--r--   0 root         (0) root         (0)     4814 2022-06-17 11:10:18.000000 stk-2022.6.17.0/README.rst
--rw-r--r--   0 root         (0) root         (0)       38 2022-06-17 11:10:33.590122 stk-2022.6.17.0/setup.cfg
--rw-r--r--   0 root         (0) root         (0)      871 2022-06-17 11:10:18.000000 stk-2022.6.17.0/setup.py
-drwxr-xr-x   0 root         (0) root         (0)        0 2022-06-17 11:10:33.526121 stk-2022.6.17.0/src/
-drwxr-xr-x   0 root         (0) root         (0)        0 2022-06-17 11:10:33.534122 stk-2022.6.17.0/src/stk/
--rw-r--r--   0 root         (0) root         (0)      191 2022-06-17 11:10:18.000000 stk-2022.6.17.0/src/stk/__init__.py
-drwxr-xr-x   0 root         (0) root         (0)        0 2022-06-17 11:10:33.538122 stk-2022.6.17.0/src/stk/databases/
--rw-r--r--   0 root         (0) root         (0)      137 2022-06-17 11:10:18.000000 stk-2022.6.17.0/src/stk/databases/__init__.py
--rw-r--r--   0 root         (0) root         (0)     1773 2022-06-17 11:10:18.000000 stk-2022.6.17.0/src/stk/databases/constructed_molecule.py
--rw-r--r--   0 root         (0) root         (0)     1881 2022-06-17 11:10:18.000000 stk-2022.6.17.0/src/stk/databases/molecule.py
-drwxr-xr-x   0 root         (0) root         (0)        0 2022-06-17 11:10:33.538122 stk-2022.6.17.0/src/stk/databases/mongo_db/
--rw-r--r--   0 root         (0) root         (0)      105 2022-06-17 11:10:18.000000 stk-2022.6.17.0/src/stk/databases/mongo_db/__init__.py
--rw-r--r--   0 root         (0) root         (0)    27781 2022-06-17 11:10:18.000000 stk-2022.6.17.0/src/stk/databases/mongo_db/constructed_molecule.py
--rw-r--r--   0 root         (0) root         (0)    17931 2022-06-17 11:10:18.000000 stk-2022.6.17.0/src/stk/databases/mongo_db/molecule.py
--rw-r--r--   0 root         (0) root         (0)     1327 2022-06-17 11:10:18.000000 stk-2022.6.17.0/src/stk/databases/mongo_db/utilities.py
--rw-r--r--   0 root         (0) root         (0)     6571 2022-06-17 11:10:18.000000 stk-2022.6.17.0/src/stk/databases/mongo_db/value.py
--rw-r--r--   0 root         (0) root         (0)     3780 2022-06-17 11:10:18.000000 stk-2022.6.17.0/src/stk/databases/value.py
-drwxr-xr-x   0 root         (0) root         (0)        0 2022-06-17 11:10:33.538122 stk-2022.6.17.0/src/stk/ea/
--rw-r--r--   0 root         (0) root         (0)      336 2022-06-17 11:10:18.000000 stk-2022.6.17.0/src/stk/ea/__init__.py
-drwxr-xr-x   0 root         (0) root         (0)        0 2022-06-17 11:10:33.538122 stk-2022.6.17.0/src/stk/ea/crossover/
--rw-r--r--   0 root         (0) root         (0)       63 2022-06-17 11:10:18.000000 stk-2022.6.17.0/src/stk/ea/crossover/__init__.py
-drwxr-xr-x   0 root         (0) root         (0)        0 2022-06-17 11:10:33.538122 stk-2022.6.17.0/src/stk/ea/crossover/crossers/
--rw-r--r--   0 root         (0) root         (0)       64 2022-06-17 11:10:18.000000 stk-2022.6.17.0/src/stk/ea/crossover/crossers/__init__.py
-drwxr-xr-x   0 root         (0) root         (0)        0 2022-06-17 11:10:33.538122 stk-2022.6.17.0/src/stk/ea/crossover/crossers/compound/
--rw-r--r--   0 root         (0) root         (0)       30 2022-06-17 11:10:18.000000 stk-2022.6.17.0/src/stk/ea/crossover/crossers/compound/__init__.py
--rw-r--r--   0 root         (0) root         (0)     6740 2022-06-17 11:10:18.000000 stk-2022.6.17.0/src/stk/ea/crossover/crossers/compound/random.py
-drwxr-xr-x   0 root         (0) root         (0)        0 2022-06-17 11:10:33.538122 stk-2022.6.17.0/src/stk/ea/crossover/crossers/molecule/
--rw-r--r--   0 root         (0) root         (0)       76 2022-06-17 11:10:18.000000 stk-2022.6.17.0/src/stk/ea/crossover/crossers/molecule/__init__.py
--rw-r--r--   0 root         (0) root         (0)      977 2022-06-17 11:10:18.000000 stk-2022.6.17.0/src/stk/ea/crossover/crossers/molecule/crosser.py
--rw-r--r--   0 root         (0) root         (0)     8527 2022-06-17 11:10:18.000000 stk-2022.6.17.0/src/stk/ea/crossover/crossers/molecule/genetic_recombination.py
-drwxr-xr-x   0 root         (0) root         (0)        0 2022-06-17 11:10:33.538122 stk-2022.6.17.0/src/stk/ea/crossover/records/
--rw-r--r--   0 root         (0) root         (0)       30 2022-06-17 11:10:18.000000 stk-2022.6.17.0/src/stk/ea/crossover/records/__init__.py
--rw-r--r--   0 root         (0) root         (0)     1445 2022-06-17 11:10:18.000000 stk-2022.6.17.0/src/stk/ea/crossover/records/record.py
-drwxr-xr-x   0 root         (0) root         (0)        0 2022-06-17 11:10:33.538122 stk-2022.6.17.0/src/stk/ea/evolutionary_algorithm/
--rw-r--r--   0 root         (0) root         (0)       66 2022-06-17 11:10:18.000000 stk-2022.6.17.0/src/stk/ea/evolutionary_algorithm/__init__.py
--rw-r--r--   0 root         (0) root         (0)     4675 2022-06-17 11:10:18.000000 stk-2022.6.17.0/src/stk/ea/evolutionary_algorithm/evolutionary_algorithm.py
-drwxr-xr-x   0 root         (0) root         (0)        0 2022-06-17 11:10:33.538122 stk-2022.6.17.0/src/stk/ea/evolutionary_algorithm/implementations/
--rw-r--r--   0 root         (0) root         (0)       74 2022-06-17 11:10:18.000000 stk-2022.6.17.0/src/stk/ea/evolutionary_algorithm/implementations/__init__.py
--rw-r--r--   0 root         (0) root         (0)     4198 2022-06-17 11:10:18.000000 stk-2022.6.17.0/src/stk/ea/evolutionary_algorithm/implementations/implementation.py
--rw-r--r--   0 root         (0) root         (0)     1246 2022-06-17 11:10:18.000000 stk-2022.6.17.0/src/stk/ea/evolutionary_algorithm/implementations/parallel.py
--rw-r--r--   0 root         (0) root         (0)      341 2022-06-17 11:10:18.000000 stk-2022.6.17.0/src/stk/ea/evolutionary_algorithm/implementations/serial.py
-drwxr-xr-x   0 root         (0) root         (0)        0 2022-06-17 11:10:33.542122 stk-2022.6.17.0/src/stk/ea/fitness_calculators/
--rw-r--r--   0 root         (0) root         (0)      121 2022-06-17 11:10:18.000000 stk-2022.6.17.0/src/stk/ea/fitness_calculators/__init__.py
--rw-r--r--   0 root         (0) root         (0)      949 2022-06-17 11:10:18.000000 stk-2022.6.17.0/src/stk/ea/fitness_calculators/fitness_calculator.py
--rw-r--r--   0 root         (0) root         (0)     8325 2022-06-17 11:10:18.000000 stk-2022.6.17.0/src/stk/ea/fitness_calculators/fitness_function.py
--rw-r--r--   0 root         (0) root         (0)     9814 2022-06-17 11:10:18.000000 stk-2022.6.17.0/src/stk/ea/fitness_calculators/property_vector.py
-drwxr-xr-x   0 root         (0) root         (0)        0 2022-06-17 11:10:33.542122 stk-2022.6.17.0/src/stk/ea/fitness_normalizers/
--rw-r--r--   0 root         (0) root         (0)      284 2022-06-17 11:10:18.000000 stk-2022.6.17.0/src/stk/ea/fitness_normalizers/__init__.py
--rw-r--r--   0 root         (0) root         (0)     5818 2022-06-17 11:10:18.000000 stk-2022.6.17.0/src/stk/ea/fitness_normalizers/add.py
--rw-r--r--   0 root         (0) root         (0)     5033 2022-06-17 11:10:18.000000 stk-2022.6.17.0/src/stk/ea/fitness_normalizers/divide_by_mean.py
--rw-r--r--   0 root         (0) root         (0)     1569 2022-06-17 11:10:18.000000 stk-2022.6.17.0/src/stk/ea/fitness_normalizers/fitness_normalizer.py
--rw-r--r--   0 root         (0) root         (0)     6010 2022-06-17 11:10:18.000000 stk-2022.6.17.0/src/stk/ea/fitness_normalizers/multiply.py
--rw-r--r--   0 root         (0) root         (0)      367 2022-06-17 11:10:18.000000 stk-2022.6.17.0/src/stk/ea/fitness_normalizers/null.py
--rw-r--r--   0 root         (0) root         (0)     7166 2022-06-17 11:10:18.000000 stk-2022.6.17.0/src/stk/ea/fitness_normalizers/power.py
--rw-r--r--   0 root         (0) root         (0)     4105 2022-06-17 11:10:18.000000 stk-2022.6.17.0/src/stk/ea/fitness_normalizers/replace_fitness.py
--rw-r--r--   0 root         (0) root         (0)     2004 2022-06-17 11:10:18.000000 stk-2022.6.17.0/src/stk/ea/fitness_normalizers/sequence.py
--rw-r--r--   0 root         (0) root         (0)     7039 2022-06-17 11:10:18.000000 stk-2022.6.17.0/src/stk/ea/fitness_normalizers/shift_up.py
--rw-r--r--   0 root         (0) root         (0)     4455 2022-06-17 11:10:18.000000 stk-2022.6.17.0/src/stk/ea/fitness_normalizers/sum.py
--rw-r--r--   0 root         (0) root         (0)     1968 2022-06-17 11:10:18.000000 stk-2022.6.17.0/src/stk/ea/generation.py
-drwxr-xr-x   0 root         (0) root         (0)        0 2022-06-17 11:10:33.542122 stk-2022.6.17.0/src/stk/ea/molecule_records/
--rw-r--r--   0 root         (0) root         (0)       32 2022-06-17 11:10:18.000000 stk-2022.6.17.0/src/stk/ea/molecule_records/__init__.py
--rw-r--r--   0 root         (0) root         (0)     3745 2022-06-17 11:10:18.000000 stk-2022.6.17.0/src/stk/ea/molecule_records/molecule.py
-drwxr-xr-x   0 root         (0) root         (0)        0 2022-06-17 11:10:33.542122 stk-2022.6.17.0/src/stk/ea/mutation/
--rw-r--r--   0 root         (0) root         (0)       63 2022-06-17 11:10:18.000000 stk-2022.6.17.0/src/stk/ea/mutation/__init__.py
-drwxr-xr-x   0 root         (0) root         (0)        0 2022-06-17 11:10:33.542122 stk-2022.6.17.0/src/stk/ea/mutation/mutators/
--rw-r--r--   0 root         (0) root         (0)       64 2022-06-17 11:10:18.000000 stk-2022.6.17.0/src/stk/ea/mutation/mutators/__init__.py
-drwxr-xr-x   0 root         (0) root         (0)        0 2022-06-17 11:10:33.542122 stk-2022.6.17.0/src/stk/ea/mutation/mutators/compound/
--rw-r--r--   0 root         (0) root         (0)       42 2022-06-17 11:10:18.000000 stk-2022.6.17.0/src/stk/ea/mutation/mutators/compound/__init__.py
--rw-r--r--   0 root         (0) root         (0)     4837 2022-06-17 11:10:18.000000 stk-2022.6.17.0/src/stk/ea/mutation/mutators/compound/random.py
-drwxr-xr-x   0 root         (0) root         (0)        0 2022-06-17 11:10:33.542122 stk-2022.6.17.0/src/stk/ea/mutation/mutators/molecule/
--rw-r--r--   0 root         (0) root         (0)      167 2022-06-17 11:10:18.000000 stk-2022.6.17.0/src/stk/ea/mutation/mutators/molecule/__init__.py
--rw-r--r--   0 root         (0) root         (0)     1068 2022-06-17 11:10:18.000000 stk-2022.6.17.0/src/stk/ea/mutation/mutators/molecule/mutator.py
--rw-r--r--   0 root         (0) root         (0)     3920 2022-06-17 11:10:18.000000 stk-2022.6.17.0/src/stk/ea/mutation/mutators/molecule/random_building_block.py
--rw-r--r--   0 root         (0) root         (0)     2617 2022-06-17 11:10:18.000000 stk-2022.6.17.0/src/stk/ea/mutation/mutators/molecule/random_topology_graph.py
--rw-r--r--   0 root         (0) root         (0)     6456 2022-06-17 11:10:18.000000 stk-2022.6.17.0/src/stk/ea/mutation/mutators/molecule/similar_building_block.py
-drwxr-xr-x   0 root         (0) root         (0)        0 2022-06-17 11:10:33.542122 stk-2022.6.17.0/src/stk/ea/mutation/records/
--rw-r--r--   0 root         (0) root         (0)       30 2022-06-17 11:10:18.000000 stk-2022.6.17.0/src/stk/ea/mutation/records/__init__.py
--rw-r--r--   0 root         (0) root         (0)     1452 2022-06-17 11:10:18.000000 stk-2022.6.17.0/src/stk/ea/mutation/records/record.py
-drwxr-xr-x   0 root         (0) root         (0)        0 2022-06-17 11:10:33.546121 stk-2022.6.17.0/src/stk/ea/plotters/
--rw-r--r--   0 root         (0) root         (0)      309 2022-06-17 11:10:18.000000 stk-2022.6.17.0/src/stk/ea/plotters/__init__.py
--rw-r--r--   0 root         (0) root         (0)    12951 2022-06-17 11:10:18.000000 stk-2022.6.17.0/src/stk/ea/plotters/progress.py
--rw-r--r--   0 root         (0) root         (0)     7608 2022-06-17 11:10:18.000000 stk-2022.6.17.0/src/stk/ea/plotters/selection.py
-drwxr-xr-x   0 root         (0) root         (0)        0 2022-06-17 11:10:33.546121 stk-2022.6.17.0/src/stk/ea/selection/
--rw-r--r--   0 root         (0) root         (0)       62 2022-06-17 11:10:18.000000 stk-2022.6.17.0/src/stk/ea/selection/__init__.py
--rw-r--r--   0 root         (0) root         (0)     7886 2022-06-17 11:10:18.000000 stk-2022.6.17.0/src/stk/ea/selection/batch.py
-drwxr-xr-x   0 root         (0) root         (0)        0 2022-06-17 11:10:33.546121 stk-2022.6.17.0/src/stk/ea/selection/selectors/
--rw-r--r--   0 root         (0) root         (0)      401 2022-06-17 11:10:18.000000 stk-2022.6.17.0/src/stk/ea/selection/selectors/__init__.py
--rw-r--r--   0 root         (0) root         (0)     6571 2022-06-17 11:10:18.000000 stk-2022.6.17.0/src/stk/ea/selection/selectors/above_average.py
--rw-r--r--   0 root         (0) root         (0)     5566 2022-06-17 11:10:18.000000 stk-2022.6.17.0/src/stk/ea/selection/selectors/best.py
--rw-r--r--   0 root         (0) root         (0)     2397 2022-06-17 11:10:18.000000 stk-2022.6.17.0/src/stk/ea/selection/selectors/filter_batches.py
--rw-r--r--   0 root         (0) root         (0)     2565 2022-06-17 11:10:18.000000 stk-2022.6.17.0/src/stk/ea/selection/selectors/filter_molecules.py
--rw-r--r--   0 root         (0) root         (0)     2423 2022-06-17 11:10:18.000000 stk-2022.6.17.0/src/stk/ea/selection/selectors/remove_batches.py
--rw-r--r--   0 root         (0) root         (0)     2675 2022-06-17 11:10:18.000000 stk-2022.6.17.0/src/stk/ea/selection/selectors/remove_molecules.py
--rw-r--r--   0 root         (0) root         (0)     5770 2022-06-17 11:10:18.000000 stk-2022.6.17.0/src/stk/ea/selection/selectors/roulette.py
--rw-r--r--   0 root         (0) root         (0)     7684 2022-06-17 11:10:18.000000 stk-2022.6.17.0/src/stk/ea/selection/selectors/selector.py
--rw-r--r--   0 root         (0) root         (0)     7010 2022-06-17 11:10:18.000000 stk-2022.6.17.0/src/stk/ea/selection/selectors/stochastic_universal_sampling.py
--rw-r--r--   0 root         (0) root         (0)     4792 2022-06-17 11:10:18.000000 stk-2022.6.17.0/src/stk/ea/selection/selectors/tournament.py
-drwxr-xr-x   0 root         (0) root         (0)        0 2022-06-17 11:10:33.546121 stk-2022.6.17.0/src/stk/ea/selection/selectors/utilities/
--rw-r--r--   0 root         (0) root         (0)       39 2022-06-17 11:10:18.000000 stk-2022.6.17.0/src/stk/ea/selection/selectors/utilities/__init__.py
--rw-r--r--   0 root         (0) root         (0)     3300 2022-06-17 11:10:18.000000 stk-2022.6.17.0/src/stk/ea/selection/selectors/utilities/yielded_batches.py
--rw-r--r--   0 root         (0) root         (0)     3584 2022-06-17 11:10:18.000000 stk-2022.6.17.0/src/stk/ea/selection/selectors/worst.py
-drwxr-xr-x   0 root         (0) root         (0)        0 2022-06-17 11:10:33.546121 stk-2022.6.17.0/src/stk/molecular/
--rw-r--r--   0 root         (0) root         (0)      306 2022-06-17 11:10:18.000000 stk-2022.6.17.0/src/stk/molecular/__init__.py
-drwxr-xr-x   0 root         (0) root         (0)        0 2022-06-17 11:10:33.546121 stk-2022.6.17.0/src/stk/molecular/atoms/
--rw-r--r--   0 root         (0) root         (0)       93 2022-06-17 11:10:18.000000 stk-2022.6.17.0/src/stk/molecular/atoms/__init__.py
--rw-r--r--   0 root         (0) root         (0)     2835 2022-06-17 11:10:18.000000 stk-2022.6.17.0/src/stk/molecular/atoms/atom.py
--rw-r--r--   0 root         (0) root         (0)     3453 2022-06-17 11:10:18.000000 stk-2022.6.17.0/src/stk/molecular/atoms/atom_info.py
--rw-r--r--   0 root         (0) root         (0)    25510 2022-06-17 11:10:18.000000 stk-2022.6.17.0/src/stk/molecular/atoms/elements.py
-drwxr-xr-x   0 root         (0) root         (0)        0 2022-06-17 11:10:33.550122 stk-2022.6.17.0/src/stk/molecular/bonds/
--rw-r--r--   0 root         (0) root         (0)       61 2022-06-17 11:10:18.000000 stk-2022.6.17.0/src/stk/molecular/bonds/__init__.py
--rw-r--r--   0 root         (0) root         (0)     5674 2022-06-17 11:10:18.000000 stk-2022.6.17.0/src/stk/molecular/bonds/bond.py
--rw-r--r--   0 root         (0) root         (0)     2649 2022-06-17 11:10:18.000000 stk-2022.6.17.0/src/stk/molecular/bonds/bond_info.py
-drwxr-xr-x   0 root         (0) root         (0)        0 2022-06-17 11:10:33.550122 stk-2022.6.17.0/src/stk/molecular/functional_groups/
--rw-r--r--   0 root         (0) root         (0)       74 2022-06-17 11:10:18.000000 stk-2022.6.17.0/src/stk/molecular/functional_groups/__init__.py
-drwxr-xr-x   0 root         (0) root         (0)        0 2022-06-17 11:10:33.554122 stk-2022.6.17.0/src/stk/molecular/functional_groups/factories/
--rw-r--r--   0 root         (0) root         (0)      841 2022-06-17 11:10:18.000000 stk-2022.6.17.0/src/stk/molecular/functional_groups/factories/__init__.py
--rw-r--r--   0 root         (0) root         (0)     4397 2022-06-17 11:10:18.000000 stk-2022.6.17.0/src/stk/molecular/functional_groups/factories/alcohol_factory.py
--rw-r--r--   0 root         (0) root         (0)     4270 2022-06-17 11:10:18.000000 stk-2022.6.17.0/src/stk/molecular/functional_groups/factories/aldehyde_factory.py
--rw-r--r--   0 root         (0) root         (0)     4380 2022-06-17 11:10:18.000000 stk-2022.6.17.0/src/stk/molecular/functional_groups/factories/amide_factory.py
--rw-r--r--   0 root         (0) root         (0)     4520 2022-06-17 11:10:18.000000 stk-2022.6.17.0/src/stk/molecular/functional_groups/factories/boronic_acid_factory.py
--rw-r--r--   0 root         (0) root         (0)     2595 2022-06-17 11:10:18.000000 stk-2022.6.17.0/src/stk/molecular/functional_groups/factories/bromo_factory.py
--rw-r--r--   0 root         (0) root         (0)     4419 2022-06-17 11:10:18.000000 stk-2022.6.17.0/src/stk/molecular/functional_groups/factories/carboxylic_acid_factory.py
--rw-r--r--   0 root         (0) root         (0)     4172 2022-06-17 11:10:18.000000 stk-2022.6.17.0/src/stk/molecular/functional_groups/factories/dibromo_factory.py
--rw-r--r--   0 root         (0) root         (0)     4188 2022-06-17 11:10:18.000000 stk-2022.6.17.0/src/stk/molecular/functional_groups/factories/difluoro_factory.py
--rw-r--r--   0 root         (0) root         (0)     4307 2022-06-17 11:10:18.000000 stk-2022.6.17.0/src/stk/molecular/functional_groups/factories/diol_factory.py
--rw-r--r--   0 root         (0) root         (0)     2625 2022-06-17 11:10:18.000000 stk-2022.6.17.0/src/stk/molecular/functional_groups/factories/fluoro_factory.py
--rw-r--r--   0 root         (0) root         (0)     4889 2022-06-17 11:10:18.000000 stk-2022.6.17.0/src/stk/molecular/functional_groups/factories/functional_group_factory.py
--rw-r--r--   0 root         (0) root         (0)     2599 2022-06-17 11:10:18.000000 stk-2022.6.17.0/src/stk/molecular/functional_groups/factories/iodo_factory.py
--rw-r--r--   0 root         (0) root         (0)     4489 2022-06-17 11:10:18.000000 stk-2022.6.17.0/src/stk/molecular/functional_groups/factories/primary_amino_factory.py
--rw-r--r--   0 root         (0) root         (0)     1215 2022-06-17 11:10:18.000000 stk-2022.6.17.0/src/stk/molecular/functional_groups/factories/ring_amine_factory.py
--rw-r--r--   0 root         (0) root         (0)     4297 2022-06-17 11:10:18.000000 stk-2022.6.17.0/src/stk/molecular/functional_groups/factories/secondary_amino_factory.py
--rw-r--r--   0 root         (0) root         (0)     3297 2022-06-17 11:10:18.000000 stk-2022.6.17.0/src/stk/molecular/functional_groups/factories/smarts_functional_group_factory.py
--rw-r--r--   0 root         (0) root         (0)     4373 2022-06-17 11:10:18.000000 stk-2022.6.17.0/src/stk/molecular/functional_groups/factories/terminal_alkene_factory.py
--rw-r--r--   0 root         (0) root         (0)     4048 2022-06-17 11:10:18.000000 stk-2022.6.17.0/src/stk/molecular/functional_groups/factories/terminal_alkyne_factory.py
--rw-r--r--   0 root         (0) root         (0)     4120 2022-06-17 11:10:18.000000 stk-2022.6.17.0/src/stk/molecular/functional_groups/factories/thioacid_factory.py
--rw-r--r--   0 root         (0) root         (0)     4282 2022-06-17 11:10:18.000000 stk-2022.6.17.0/src/stk/molecular/functional_groups/factories/thiol_factory.py
--rw-r--r--   0 root         (0) root         (0)      814 2022-06-17 11:10:18.000000 stk-2022.6.17.0/src/stk/molecular/functional_groups/factories/utilities.py
-drwxr-xr-x   0 root         (0) root         (0)        0 2022-06-17 11:10:33.558122 stk-2022.6.17.0/src/stk/molecular/functional_groups/functional_groups/
--rw-r--r--   0 root         (0) root         (0)      699 2022-06-17 11:10:18.000000 stk-2022.6.17.0/src/stk/molecular/functional_groups/functional_groups/__init__.py
--rw-r--r--   0 root         (0) root         (0)     3181 2022-06-17 11:10:18.000000 stk-2022.6.17.0/src/stk/molecular/functional_groups/functional_groups/alcohol.py
--rw-r--r--   0 root         (0) root         (0)     3687 2022-06-17 11:10:18.000000 stk-2022.6.17.0/src/stk/molecular/functional_groups/functional_groups/aldehyde.py
--rw-r--r--   0 root         (0) root         (0)     4462 2022-06-17 11:10:18.000000 stk-2022.6.17.0/src/stk/molecular/functional_groups/functional_groups/alkene.py
--rw-r--r--   0 root         (0) root         (0)     3538 2022-06-17 11:10:18.000000 stk-2022.6.17.0/src/stk/molecular/functional_groups/functional_groups/alkyne.py
--rw-r--r--   0 root         (0) root         (0)     4771 2022-06-17 11:10:18.000000 stk-2022.6.17.0/src/stk/molecular/functional_groups/functional_groups/amide.py
--rw-r--r--   0 root         (0) root         (0)     4825 2022-06-17 11:10:18.000000 stk-2022.6.17.0/src/stk/molecular/functional_groups/functional_groups/boronic_acid.py
--rw-r--r--   0 root         (0) root         (0)     2501 2022-06-17 11:10:18.000000 stk-2022.6.17.0/src/stk/molecular/functional_groups/functional_groups/bromo.py
--rw-r--r--   0 root         (0) root         (0)     3865 2022-06-17 11:10:18.000000 stk-2022.6.17.0/src/stk/molecular/functional_groups/functional_groups/carboxylic_acid.py
--rw-r--r--   0 root         (0) root         (0)     3348 2022-06-17 11:10:18.000000 stk-2022.6.17.0/src/stk/molecular/functional_groups/functional_groups/dibromo.py
--rw-r--r--   0 root         (0) root         (0)     3218 2022-06-17 11:10:18.000000 stk-2022.6.17.0/src/stk/molecular/functional_groups/functional_groups/difluoro.py
--rw-r--r--   0 root         (0) root         (0)     4406 2022-06-17 11:10:18.000000 stk-2022.6.17.0/src/stk/molecular/functional_groups/functional_groups/diol.py
--rw-r--r--   0 root         (0) root         (0)     2298 2022-06-17 11:10:18.000000 stk-2022.6.17.0/src/stk/molecular/functional_groups/functional_groups/fluoro.py
--rw-r--r--   0 root         (0) root         (0)    13809 2022-06-17 11:10:18.000000 stk-2022.6.17.0/src/stk/molecular/functional_groups/functional_groups/functional_group.py
--rw-r--r--   0 root         (0) root         (0)     4868 2022-06-17 11:10:18.000000 stk-2022.6.17.0/src/stk/molecular/functional_groups/functional_groups/generic_functional_group.py
--rw-r--r--   0 root         (0) root         (0)     2200 2022-06-17 11:10:18.000000 stk-2022.6.17.0/src/stk/molecular/functional_groups/functional_groups/iodo.py
--rw-r--r--   0 root         (0) root         (0)     3453 2022-06-17 11:10:18.000000 stk-2022.6.17.0/src/stk/molecular/functional_groups/functional_groups/primary_amino.py
--rw-r--r--   0 root         (0) root         (0)     4657 2022-06-17 11:10:18.000000 stk-2022.6.17.0/src/stk/molecular/functional_groups/functional_groups/ring_amine.py
--rw-r--r--   0 root         (0) root         (0)     3382 2022-06-17 11:10:18.000000 stk-2022.6.17.0/src/stk/molecular/functional_groups/functional_groups/secondary_amino.py
--rw-r--r--   0 root         (0) root         (0)     1249 2022-06-17 11:10:18.000000 stk-2022.6.17.0/src/stk/molecular/functional_groups/functional_groups/single_atom.py
--rw-r--r--   0 root         (0) root         (0)     3818 2022-06-17 11:10:18.000000 stk-2022.6.17.0/src/stk/molecular/functional_groups/functional_groups/thioacid.py
--rw-r--r--   0 root         (0) root         (0)     2787 2022-06-17 11:10:18.000000 stk-2022.6.17.0/src/stk/molecular/functional_groups/functional_groups/thiol.py
-drwxr-xr-x   0 root         (0) root         (0)        0 2022-06-17 11:10:33.558122 stk-2022.6.17.0/src/stk/molecular/key_makers/
--rw-r--r--   0 root         (0) root         (0)      124 2022-06-17 11:10:18.000000 stk-2022.6.17.0/src/stk/molecular/key_makers/__init__.py
--rw-r--r--   0 root         (0) root         (0)     1643 2022-06-17 11:10:18.000000 stk-2022.6.17.0/src/stk/molecular/key_makers/inchi.py
--rw-r--r--   0 root         (0) root         (0)     1473 2022-06-17 11:10:18.000000 stk-2022.6.17.0/src/stk/molecular/key_makers/inchi_key.py
--rw-r--r--   0 root         (0) root         (0)     3355 2022-06-17 11:10:18.000000 stk-2022.6.17.0/src/stk/molecular/key_makers/molecule.py
--rw-r--r--   0 root         (0) root         (0)     1323 2022-06-17 11:10:18.000000 stk-2022.6.17.0/src/stk/molecular/key_makers/smiles.py
--rw-r--r--   0 root         (0) root         (0)     1666 2022-06-17 11:10:18.000000 stk-2022.6.17.0/src/stk/molecular/key_makers/utilities.py
-drwxr-xr-x   0 root         (0) root         (0)        0 2022-06-17 11:10:33.558122 stk-2022.6.17.0/src/stk/molecular/molecules/
--rw-r--r--   0 root         (0) root         (0)      114 2022-06-17 11:10:18.000000 stk-2022.6.17.0/src/stk/molecular/molecules/__init__.py
--rw-r--r--   0 root         (0) root         (0)    33513 2022-06-17 11:10:18.000000 stk-2022.6.17.0/src/stk/molecular/molecules/building_block.py
--rw-r--r--   0 root         (0) root         (0)    14187 2022-06-17 11:10:18.000000 stk-2022.6.17.0/src/stk/molecular/molecules/constructed_molecule.py
-drwxr-xr-x   0 root         (0) root         (0)        0 2022-06-17 11:10:33.558122 stk-2022.6.17.0/src/stk/molecular/molecules/molecule/
--rw-r--r--   0 root         (0) root         (0)       32 2022-06-17 11:10:18.000000 stk-2022.6.17.0/src/stk/molecular/molecules/molecule/__init__.py
--rw-r--r--   0 root         (0) root         (0)    25952 2022-06-17 11:10:18.000000 stk-2022.6.17.0/src/stk/molecular/molecules/molecule/molecule.py
-drwxr-xr-x   0 root         (0) root         (0)        0 2022-06-17 11:10:33.558122 stk-2022.6.17.0/src/stk/molecular/molecules/molecule/utilities/
--rw-r--r--   0 root         (0) root         (0)       61 2022-06-17 11:10:18.000000 stk-2022.6.17.0/src/stk/molecular/molecules/molecule/utilities/__init__.py
-drwxr-xr-x   0 root         (0) root         (0)        0 2022-06-17 11:10:33.562121 stk-2022.6.17.0/src/stk/molecular/molecules/molecule/utilities/updaters/
--rw-r--r--   0 root         (0) root         (0)      266 2022-06-17 11:10:18.000000 stk-2022.6.17.0/src/stk/molecular/molecules/molecule/utilities/updaters/__init__.py
--rw-r--r--   0 root         (0) root         (0)      578 2022-06-17 11:10:18.000000 stk-2022.6.17.0/src/stk/molecular/molecules/molecule/utilities/updaters/mae.py
--rw-r--r--   0 root         (0) root         (0)      725 2022-06-17 11:10:18.000000 stk-2022.6.17.0/src/stk/molecular/molecules/molecule/utilities/updaters/mdl_mol.py
--rw-r--r--   0 root         (0) root         (0)      717 2022-06-17 11:10:18.000000 stk-2022.6.17.0/src/stk/molecular/molecules/molecule/utilities/updaters/pdb.py
--rw-r--r--   0 root         (0) root         (0)     5691 2022-06-17 11:10:18.000000 stk-2022.6.17.0/src/stk/molecular/molecules/molecule/utilities/updaters/turbomole.py
--rw-r--r--   0 root         (0) root         (0)     2094 2022-06-17 11:10:18.000000 stk-2022.6.17.0/src/stk/molecular/molecules/molecule/utilities/updaters/xyz.py
-drwxr-xr-x   0 root         (0) root         (0)        0 2022-06-17 11:10:33.562121 stk-2022.6.17.0/src/stk/molecular/molecules/molecule/utilities/writers/
--rw-r--r--   0 root         (0) root         (0)      131 2022-06-17 11:10:18.000000 stk-2022.6.17.0/src/stk/molecular/molecules/molecule/utilities/writers/__init__.py
--rw-r--r--   0 root         (0) root         (0)     2730 2022-06-17 11:10:18.000000 stk-2022.6.17.0/src/stk/molecular/molecules/molecule/utilities/writers/mdl_mol.py
--rw-r--r--   0 root         (0) root         (0)     2094 2022-06-17 11:10:18.000000 stk-2022.6.17.0/src/stk/molecular/molecules/molecule/utilities/writers/pdb.py
--rw-r--r--   0 root         (0) root         (0)     1094 2022-06-17 11:10:18.000000 stk-2022.6.17.0/src/stk/molecular/molecules/molecule/utilities/writers/xyz.py
--rw-r--r--   0 root         (0) root         (0)      746 2022-06-17 11:10:18.000000 stk-2022.6.17.0/src/stk/molecular/molecules/utilities.py
--rw-r--r--   0 root         (0) root         (0)     4967 2022-06-17 11:10:18.000000 stk-2022.6.17.0/src/stk/molecular/periodic_info.py
-drwxr-xr-x   0 root         (0) root         (0)        0 2022-06-17 11:10:33.562121 stk-2022.6.17.0/src/stk/molecular/reactions/
--rw-r--r--   0 root         (0) root         (0)       66 2022-06-17 11:10:18.000000 stk-2022.6.17.0/src/stk/molecular/reactions/__init__.py
-drwxr-xr-x   0 root         (0) root         (0)        0 2022-06-17 11:10:33.562121 stk-2022.6.17.0/src/stk/molecular/reactions/factories/
--rw-r--r--   0 root         (0) root         (0)      135 2022-06-17 11:10:18.000000 stk-2022.6.17.0/src/stk/molecular/reactions/factories/__init__.py
--rw-r--r--   0 root         (0) root         (0)     1356 2022-06-17 11:10:18.000000 stk-2022.6.17.0/src/stk/molecular/reactions/factories/dative_reaction_factory.py
--rw-r--r--   0 root         (0) root         (0)     5696 2022-06-17 11:10:18.000000 stk-2022.6.17.0/src/stk/molecular/reactions/factories/generic_reaction_factory.py
--rw-r--r--   0 root         (0) root         (0)     1751 2022-06-17 11:10:18.000000 stk-2022.6.17.0/src/stk/molecular/reactions/factories/reaction_factory.py
-drwxr-xr-x   0 root         (0) root         (0)        0 2022-06-17 11:10:33.562121 stk-2022.6.17.0/src/stk/molecular/reactions/reactions/
--rw-r--r--   0 root         (0) root         (0)      241 2022-06-17 11:10:18.000000 stk-2022.6.17.0/src/stk/molecular/reactions/reactions/__init__.py
-drwxr-xr-x   0 root         (0) root         (0)        0 2022-06-17 11:10:33.562121 stk-2022.6.17.0/src/stk/molecular/reactions/reactions/dative_reaction/
--rw-r--r--   0 root         (0) root         (0)       39 2022-06-17 11:10:18.000000 stk-2022.6.17.0/src/stk/molecular/reactions/reactions/dative_reaction/__init__.py
--rw-r--r--   0 root         (0) root         (0)     1397 2022-06-17 11:10:18.000000 stk-2022.6.17.0/src/stk/molecular/reactions/reactions/dative_reaction/dative_reaction.py
--rw-r--r--   0 root         (0) root         (0)      497 2022-06-17 11:10:18.000000 stk-2022.6.17.0/src/stk/molecular/reactions/reactions/dative_reaction/utilities.py
--rw-r--r--   0 root         (0) root         (0)     1806 2022-06-17 11:10:18.000000 stk-2022.6.17.0/src/stk/molecular/reactions/reactions/one_one_reaction.py
--rw-r--r--   0 root         (0) root         (0)     1972 2022-06-17 11:10:18.000000 stk-2022.6.17.0/src/stk/molecular/reactions/reactions/one_two_reaction.py
-drwxr-xr-x   0 root         (0) root         (0)        0 2022-06-17 11:10:33.566121 stk-2022.6.17.0/src/stk/molecular/reactions/reactions/reaction/
--rw-r--r--   0 root         (0) root         (0)      129 2022-06-17 11:10:18.000000 stk-2022.6.17.0/src/stk/molecular/reactions/reactions/reaction/__init__.py
--rw-r--r--   0 root         (0) root         (0)     2011 2022-06-17 11:10:18.000000 stk-2022.6.17.0/src/stk/molecular/reactions/reactions/reaction/new_atom.py
--rw-r--r--   0 root         (0) root         (0)     4085 2022-06-17 11:10:18.000000 stk-2022.6.17.0/src/stk/molecular/reactions/reactions/reaction/reaction.py
--rw-r--r--   0 root         (0) root         (0)     2098 2022-06-17 11:10:18.000000 stk-2022.6.17.0/src/stk/molecular/reactions/reactions/reaction/reaction_result.py
--rw-r--r--   0 root         (0) root         (0)     3843 2022-06-17 11:10:18.000000 stk-2022.6.17.0/src/stk/molecular/reactions/reactions/ring_amine_reaction.py
--rw-r--r--   0 root         (0) root         (0)     2929 2022-06-17 11:10:18.000000 stk-2022.6.17.0/src/stk/molecular/reactions/reactions/two_two_reaction.py
-drwxr-xr-x   0 root         (0) root         (0)        0 2022-06-17 11:10:33.566121 stk-2022.6.17.0/src/stk/molecular/topology_graphs/
--rw-r--r--   0 root         (0) root         (0)      254 2022-06-17 11:10:18.000000 stk-2022.6.17.0/src/stk/molecular/topology_graphs/__init__.py
-drwxr-xr-x   0 root         (0) root         (0)        0 2022-06-17 11:10:33.566121 stk-2022.6.17.0/src/stk/molecular/topology_graphs/cage/
--rw-r--r--   0 root         (0) root         (0)      290 2022-06-17 11:10:18.000000 stk-2022.6.17.0/src/stk/molecular/topology_graphs/cage/__init__.py
--rw-r--r--   0 root         (0) root         (0)    45687 2022-06-17 11:10:18.000000 stk-2022.6.17.0/src/stk/molecular/topology_graphs/cage/cage.py
--rw-r--r--   0 root         (0) root         (0)     8115 2022-06-17 11:10:18.000000 stk-2022.6.17.0/src/stk/molecular/topology_graphs/cage/cage_construction_state.py
-drwxr-xr-x   0 root         (0) root         (0)        0 2022-06-17 11:10:33.566121 stk-2022.6.17.0/src/stk/molecular/topology_graphs/cage/metal_topologies/
--rw-r--r--   0 root         (0) root         (0)      454 2022-06-17 11:10:18.000000 stk-2022.6.17.0/src/stk/molecular/topology_graphs/cage/metal_topologies/__init__.py
--rw-r--r--   0 root         (0) root         (0)     7536 2022-06-17 11:10:18.000000 stk-2022.6.17.0/src/stk/molecular/topology_graphs/cage/metal_topologies/m12l24.py
--rw-r--r--   0 root         (0) root         (0)    13454 2022-06-17 11:10:18.000000 stk-2022.6.17.0/src/stk/molecular/topology_graphs/cage/metal_topologies/m24l48.py
--rw-r--r--   0 root         (0) root         (0)     5137 2022-06-17 11:10:18.000000 stk-2022.6.17.0/src/stk/molecular/topology_graphs/cage/metal_topologies/m2l4_lantern.py
--rw-r--r--   0 root         (0) root         (0)     8060 2022-06-17 11:10:18.000000 stk-2022.6.17.0/src/stk/molecular/topology_graphs/cage/metal_topologies/m3l3_triangle.py
--rw-r--r--   0 root         (0) root         (0)     7225 2022-06-17 11:10:18.000000 stk-2022.6.17.0/src/stk/molecular/topology_graphs/cage/metal_topologies/m3l6.py
--rw-r--r--   0 root         (0) root         (0)     7876 2022-06-17 11:10:18.000000 stk-2022.6.17.0/src/stk/molecular/topology_graphs/cage/metal_topologies/m4l4_square.py
--rw-r--r--   0 root         (0) root         (0)     7956 2022-06-17 11:10:18.000000 stk-2022.6.17.0/src/stk/molecular/topology_graphs/cage/metal_topologies/m4l4_tetrahedron.py
--rw-r--r--   0 root         (0) root         (0)     9228 2022-06-17 11:10:18.000000 stk-2022.6.17.0/src/stk/molecular/topology_graphs/cage/metal_topologies/m4l6_tetrahedron.py
--rw-r--r--   0 root         (0) root         (0)     8755 2022-06-17 11:10:18.000000 stk-2022.6.17.0/src/stk/molecular/topology_graphs/cage/metal_topologies/m4l6_tetrahedron_spacer.py
--rw-r--r--   0 root         (0) root         (0)     5895 2022-06-17 11:10:18.000000 stk-2022.6.17.0/src/stk/molecular/topology_graphs/cage/metal_topologies/m4l8.py
--rw-r--r--   0 root         (0) root         (0)     6734 2022-06-17 11:10:18.000000 stk-2022.6.17.0/src/stk/molecular/topology_graphs/cage/metal_topologies/m6l12_cube.py
--rw-r--r--   0 root         (0) root         (0)     9444 2022-06-17 11:10:18.000000 stk-2022.6.17.0/src/stk/molecular/topology_graphs/cage/metal_topologies/m6l2l3_prism.py
--rw-r--r--   0 root         (0) root         (0)     9492 2022-06-17 11:10:18.000000 stk-2022.6.17.0/src/stk/molecular/topology_graphs/cage/metal_topologies/m8l6_cube.py
-drwxr-xr-x   0 root         (0) root         (0)        0 2022-06-17 11:10:33.566121 stk-2022.6.17.0/src/stk/molecular/topology_graphs/cage/three_plus_four/
--rw-r--r--   0 root         (0) root         (0)       38 2022-06-17 11:10:18.000000 stk-2022.6.17.0/src/stk/molecular/topology_graphs/cage/three_plus_four/__init__.py
--rw-r--r--   0 root         (0) root         (0)     6775 2022-06-17 11:10:18.000000 stk-2022.6.17.0/src/stk/molecular/topology_graphs/cage/three_plus_four/six_plus_eight.py
-drwxr-xr-x   0 root         (0) root         (0)        0 2022-06-17 11:10:33.570122 stk-2022.6.17.0/src/stk/molecular/topology_graphs/cage/three_plus_three/
--rw-r--r--   0 root         (0) root         (0)      110 2022-06-17 11:10:18.000000 stk-2022.6.17.0/src/stk/molecular/topology_graphs/cage/three_plus_three/__init__.py
--rw-r--r--   0 root         (0) root         (0)     4103 2022-06-17 11:10:18.000000 stk-2022.6.17.0/src/stk/molecular/topology_graphs/cage/three_plus_three/four_plus_four.py
--rw-r--r--   0 root         (0) root         (0)     6087 2022-06-17 11:10:18.000000 stk-2022.6.17.0/src/stk/molecular/topology_graphs/cage/three_plus_three/one_plus_one.py
--rw-r--r--   0 root         (0) root         (0)     3577 2022-06-17 11:10:18.000000 stk-2022.6.17.0/src/stk/molecular/topology_graphs/cage/three_plus_three/two_plus_two.py
-drwxr-xr-x   0 root         (0) root         (0)        0 2022-06-17 11:10:33.570122 stk-2022.6.17.0/src/stk/molecular/topology_graphs/cage/two_plus_five/
--rw-r--r--   0 root         (0) root         (0)       42 2022-06-17 11:10:18.000000 stk-2022.6.17.0/src/stk/molecular/topology_graphs/cage/two_plus_five/__init__.py
--rw-r--r--   0 root         (0) root         (0)    11757 2022-06-17 11:10:18.000000 stk-2022.6.17.0/src/stk/molecular/topology_graphs/cage/two_plus_five/twelve_plus_thirty.py
-drwxr-xr-x   0 root         (0) root         (0)        0 2022-06-17 11:10:33.570122 stk-2022.6.17.0/src/stk/molecular/topology_graphs/cage/two_plus_four/
--rw-r--r--   0 root         (0) root         (0)      271 2022-06-17 11:10:18.000000 stk-2022.6.17.0/src/stk/molecular/topology_graphs/cage/two_plus_four/__init__.py
--rw-r--r--   0 root         (0) root         (0)     7985 2022-06-17 11:10:18.000000 stk-2022.6.17.0/src/stk/molecular/topology_graphs/cage/two_plus_four/eight_plus_sixteen.py
--rw-r--r--   0 root         (0) root         (0)     5585 2022-06-17 11:10:18.000000 stk-2022.6.17.0/src/stk/molecular/topology_graphs/cage/two_plus_four/five_plus_ten.py
--rw-r--r--   0 root         (0) root         (0)     4952 2022-06-17 11:10:18.000000 stk-2022.6.17.0/src/stk/molecular/topology_graphs/cage/two_plus_four/four_plus_eight.py
--rw-r--r--   0 root         (0) root         (0)     6673 2022-06-17 11:10:18.000000 stk-2022.6.17.0/src/stk/molecular/topology_graphs/cage/two_plus_four/six_plus_twelve.py
--rw-r--r--   0 root         (0) root         (0)     8948 2022-06-17 11:10:18.000000 stk-2022.6.17.0/src/stk/molecular/topology_graphs/cage/two_plus_four/ten_plus_twenty.py
--rw-r--r--   0 root         (0) root         (0)     4664 2022-06-17 11:10:18.000000 stk-2022.6.17.0/src/stk/molecular/topology_graphs/cage/two_plus_four/three_plus_six.py
--rw-r--r--   0 root         (0) root         (0)     4138 2022-06-17 11:10:18.000000 stk-2022.6.17.0/src/stk/molecular/topology_graphs/cage/two_plus_four/two_plus_four.py
-drwxr-xr-x   0 root         (0) root         (0)        0 2022-06-17 11:10:33.570122 stk-2022.6.17.0/src/stk/molecular/topology_graphs/cage/two_plus_three/
--rw-r--r--   0 root         (0) root         (0)      234 2022-06-17 11:10:18.000000 stk-2022.6.17.0/src/stk/molecular/topology_graphs/cage/two_plus_three/__init__.py
--rw-r--r--   0 root         (0) root         (0)     6823 2022-06-17 11:10:18.000000 stk-2022.6.17.0/src/stk/molecular/topology_graphs/cage/two_plus_three/eight_plus_twelve.py
--rw-r--r--   0 root         (0) root         (0)     4874 2022-06-17 11:10:18.000000 stk-2022.6.17.0/src/stk/molecular/topology_graphs/cage/two_plus_three/four_plus_six.py
--rw-r--r--   0 root         (0) root         (0)     4764 2022-06-17 11:10:18.000000 stk-2022.6.17.0/src/stk/molecular/topology_graphs/cage/two_plus_three/four_plus_six_2.py
--rw-r--r--   0 root         (0) root         (0)     6060 2022-06-17 11:10:18.000000 stk-2022.6.17.0/src/stk/molecular/topology_graphs/cage/two_plus_three/six_plus_nine.py
--rw-r--r--   0 root         (0) root         (0)    10936 2022-06-17 11:10:18.000000 stk-2022.6.17.0/src/stk/molecular/topology_graphs/cage/two_plus_three/twenty_plus_thirty.py
--rw-r--r--   0 root         (0) root         (0)     4024 2022-06-17 11:10:18.000000 stk-2022.6.17.0/src/stk/molecular/topology_graphs/cage/two_plus_three/two_plus_three.py
--rw-r--r--   0 root         (0) root         (0)    11602 2022-06-17 11:10:18.000000 stk-2022.6.17.0/src/stk/molecular/topology_graphs/cage/vertices.py
-drwxr-xr-x   0 root         (0) root         (0)        0 2022-06-17 11:10:33.574122 stk-2022.6.17.0/src/stk/molecular/topology_graphs/cof/
--rw-r--r--   0 root         (0) root         (0)      412 2022-06-17 11:10:18.000000 stk-2022.6.17.0/src/stk/molecular/topology_graphs/cof/__init__.py
--rw-r--r--   0 root         (0) root         (0)    27791 2022-06-17 11:10:18.000000 stk-2022.6.17.0/src/stk/molecular/topology_graphs/cof/cof.py
--rw-r--r--   0 root         (0) root         (0)     1916 2022-06-17 11:10:18.000000 stk-2022.6.17.0/src/stk/molecular/topology_graphs/cof/edge.py
--rw-r--r--   0 root         (0) root         (0)     8182 2022-06-17 11:10:18.000000 stk-2022.6.17.0/src/stk/molecular/topology_graphs/cof/hexagonal.py
--rw-r--r--   0 root         (0) root         (0)     4841 2022-06-17 11:10:18.000000 stk-2022.6.17.0/src/stk/molecular/topology_graphs/cof/honeycomb.py
--rw-r--r--   0 root         (0) root         (0)     6041 2022-06-17 11:10:18.000000 stk-2022.6.17.0/src/stk/molecular/topology_graphs/cof/kagome.py
--rw-r--r--   0 root         (0) root         (0)     3853 2022-06-17 11:10:18.000000 stk-2022.6.17.0/src/stk/molecular/topology_graphs/cof/linkerless_honeycomb.py
--rw-r--r--   0 root         (0) root         (0)    11933 2022-06-17 11:10:18.000000 stk-2022.6.17.0/src/stk/molecular/topology_graphs/cof/periodic_hexagonal.py
--rw-r--r--   0 root         (0) root         (0)     8593 2022-06-17 11:10:18.000000 stk-2022.6.17.0/src/stk/molecular/topology_graphs/cof/periodic_honeycomb.py
--rw-r--r--   0 root         (0) root         (0)    10045 2022-06-17 11:10:18.000000 stk-2022.6.17.0/src/stk/molecular/topology_graphs/cof/periodic_kagome.py
--rw-r--r--   0 root         (0) root         (0)     7614 2022-06-17 11:10:18.000000 stk-2022.6.17.0/src/stk/molecular/topology_graphs/cof/periodic_linkerless_honeycomb.py
--rw-r--r--   0 root         (0) root         (0)     8436 2022-06-17 11:10:18.000000 stk-2022.6.17.0/src/stk/molecular/topology_graphs/cof/periodic_square.py
--rw-r--r--   0 root         (0) root         (0)     4831 2022-06-17 11:10:18.000000 stk-2022.6.17.0/src/stk/molecular/topology_graphs/cof/square.py
--rw-r--r--   0 root         (0) root         (0)    11467 2022-06-17 11:10:18.000000 stk-2022.6.17.0/src/stk/molecular/topology_graphs/cof/vertices.py
-drwxr-xr-x   0 root         (0) root         (0)        0 2022-06-17 11:10:33.574122 stk-2022.6.17.0/src/stk/molecular/topology_graphs/host_guest/
--rw-r--r--   0 root         (0) root         (0)       62 2022-06-17 11:10:18.000000 stk-2022.6.17.0/src/stk/molecular/topology_graphs/host_guest/__init__.py
--rw-r--r--   0 root         (0) root         (0)    17065 2022-06-17 11:10:18.000000 stk-2022.6.17.0/src/stk/molecular/topology_graphs/host_guest/complex.py
--rw-r--r--   0 root         (0) root         (0)     2059 2022-06-17 11:10:18.000000 stk-2022.6.17.0/src/stk/molecular/topology_graphs/host_guest/vertices.py
-drwxr-xr-x   0 root         (0) root         (0)        0 2022-06-17 11:10:33.574122 stk-2022.6.17.0/src/stk/molecular/topology_graphs/macrocycle/
--rw-r--r--   0 root         (0) root         (0)       65 2022-06-17 11:10:18.000000 stk-2022.6.17.0/src/stk/molecular/topology_graphs/macrocycle/__init__.py
--rw-r--r--   0 root         (0) root         (0)    18479 2022-06-17 11:10:18.000000 stk-2022.6.17.0/src/stk/molecular/topology_graphs/macrocycle/macrocycle.py
--rw-r--r--   0 root         (0) root         (0)     3608 2022-06-17 11:10:18.000000 stk-2022.6.17.0/src/stk/molecular/topology_graphs/macrocycle/vertices.py
-drwxr-xr-x   0 root         (0) root         (0)        0 2022-06-17 11:10:33.574122 stk-2022.6.17.0/src/stk/molecular/topology_graphs/metal_complex/
--rw-r--r--   0 root         (0) root         (0)      207 2022-06-17 11:10:18.000000 stk-2022.6.17.0/src/stk/molecular/topology_graphs/metal_complex/__init__.py
--rw-r--r--   0 root         (0) root         (0)    27357 2022-06-17 11:10:18.000000 stk-2022.6.17.0/src/stk/molecular/topology_graphs/metal_complex/metal_complex.py
-drwxr-xr-x   0 root         (0) root         (0)        0 2022-06-17 11:10:33.574122 stk-2022.6.17.0/src/stk/molecular/topology_graphs/metal_complex/octahedral/
--rw-r--r--   0 root         (0) root         (0)      115 2022-06-17 11:10:18.000000 stk-2022.6.17.0/src/stk/molecular/topology_graphs/metal_complex/octahedral/__init__.py
--rw-r--r--   0 root         (0) root         (0)     3625 2022-06-17 11:10:18.000000 stk-2022.6.17.0/src/stk/molecular/topology_graphs/metal_complex/octahedral/octahedral.py
--rw-r--r--   0 root         (0) root         (0)     3942 2022-06-17 11:10:18.000000 stk-2022.6.17.0/src/stk/molecular/topology_graphs/metal_complex/octahedral/octahedral_delta.py
--rw-r--r--   0 root         (0) root         (0)     3946 2022-06-17 11:10:18.000000 stk-2022.6.17.0/src/stk/molecular/topology_graphs/metal_complex/octahedral/octahedral_lambda.py
-drwxr-xr-x   0 root         (0) root         (0)        0 2022-06-17 11:10:33.578122 stk-2022.6.17.0/src/stk/molecular/topology_graphs/metal_complex/paddlewheel/
--rw-r--r--   0 root         (0) root         (0)       35 2022-06-17 11:10:18.000000 stk-2022.6.17.0/src/stk/molecular/topology_graphs/metal_complex/paddlewheel/__init__.py
--rw-r--r--   0 root         (0) root         (0)     4715 2022-06-17 11:10:18.000000 stk-2022.6.17.0/src/stk/molecular/topology_graphs/metal_complex/paddlewheel/paddlewheel.py
-drwxr-xr-x   0 root         (0) root         (0)        0 2022-06-17 11:10:33.578122 stk-2022.6.17.0/src/stk/molecular/topology_graphs/metal_complex/porphyrin/
--rw-r--r--   0 root         (0) root         (0)       33 2022-06-17 11:10:18.000000 stk-2022.6.17.0/src/stk/molecular/topology_graphs/metal_complex/porphyrin/__init__.py
--rw-r--r--   0 root         (0) root         (0)     3276 2022-06-17 11:10:18.000000 stk-2022.6.17.0/src/stk/molecular/topology_graphs/metal_complex/porphyrin/porphyrin.py
-drwxr-xr-x   0 root         (0) root         (0)        0 2022-06-17 11:10:33.578122 stk-2022.6.17.0/src/stk/molecular/topology_graphs/metal_complex/square_planar/
--rw-r--r--   0 root         (0) root         (0)      135 2022-06-17 11:10:18.000000 stk-2022.6.17.0/src/stk/molecular/topology_graphs/metal_complex/square_planar/__init__.py
--rw-r--r--   0 root         (0) root         (0)     3321 2022-06-17 11:10:18.000000 stk-2022.6.17.0/src/stk/molecular/topology_graphs/metal_complex/square_planar/bidentate_square_planar.py
--rw-r--r--   0 root         (0) root         (0)     2931 2022-06-17 11:10:18.000000 stk-2022.6.17.0/src/stk/molecular/topology_graphs/metal_complex/square_planar/cis_protected_square_planar.py
--rw-r--r--   0 root         (0) root         (0)     3267 2022-06-17 11:10:18.000000 stk-2022.6.17.0/src/stk/molecular/topology_graphs/metal_complex/square_planar/square_planar.py
--rw-r--r--   0 root         (0) root         (0)     4762 2022-06-17 11:10:18.000000 stk-2022.6.17.0/src/stk/molecular/topology_graphs/metal_complex/vertices.py
-drwxr-xr-x   0 root         (0) root         (0)        0 2022-06-17 11:10:33.578122 stk-2022.6.17.0/src/stk/molecular/topology_graphs/polymer/
--rw-r--r--   0 root         (0) root         (0)       78 2022-06-17 11:10:18.000000 stk-2022.6.17.0/src/stk/molecular/topology_graphs/polymer/__init__.py
-drwxr-xr-x   0 root         (0) root         (0)        0 2022-06-17 11:10:33.578122 stk-2022.6.17.0/src/stk/molecular/topology_graphs/polymer/linear/
--rw-r--r--   0 root         (0) root         (0)       61 2022-06-17 11:10:18.000000 stk-2022.6.17.0/src/stk/molecular/topology_graphs/polymer/linear/__init__.py
--rw-r--r--   0 root         (0) root         (0)    24116 2022-06-17 11:10:18.000000 stk-2022.6.17.0/src/stk/molecular/topology_graphs/polymer/linear/linear.py
--rw-r--r--   0 root         (0) root         (0)     6084 2022-06-17 11:10:18.000000 stk-2022.6.17.0/src/stk/molecular/topology_graphs/polymer/linear/vertices.py
-drwxr-xr-x   0 root         (0) root         (0)        0 2022-06-17 11:10:33.578122 stk-2022.6.17.0/src/stk/molecular/topology_graphs/rotaxane/
--rw-r--r--   0 root         (0) root         (0)      116 2022-06-17 11:10:18.000000 stk-2022.6.17.0/src/stk/molecular/topology_graphs/rotaxane/__init__.py
--rw-r--r--   0 root         (0) root         (0)    18803 2022-06-17 11:10:18.000000 stk-2022.6.17.0/src/stk/molecular/topology_graphs/rotaxane/nrotaxane.py
--rw-r--r--   0 root         (0) root         (0)     2228 2022-06-17 11:10:18.000000 stk-2022.6.17.0/src/stk/molecular/topology_graphs/rotaxane/vertices.py
-drwxr-xr-x   0 root         (0) root         (0)        0 2022-06-17 11:10:33.578122 stk-2022.6.17.0/src/stk/molecular/topology_graphs/topology_graph/
--rw-r--r--   0 root         (0) root         (0)      173 2022-06-17 11:10:18.000000 stk-2022.6.17.0/src/stk/molecular/topology_graphs/topology_graph/__init__.py
-drwxr-xr-x   0 root         (0) root         (0)        0 2022-06-17 11:10:33.578122 stk-2022.6.17.0/src/stk/molecular/topology_graphs/topology_graph/construction_result/
--rw-r--r--   0 root         (0) root         (0)      176 2022-06-17 11:10:18.000000 stk-2022.6.17.0/src/stk/molecular/topology_graphs/topology_graph/construction_result/__init__.py
--rw-r--r--   0 root         (0) root         (0)     3736 2022-06-17 11:10:18.000000 stk-2022.6.17.0/src/stk/molecular/topology_graphs/topology_graph/construction_result/construction_result.py
--rw-r--r--   0 root         (0) root         (0)     1434 2022-06-17 11:10:18.000000 stk-2022.6.17.0/src/stk/molecular/topology_graphs/topology_graph/construction_result/periodic.py
-drwxr-xr-x   0 root         (0) root         (0)        0 2022-06-17 11:10:33.582121 stk-2022.6.17.0/src/stk/molecular/topology_graphs/topology_graph/construction_state/
--rw-r--r--   0 root         (0) root         (0)       58 2022-06-17 11:10:18.000000 stk-2022.6.17.0/src/stk/molecular/topology_graphs/topology_graph/construction_state/__init__.py
--rw-r--r--   0 root         (0) root         (0)    12054 2022-06-17 11:10:18.000000 stk-2022.6.17.0/src/stk/molecular/topology_graphs/topology_graph/construction_state/construction_state.py
--rw-r--r--   0 root         (0) root         (0)    10648 2022-06-17 11:10:18.000000 stk-2022.6.17.0/src/stk/molecular/topology_graphs/topology_graph/construction_state/graph_state.py
-drwxr-xr-x   0 root         (0) root         (0)        0 2022-06-17 11:10:33.582121 stk-2022.6.17.0/src/stk/molecular/topology_graphs/topology_graph/construction_state/molecule_state/
--rw-r--r--   0 root         (0) root         (0)       51 2022-06-17 11:10:18.000000 stk-2022.6.17.0/src/stk/molecular/topology_graphs/topology_graph/construction_state/molecule_state/__init__.py
--rw-r--r--   0 root         (0) root         (0)     5659 2022-06-17 11:10:18.000000 stk-2022.6.17.0/src/stk/molecular/topology_graphs/topology_graph/construction_state/molecule_state/deletions_summary.py
--rw-r--r--   0 root         (0) root         (0)     9123 2022-06-17 11:10:18.000000 stk-2022.6.17.0/src/stk/molecular/topology_graphs/topology_graph/construction_state/molecule_state/molecule_state.py
-drwxr-xr-x   0 root         (0) root         (0)        0 2022-06-17 11:10:33.582121 stk-2022.6.17.0/src/stk/molecular/topology_graphs/topology_graph/construction_state/molecule_state/placements_summary/
--rw-r--r--   0 root         (0) root         (0)       59 2022-06-17 11:10:18.000000 stk-2022.6.17.0/src/stk/molecular/topology_graphs/topology_graph/construction_state/molecule_state/placements_summary/__init__.py
--rw-r--r--   0 root         (0) root         (0)     2422 2022-06-17 11:10:18.000000 stk-2022.6.17.0/src/stk/molecular/topology_graphs/topology_graph/construction_state/molecule_state/placements_summary/atom_batch.py
--rw-r--r--   0 root         (0) root         (0)     1884 2022-06-17 11:10:18.000000 stk-2022.6.17.0/src/stk/molecular/topology_graphs/topology_graph/construction_state/molecule_state/placements_summary/bond_batch.py
--rw-r--r--   0 root         (0) root         (0)     7322 2022-06-17 11:10:18.000000 stk-2022.6.17.0/src/stk/molecular/topology_graphs/topology_graph/construction_state/molecule_state/placements_summary/placements_summary.py
-drwxr-xr-x   0 root         (0) root         (0)        0 2022-06-17 11:10:33.582121 stk-2022.6.17.0/src/stk/molecular/topology_graphs/topology_graph/construction_state/molecule_state/reactions_summary/
--rw-r--r--   0 root         (0) root         (0)       57 2022-06-17 11:10:18.000000 stk-2022.6.17.0/src/stk/molecular/topology_graphs/topology_graph/construction_state/molecule_state/reactions_summary/__init__.py
--rw-r--r--   0 root         (0) root         (0)     2234 2022-06-17 11:10:18.000000 stk-2022.6.17.0/src/stk/molecular/topology_graphs/topology_graph/construction_state/molecule_state/reactions_summary/atom_batch.py
--rw-r--r--   0 root         (0) root         (0)     1307 2022-06-17 11:10:18.000000 stk-2022.6.17.0/src/stk/molecular/topology_graphs/topology_graph/construction_state/molecule_state/reactions_summary/bond_batch.py
--rw-r--r--   0 root         (0) root         (0)     5218 2022-06-17 11:10:18.000000 stk-2022.6.17.0/src/stk/molecular/topology_graphs/topology_graph/construction_state/molecule_state/reactions_summary/reactions_summary.py
--rw-r--r--   0 root         (0) root         (0)     5593 2022-06-17 11:10:18.000000 stk-2022.6.17.0/src/stk/molecular/topology_graphs/topology_graph/edge.py
--rw-r--r--   0 root         (0) root         (0)      887 2022-06-17 11:10:18.000000 stk-2022.6.17.0/src/stk/molecular/topology_graphs/topology_graph/edge_group.py
-drwxr-xr-x   0 root         (0) root         (0)        0 2022-06-17 11:10:33.582121 stk-2022.6.17.0/src/stk/molecular/topology_graphs/topology_graph/optimizers/
--rw-r--r--   0 root         (0) root         (0)      232 2022-06-17 11:10:18.000000 stk-2022.6.17.0/src/stk/molecular/topology_graphs/topology_graph/optimizers/__init__.py
--rw-r--r--   0 root         (0) root         (0)     3102 2022-06-17 11:10:18.000000 stk-2022.6.17.0/src/stk/molecular/topology_graphs/topology_graph/optimizers/collapser.py
--rw-r--r--   0 root         (0) root         (0)     4574 2022-06-17 11:10:18.000000 stk-2022.6.17.0/src/stk/molecular/topology_graphs/topology_graph/optimizers/mchammer.py
--rw-r--r--   0 root         (0) root         (0)      215 2022-06-17 11:10:18.000000 stk-2022.6.17.0/src/stk/molecular/topology_graphs/topology_graph/optimizers/null.py
--rw-r--r--   0 root         (0) root         (0)     1098 2022-06-17 11:10:18.000000 stk-2022.6.17.0/src/stk/molecular/topology_graphs/topology_graph/optimizers/optimizer.py
--rw-r--r--   0 root         (0) root         (0)     3804 2022-06-17 11:10:18.000000 stk-2022.6.17.0/src/stk/molecular/topology_graphs/topology_graph/optimizers/periodic_collapser.py
--rw-r--r--   0 root         (0) root         (0)     4394 2022-06-17 11:10:18.000000 stk-2022.6.17.0/src/stk/molecular/topology_graphs/topology_graph/optimizers/spinner.py
--rw-r--r--   0 root         (0) root         (0)     2118 2022-06-17 11:10:18.000000 stk-2022.6.17.0/src/stk/molecular/topology_graphs/topology_graph/optimizers/utilities.py
-drwxr-xr-x   0 root         (0) root         (0)        0 2022-06-17 11:10:33.586122 stk-2022.6.17.0/src/stk/molecular/topology_graphs/topology_graph/topology_graph/
--rw-r--r--   0 root         (0) root         (0)       38 2022-06-17 11:10:18.000000 stk-2022.6.17.0/src/stk/molecular/topology_graphs/topology_graph/topology_graph/__init__.py
-drwxr-xr-x   0 root         (0) root         (0)        0 2022-06-17 11:10:33.586122 stk-2022.6.17.0/src/stk/molecular/topology_graphs/topology_graph/topology_graph/implementations/
--rw-r--r--   0 root         (0) root         (0)      167 2022-06-17 11:10:18.000000 stk-2022.6.17.0/src/stk/molecular/topology_graphs/topology_graph/topology_graph/implementations/__init__.py
--rw-r--r--   0 root         (0) root         (0)     2129 2022-06-17 11:10:18.000000 stk-2022.6.17.0/src/stk/molecular/topology_graphs/topology_graph/topology_graph/implementations/parallel.py
--rw-r--r--   0 root         (0) root         (0)     1785 2022-06-17 11:10:18.000000 stk-2022.6.17.0/src/stk/molecular/topology_graphs/topology_graph/topology_graph/implementations/serial.py
--rw-r--r--   0 root         (0) root         (0)     2578 2022-06-17 11:10:18.000000 stk-2022.6.17.0/src/stk/molecular/topology_graphs/topology_graph/topology_graph/implementations/utilities.py
--rw-r--r--   0 root         (0) root         (0)    19475 2022-06-17 11:10:18.000000 stk-2022.6.17.0/src/stk/molecular/topology_graphs/topology_graph/topology_graph/topology_graph.py
--rw-r--r--   0 root         (0) root         (0)     5082 2022-06-17 11:10:18.000000 stk-2022.6.17.0/src/stk/molecular/topology_graphs/topology_graph/vertex.py
-drwxr-xr-x   0 root         (0) root         (0)        0 2022-06-17 11:10:33.586122 stk-2022.6.17.0/src/stk/molecular/topology_graphs/utilities/
--rw-r--r--   0 root         (0) root         (0)      113 2022-06-17 11:10:18.000000 stk-2022.6.17.0/src/stk/molecular/topology_graphs/utilities/__init__.py
--rw-r--r--   0 root         (0) root         (0)     1126 2022-06-17 11:10:18.000000 stk-2022.6.17.0/src/stk/molecular/topology_graphs/utilities/edge_sorter.py
--rw-r--r--   0 root         (0) root         (0)     1959 2022-06-17 11:10:18.000000 stk-2022.6.17.0/src/stk/molecular/topology_graphs/utilities/functional_group_sorter.py
--rw-r--r--   0 root         (0) root         (0)     2367 2022-06-17 11:10:18.000000 stk-2022.6.17.0/src/stk/molecular/topology_graphs/utilities/sorter.py
-drwxr-xr-x   0 root         (0) root         (0)        0 2022-06-17 11:10:33.586122 stk-2022.6.17.0/src/stk/molecular/writers/
--rw-r--r--   0 root         (0) root         (0)      118 2022-06-17 11:10:18.000000 stk-2022.6.17.0/src/stk/molecular/writers/__init__.py
--rw-r--r--   0 root         (0) root         (0)     4094 2022-06-17 11:10:18.000000 stk-2022.6.17.0/src/stk/molecular/writers/mdl_mol.py
--rw-r--r--   0 root         (0) root         (0)     6004 2022-06-17 11:10:18.000000 stk-2022.6.17.0/src/stk/molecular/writers/pdb.py
--rw-r--r--   0 root         (0) root         (0)     5023 2022-06-17 11:10:18.000000 stk-2022.6.17.0/src/stk/molecular/writers/turbomole.py
--rw-r--r--   0 root         (0) root         (0)     2842 2022-06-17 11:10:18.000000 stk-2022.6.17.0/src/stk/molecular/writers/xyz.py
--rw-r--r--   0 root         (0) root         (0)        0 2022-06-17 11:10:18.000000 stk-2022.6.17.0/src/stk/py.typed
-drwxr-xr-x   0 root         (0) root         (0)        0 2022-06-17 11:10:33.586122 stk-2022.6.17.0/src/stk/serialization/
--rw-r--r--   0 root         (0) root         (0)       28 2022-06-17 11:10:18.000000 stk-2022.6.17.0/src/stk/serialization/__init__.py
-drwxr-xr-x   0 root         (0) root         (0)        0 2022-06-17 11:10:33.586122 stk-2022.6.17.0/src/stk/serialization/json/
--rw-r--r--   0 root         (0) root         (0)       72 2022-06-17 11:10:18.000000 stk-2022.6.17.0/src/stk/serialization/json/__init__.py
-drwxr-xr-x   0 root         (0) root         (0)        0 2022-06-17 11:10:33.586122 stk-2022.6.17.0/src/stk/serialization/json/deserializers/
--rw-r--r--   0 root         (0) root         (0)       76 2022-06-17 11:10:18.000000 stk-2022.6.17.0/src/stk/serialization/json/deserializers/__init__.py
--rw-r--r--   0 root         (0) root         (0)     2885 2022-06-17 11:10:18.000000 stk-2022.6.17.0/src/stk/serialization/json/deserializers/constructed_molecule.py
--rw-r--r--   0 root         (0) root         (0)     1486 2022-06-17 11:10:18.000000 stk-2022.6.17.0/src/stk/serialization/json/deserializers/molecule.py
--rw-r--r--   0 root         (0) root         (0)     1138 2022-06-17 11:10:18.000000 stk-2022.6.17.0/src/stk/serialization/json/deserializers/utilities.py
-drwxr-xr-x   0 root         (0) root         (0)        0 2022-06-17 11:10:33.586122 stk-2022.6.17.0/src/stk/serialization/json/serializers/
--rw-r--r--   0 root         (0) root         (0)       76 2022-06-17 11:10:18.000000 stk-2022.6.17.0/src/stk/serialization/json/serializers/__init__.py
-drwxr-xr-x   0 root         (0) root         (0)        0 2022-06-17 11:10:33.590122 stk-2022.6.17.0/src/stk/serialization/json/serializers/constructed_molecule/
--rw-r--r--   0 root         (0) root         (0)       44 2022-06-17 11:10:18.000000 stk-2022.6.17.0/src/stk/serialization/json/serializers/constructed_molecule/__init__.py
--rw-r--r--   0 root         (0) root         (0)     6856 2022-06-17 11:10:18.000000 stk-2022.6.17.0/src/stk/serialization/json/serializers/constructed_molecule/constructed_molecule.py
-drwxr-xr-x   0 root         (0) root         (0)        0 2022-06-17 11:10:33.590122 stk-2022.6.17.0/src/stk/serialization/json/serializers/molecule/
--rw-r--r--   0 root         (0) root         (0)       47 2022-06-17 11:10:18.000000 stk-2022.6.17.0/src/stk/serialization/json/serializers/molecule/__init__.py
--rw-r--r--   0 root         (0) root         (0)     4566 2022-06-17 11:10:18.000000 stk-2022.6.17.0/src/stk/serialization/json/serializers/molecule/molecule.py
--rw-r--r--   0 root         (0) root         (0)     1112 2022-06-17 11:10:18.000000 stk-2022.6.17.0/src/stk/serialization/json/serializers/molecule/utilities.py
-drwxr-xr-x   0 root         (0) root         (0)        0 2022-06-17 11:10:33.590122 stk-2022.6.17.0/src/stk/utilities/
--rw-r--r--   0 root         (0) root         (0)       33 2022-06-17 11:10:18.000000 stk-2022.6.17.0/src/stk/utilities/__init__.py
--rw-r--r--   0 root         (0) root         (0)    22924 2022-06-17 11:10:18.000000 stk-2022.6.17.0/src/stk/utilities/utilities.py
-drwxr-xr-x   0 root         (0) root         (0)        0 2022-06-17 11:10:33.534122 stk-2022.6.17.0/src/stk.egg-info/
--rw-r--r--   0 root         (0) root         (0)      188 2022-06-17 11:10:32.000000 stk-2022.6.17.0/src/stk.egg-info/PKG-INFO
--rw-r--r--   0 root         (0) root         (0)    18817 2022-06-17 11:10:33.000000 stk-2022.6.17.0/src/stk.egg-info/SOURCES.txt
--rw-r--r--   0 root         (0) root         (0)        1 2022-06-17 11:10:32.000000 stk-2022.6.17.0/src/stk.egg-info/dependency_links.txt
--rw-r--r--   0 root         (0) root         (0)      101 2022-06-17 11:10:33.000000 stk-2022.6.17.0/src/stk.egg-info/requires.txt
--rw-r--r--   0 root         (0) root         (0)        4 2022-06-17 11:10:33.000000 stk-2022.6.17.0/src/stk.egg-info/top_level.txt
+drwxr-xr-x   0 root         (0) root         (0)        0 2023-07-05 15:50:04.563074 stk-2023.7.5.0/
+-rw-r--r--   0 root         (0) root         (0)     1098 2023-07-05 15:49:52.000000 stk-2023.7.5.0/LICENSE
+-rw-r--r--   0 root         (0) root         (0)     6103 2023-07-05 15:50:04.563074 stk-2023.7.5.0/PKG-INFO
+-rw-r--r--   0 root         (0) root         (0)     5735 2023-07-05 15:49:52.000000 stk-2023.7.5.0/README.rst
+-rw-r--r--   0 root         (0) root         (0)     1585 2023-07-05 15:49:52.000000 stk-2023.7.5.0/pyproject.toml
+-rw-r--r--   0 root         (0) root         (0)       38 2023-07-05 15:50:04.563074 stk-2023.7.5.0/setup.cfg
+drwxr-xr-x   0 root         (0) root         (0)        0 2023-07-05 15:50:04.515075 stk-2023.7.5.0/src/
+drwxr-xr-x   0 root         (0) root         (0)        0 2023-07-05 15:50:04.523074 stk-2023.7.5.0/src/stk/
+-rw-r--r--   0 root         (0) root         (0)    14877 2023-07-05 15:49:52.000000 stk-2023.7.5.0/src/stk/__init__.py
+drwxr-xr-x   0 root         (0) root         (0)        0 2023-07-05 15:50:04.523074 stk-2023.7.5.0/src/stk/_internal/
+-rw-r--r--   0 root         (0) root         (0)        1 2023-07-05 15:49:52.000000 stk-2023.7.5.0/src/stk/_internal/__init__.py
+-rw-r--r--   0 root         (0) root         (0)     2835 2023-07-05 15:49:52.000000 stk-2023.7.5.0/src/stk/_internal/atom.py
+-rw-r--r--   0 root         (0) root         (0)     3520 2023-07-05 15:49:52.000000 stk-2023.7.5.0/src/stk/_internal/atom_info.py
+-rw-r--r--   0 root         (0) root         (0)     5660 2023-07-05 15:49:52.000000 stk-2023.7.5.0/src/stk/_internal/bond.py
+-rw-r--r--   0 root         (0) root         (0)     2649 2023-07-05 15:49:52.000000 stk-2023.7.5.0/src/stk/_internal/bond_info.py
+-rw-r--r--   0 root         (0) root         (0)    37484 2023-07-05 15:49:52.000000 stk-2023.7.5.0/src/stk/_internal/building_block.py
+-rw-r--r--   0 root         (0) root         (0)    14393 2023-07-05 15:49:52.000000 stk-2023.7.5.0/src/stk/_internal/constructed_molecule.py
+drwxr-xr-x   0 root         (0) root         (0)        0 2023-07-05 15:50:04.527074 stk-2023.7.5.0/src/stk/_internal/construction_result/
+-rw-r--r--   0 root         (0) root         (0)        1 2023-07-05 15:49:52.000000 stk-2023.7.5.0/src/stk/_internal/construction_result/__init__.py
+-rw-r--r--   0 root         (0) root         (0)     3700 2023-07-05 15:49:52.000000 stk-2023.7.5.0/src/stk/_internal/construction_result/construction_result.py
+-rw-r--r--   0 root         (0) root         (0)     1447 2023-07-05 15:49:52.000000 stk-2023.7.5.0/src/stk/_internal/construction_result/periodic.py
+drwxr-xr-x   0 root         (0) root         (0)        0 2023-07-05 15:50:04.527074 stk-2023.7.5.0/src/stk/_internal/construction_state/
+-rw-r--r--   0 root         (0) root         (0)       58 2023-07-05 15:49:52.000000 stk-2023.7.5.0/src/stk/_internal/construction_state/__init__.py
+-rw-r--r--   0 root         (0) root         (0)    11906 2023-07-05 15:49:52.000000 stk-2023.7.5.0/src/stk/_internal/construction_state/construction_state.py
+-rw-r--r--   0 root         (0) root         (0)    10688 2023-07-05 15:49:52.000000 stk-2023.7.5.0/src/stk/_internal/construction_state/graph_state.py
+drwxr-xr-x   0 root         (0) root         (0)        0 2023-07-05 15:50:04.527074 stk-2023.7.5.0/src/stk/_internal/construction_state/molecule_state/
+-rw-r--r--   0 root         (0) root         (0)       50 2023-07-05 15:49:52.000000 stk-2023.7.5.0/src/stk/_internal/construction_state/molecule_state/__init__.py
+-rw-r--r--   0 root         (0) root         (0)     5684 2023-07-05 15:49:52.000000 stk-2023.7.5.0/src/stk/_internal/construction_state/molecule_state/deletions_summary.py
+-rw-r--r--   0 root         (0) root         (0)     9278 2023-07-05 15:49:52.000000 stk-2023.7.5.0/src/stk/_internal/construction_state/molecule_state/molecule_state.py
+drwxr-xr-x   0 root         (0) root         (0)        0 2023-07-05 15:50:04.527074 stk-2023.7.5.0/src/stk/_internal/construction_state/molecule_state/placements_summary/
+-rw-r--r--   0 root         (0) root         (0)       59 2023-07-05 15:49:52.000000 stk-2023.7.5.0/src/stk/_internal/construction_state/molecule_state/placements_summary/__init__.py
+-rw-r--r--   0 root         (0) root         (0)     2477 2023-07-05 15:49:52.000000 stk-2023.7.5.0/src/stk/_internal/construction_state/molecule_state/placements_summary/atom_batch.py
+-rw-r--r--   0 root         (0) root         (0)     1939 2023-07-05 15:49:52.000000 stk-2023.7.5.0/src/stk/_internal/construction_state/molecule_state/placements_summary/bond_batch.py
+-rw-r--r--   0 root         (0) root         (0)     7311 2023-07-05 15:49:52.000000 stk-2023.7.5.0/src/stk/_internal/construction_state/molecule_state/placements_summary/placements_summary.py
+drwxr-xr-x   0 root         (0) root         (0)        0 2023-07-05 15:50:04.527074 stk-2023.7.5.0/src/stk/_internal/construction_state/molecule_state/reactions_summary/
+-rw-r--r--   0 root         (0) root         (0)       57 2023-07-05 15:49:52.000000 stk-2023.7.5.0/src/stk/_internal/construction_state/molecule_state/reactions_summary/__init__.py
+-rw-r--r--   0 root         (0) root         (0)     2296 2023-07-05 15:49:52.000000 stk-2023.7.5.0/src/stk/_internal/construction_state/molecule_state/reactions_summary/atom_batch.py
+-rw-r--r--   0 root         (0) root         (0)     1319 2023-07-05 15:49:52.000000 stk-2023.7.5.0/src/stk/_internal/construction_state/molecule_state/reactions_summary/bond_batch.py
+-rw-r--r--   0 root         (0) root         (0)     5218 2023-07-05 15:49:52.000000 stk-2023.7.5.0/src/stk/_internal/construction_state/molecule_state/reactions_summary/reactions_summary.py
+drwxr-xr-x   0 root         (0) root         (0)        0 2023-07-05 15:50:04.527074 stk-2023.7.5.0/src/stk/_internal/databases/
+-rw-r--r--   0 root         (0) root         (0)        1 2023-07-05 15:49:52.000000 stk-2023.7.5.0/src/stk/_internal/databases/__init__.py
+-rw-r--r--   0 root         (0) root         (0)     1587 2023-07-05 15:49:52.000000 stk-2023.7.5.0/src/stk/_internal/databases/constructed_molecule.py
+-rw-r--r--   0 root         (0) root         (0)     1747 2023-07-05 15:49:52.000000 stk-2023.7.5.0/src/stk/_internal/databases/molecule.py
+drwxr-xr-x   0 root         (0) root         (0)        0 2023-07-05 15:50:04.527074 stk-2023.7.5.0/src/stk/_internal/databases/mongo_db/
+-rw-r--r--   0 root         (0) root         (0)        1 2023-07-05 15:49:52.000000 stk-2023.7.5.0/src/stk/_internal/databases/mongo_db/__init__.py
+-rw-r--r--   0 root         (0) root         (0)    27693 2023-07-05 15:49:52.000000 stk-2023.7.5.0/src/stk/_internal/databases/mongo_db/constructed_molecule.py
+-rw-r--r--   0 root         (0) root         (0)    17958 2023-07-05 15:49:52.000000 stk-2023.7.5.0/src/stk/_internal/databases/mongo_db/molecule.py
+-rw-r--r--   0 root         (0) root         (0)     1361 2023-07-05 15:49:52.000000 stk-2023.7.5.0/src/stk/_internal/databases/mongo_db/utilities.py
+-rw-r--r--   0 root         (0) root         (0)     6457 2023-07-05 15:49:52.000000 stk-2023.7.5.0/src/stk/_internal/databases/mongo_db/value.py
+-rw-r--r--   0 root         (0) root         (0)     3658 2023-07-05 15:49:52.000000 stk-2023.7.5.0/src/stk/_internal/databases/value.py
+drwxr-xr-x   0 root         (0) root         (0)        0 2023-07-05 15:50:04.527074 stk-2023.7.5.0/src/stk/_internal/ea/
+-rw-r--r--   0 root         (0) root         (0)        1 2023-07-05 15:49:52.000000 stk-2023.7.5.0/src/stk/_internal/ea/__init__.py
+drwxr-xr-x   0 root         (0) root         (0)        0 2023-07-05 15:50:04.531074 stk-2023.7.5.0/src/stk/_internal/ea/crossover/
+-rw-r--r--   0 root         (0) root         (0)        1 2023-07-05 15:49:52.000000 stk-2023.7.5.0/src/stk/_internal/ea/crossover/__init__.py
+-rw-r--r--   0 root         (0) root         (0)     8967 2023-07-05 15:49:52.000000 stk-2023.7.5.0/src/stk/_internal/ea/crossover/genetic_recombination.py
+-rw-r--r--   0 root         (0) root         (0)      914 2023-07-05 15:49:52.000000 stk-2023.7.5.0/src/stk/_internal/ea/crossover/molecule_crosser.py
+-rw-r--r--   0 root         (0) root         (0)     7633 2023-07-05 15:49:52.000000 stk-2023.7.5.0/src/stk/_internal/ea/crossover/random.py
+-rw-r--r--   0 root         (0) root         (0)     1303 2023-07-05 15:49:52.000000 stk-2023.7.5.0/src/stk/_internal/ea/crossover/record.py
+drwxr-xr-x   0 root         (0) root         (0)        0 2023-07-05 15:50:04.531074 stk-2023.7.5.0/src/stk/_internal/ea/evolutionary_algorithm/
+-rw-r--r--   0 root         (0) root         (0)        1 2023-07-05 15:49:52.000000 stk-2023.7.5.0/src/stk/_internal/ea/evolutionary_algorithm/__init__.py
+-rw-r--r--   0 root         (0) root         (0)     4741 2023-07-05 15:49:52.000000 stk-2023.7.5.0/src/stk/_internal/ea/evolutionary_algorithm/evolutionary_algorithm.py
+drwxr-xr-x   0 root         (0) root         (0)        0 2023-07-05 15:50:04.531074 stk-2023.7.5.0/src/stk/_internal/ea/evolutionary_algorithm/implementations/
+-rw-r--r--   0 root         (0) root         (0)        1 2023-07-05 15:49:52.000000 stk-2023.7.5.0/src/stk/_internal/ea/evolutionary_algorithm/implementations/__init__.py
+-rw-r--r--   0 root         (0) root         (0)     4186 2023-07-05 15:49:52.000000 stk-2023.7.5.0/src/stk/_internal/ea/evolutionary_algorithm/implementations/implementation.py
+-rw-r--r--   0 root         (0) root         (0)     1245 2023-07-05 15:49:52.000000 stk-2023.7.5.0/src/stk/_internal/ea/evolutionary_algorithm/implementations/parallel.py
+-rw-r--r--   0 root         (0) root         (0)      341 2023-07-05 15:49:52.000000 stk-2023.7.5.0/src/stk/_internal/ea/evolutionary_algorithm/implementations/serial.py
+drwxr-xr-x   0 root         (0) root         (0)        0 2023-07-05 15:50:04.531074 stk-2023.7.5.0/src/stk/_internal/ea/fitness_calculators/
+-rw-r--r--   0 root         (0) root         (0)        1 2023-07-05 15:49:52.000000 stk-2023.7.5.0/src/stk/_internal/ea/fitness_calculators/__init__.py
+-rw-r--r--   0 root         (0) root         (0)      637 2023-07-05 15:49:52.000000 stk-2023.7.5.0/src/stk/_internal/ea/fitness_calculators/fitness_calculator.py
+-rw-r--r--   0 root         (0) root         (0)     9713 2023-07-05 15:49:52.000000 stk-2023.7.5.0/src/stk/_internal/ea/fitness_calculators/fitness_function.py
+-rw-r--r--   0 root         (0) root         (0)    11219 2023-07-05 15:49:52.000000 stk-2023.7.5.0/src/stk/_internal/ea/fitness_calculators/property_vector.py
+drwxr-xr-x   0 root         (0) root         (0)        0 2023-07-05 15:50:04.531074 stk-2023.7.5.0/src/stk/_internal/ea/fitness_normalizers/
+-rw-r--r--   0 root         (0) root         (0)        1 2023-07-05 15:49:52.000000 stk-2023.7.5.0/src/stk/_internal/ea/fitness_normalizers/__init__.py
+-rw-r--r--   0 root         (0) root         (0)     5818 2023-07-05 15:49:52.000000 stk-2023.7.5.0/src/stk/_internal/ea/fitness_normalizers/add.py
+-rw-r--r--   0 root         (0) root         (0)     5033 2023-07-05 15:49:52.000000 stk-2023.7.5.0/src/stk/_internal/ea/fitness_normalizers/divide_by_mean.py
+-rw-r--r--   0 root         (0) root         (0)     1007 2023-07-05 15:49:52.000000 stk-2023.7.5.0/src/stk/_internal/ea/fitness_normalizers/fitness_normalizer.py
+-rw-r--r--   0 root         (0) root         (0)     6010 2023-07-05 15:49:52.000000 stk-2023.7.5.0/src/stk/_internal/ea/fitness_normalizers/multiply.py
+-rw-r--r--   0 root         (0) root         (0)      367 2023-07-05 15:49:52.000000 stk-2023.7.5.0/src/stk/_internal/ea/fitness_normalizers/null.py
+-rw-r--r--   0 root         (0) root         (0)     7166 2023-07-05 15:49:52.000000 stk-2023.7.5.0/src/stk/_internal/ea/fitness_normalizers/power.py
+-rw-r--r--   0 root         (0) root         (0)     4105 2023-07-05 15:49:52.000000 stk-2023.7.5.0/src/stk/_internal/ea/fitness_normalizers/replace_fitness.py
+-rw-r--r--   0 root         (0) root         (0)     2004 2023-07-05 15:49:52.000000 stk-2023.7.5.0/src/stk/_internal/ea/fitness_normalizers/sequence.py
+-rw-r--r--   0 root         (0) root         (0)     7017 2023-07-05 15:49:52.000000 stk-2023.7.5.0/src/stk/_internal/ea/fitness_normalizers/shift_up.py
+-rw-r--r--   0 root         (0) root         (0)     4455 2023-07-05 15:49:52.000000 stk-2023.7.5.0/src/stk/_internal/ea/fitness_normalizers/sum.py
+-rw-r--r--   0 root         (0) root         (0)     1968 2023-07-05 15:49:52.000000 stk-2023.7.5.0/src/stk/_internal/ea/generation.py
+drwxr-xr-x   0 root         (0) root         (0)        0 2023-07-05 15:50:04.531074 stk-2023.7.5.0/src/stk/_internal/ea/molecule_records/
+-rw-r--r--   0 root         (0) root         (0)       32 2023-07-05 15:49:52.000000 stk-2023.7.5.0/src/stk/_internal/ea/molecule_records/__init__.py
+-rw-r--r--   0 root         (0) root         (0)     3583 2023-07-05 15:49:52.000000 stk-2023.7.5.0/src/stk/_internal/ea/molecule_records/molecule.py
+drwxr-xr-x   0 root         (0) root         (0)        0 2023-07-05 15:50:04.535075 stk-2023.7.5.0/src/stk/_internal/ea/mutation/
+-rw-r--r--   0 root         (0) root         (0)        1 2023-07-05 15:49:52.000000 stk-2023.7.5.0/src/stk/_internal/ea/mutation/__init__.py
+-rw-r--r--   0 root         (0) root         (0)      748 2023-07-05 15:49:52.000000 stk-2023.7.5.0/src/stk/_internal/ea/mutation/mutator.py
+-rw-r--r--   0 root         (0) root         (0)     5365 2023-07-05 15:49:52.000000 stk-2023.7.5.0/src/stk/_internal/ea/mutation/random.py
+-rw-r--r--   0 root         (0) root         (0)     4762 2023-07-05 15:49:52.000000 stk-2023.7.5.0/src/stk/_internal/ea/mutation/random_building_block.py
+-rw-r--r--   0 root         (0) root         (0)     3253 2023-07-05 15:49:52.000000 stk-2023.7.5.0/src/stk/_internal/ea/mutation/random_topology_graph.py
+-rw-r--r--   0 root         (0) root         (0)     1295 2023-07-05 15:49:52.000000 stk-2023.7.5.0/src/stk/_internal/ea/mutation/record.py
+-rw-r--r--   0 root         (0) root         (0)     7590 2023-07-05 15:49:52.000000 stk-2023.7.5.0/src/stk/_internal/ea/mutation/similar_building_block.py
+drwxr-xr-x   0 root         (0) root         (0)        0 2023-07-05 15:50:04.535075 stk-2023.7.5.0/src/stk/_internal/ea/plotters/
+-rw-r--r--   0 root         (0) root         (0)      243 2023-07-05 15:49:52.000000 stk-2023.7.5.0/src/stk/_internal/ea/plotters/__init__.py
+-rw-r--r--   0 root         (0) root         (0)    13994 2023-07-05 15:49:52.000000 stk-2023.7.5.0/src/stk/_internal/ea/plotters/progress.py
+-rw-r--r--   0 root         (0) root         (0)     7603 2023-07-05 15:49:52.000000 stk-2023.7.5.0/src/stk/_internal/ea/plotters/selection.py
+drwxr-xr-x   0 root         (0) root         (0)        0 2023-07-05 15:50:04.535075 stk-2023.7.5.0/src/stk/_internal/ea/selection/
+-rw-r--r--   0 root         (0) root         (0)        1 2023-07-05 15:49:52.000000 stk-2023.7.5.0/src/stk/_internal/ea/selection/__init__.py
+-rw-r--r--   0 root         (0) root         (0)     7886 2023-07-05 15:49:52.000000 stk-2023.7.5.0/src/stk/_internal/ea/selection/batch.py
+drwxr-xr-x   0 root         (0) root         (0)        0 2023-07-05 15:50:04.535075 stk-2023.7.5.0/src/stk/_internal/ea/selection/selectors/
+-rw-r--r--   0 root         (0) root         (0)        1 2023-07-05 15:49:52.000000 stk-2023.7.5.0/src/stk/_internal/ea/selection/selectors/__init__.py
+-rw-r--r--   0 root         (0) root         (0)     6845 2023-07-05 15:49:52.000000 stk-2023.7.5.0/src/stk/_internal/ea/selection/selectors/above_average.py
+-rw-r--r--   0 root         (0) root         (0)     5939 2023-07-05 15:49:52.000000 stk-2023.7.5.0/src/stk/_internal/ea/selection/selectors/best.py
+-rw-r--r--   0 root         (0) root         (0)     2397 2023-07-05 15:49:52.000000 stk-2023.7.5.0/src/stk/_internal/ea/selection/selectors/filter_batches.py
+-rw-r--r--   0 root         (0) root         (0)     2541 2023-07-05 15:49:52.000000 stk-2023.7.5.0/src/stk/_internal/ea/selection/selectors/filter_molecules.py
+-rw-r--r--   0 root         (0) root         (0)     2423 2023-07-05 15:49:52.000000 stk-2023.7.5.0/src/stk/_internal/ea/selection/selectors/remove_batches.py
+-rw-r--r--   0 root         (0) root         (0)     2629 2023-07-05 15:49:52.000000 stk-2023.7.5.0/src/stk/_internal/ea/selection/selectors/remove_molecules.py
+-rw-r--r--   0 root         (0) root         (0)     6006 2023-07-05 15:49:52.000000 stk-2023.7.5.0/src/stk/_internal/ea/selection/selectors/roulette.py
+-rw-r--r--   0 root         (0) root         (0)     7396 2023-07-05 15:49:52.000000 stk-2023.7.5.0/src/stk/_internal/ea/selection/selectors/selector.py
+-rw-r--r--   0 root         (0) root         (0)     7125 2023-07-05 15:49:52.000000 stk-2023.7.5.0/src/stk/_internal/ea/selection/selectors/stochastic_universal_sampling.py
+-rw-r--r--   0 root         (0) root         (0)     4934 2023-07-05 15:49:52.000000 stk-2023.7.5.0/src/stk/_internal/ea/selection/selectors/tournament.py
+drwxr-xr-x   0 root         (0) root         (0)        0 2023-07-05 15:50:04.535075 stk-2023.7.5.0/src/stk/_internal/ea/selection/selectors/utilities/
+-rw-r--r--   0 root         (0) root         (0)        1 2023-07-05 15:49:52.000000 stk-2023.7.5.0/src/stk/_internal/ea/selection/selectors/utilities/__init__.py
+-rw-r--r--   0 root         (0) root         (0)     3257 2023-07-05 15:49:52.000000 stk-2023.7.5.0/src/stk/_internal/ea/selection/selectors/utilities/yielded_batches.py
+-rw-r--r--   0 root         (0) root         (0)     3718 2023-07-05 15:49:52.000000 stk-2023.7.5.0/src/stk/_internal/ea/selection/selectors/worst.py
+-rw-r--r--   0 root         (0) root         (0)    25498 2023-07-05 15:49:52.000000 stk-2023.7.5.0/src/stk/_internal/elements.py
+drwxr-xr-x   0 root         (0) root         (0)        0 2023-07-05 15:50:04.539075 stk-2023.7.5.0/src/stk/_internal/functional_group_factories/
+-rw-r--r--   0 root         (0) root         (0)        1 2023-07-05 15:49:52.000000 stk-2023.7.5.0/src/stk/_internal/functional_group_factories/__init__.py
+-rw-r--r--   0 root         (0) root         (0)     4502 2023-07-05 15:49:52.000000 stk-2023.7.5.0/src/stk/_internal/functional_group_factories/alcohol_factory.py
+-rw-r--r--   0 root         (0) root         (0)     4376 2023-07-05 15:49:52.000000 stk-2023.7.5.0/src/stk/_internal/functional_group_factories/aldehyde_factory.py
+-rw-r--r--   0 root         (0) root         (0)     4485 2023-07-05 15:49:52.000000 stk-2023.7.5.0/src/stk/_internal/functional_group_factories/amide_factory.py
+-rw-r--r--   0 root         (0) root         (0)     4631 2023-07-05 15:49:52.000000 stk-2023.7.5.0/src/stk/_internal/functional_group_factories/boronic_acid_factory.py
+-rw-r--r--   0 root         (0) root         (0)     2699 2023-07-05 15:49:52.000000 stk-2023.7.5.0/src/stk/_internal/functional_group_factories/bromo_factory.py
+-rw-r--r--   0 root         (0) root         (0)     4534 2023-07-05 15:49:52.000000 stk-2023.7.5.0/src/stk/_internal/functional_group_factories/carboxylic_acid_factory.py
+-rw-r--r--   0 root         (0) root         (0)     4280 2023-07-05 15:49:52.000000 stk-2023.7.5.0/src/stk/_internal/functional_group_factories/dibromo_factory.py
+-rw-r--r--   0 root         (0) root         (0)     4297 2023-07-05 15:49:52.000000 stk-2023.7.5.0/src/stk/_internal/functional_group_factories/difluoro_factory.py
+-rw-r--r--   0 root         (0) root         (0)     4412 2023-07-05 15:49:52.000000 stk-2023.7.5.0/src/stk/_internal/functional_group_factories/diol_factory.py
+-rw-r--r--   0 root         (0) root         (0)     2730 2023-07-05 15:49:52.000000 stk-2023.7.5.0/src/stk/_internal/functional_group_factories/fluoro_factory.py
+-rw-r--r--   0 root         (0) root         (0)     3096 2023-07-05 15:49:52.000000 stk-2023.7.5.0/src/stk/_internal/functional_group_factories/functional_group_factory.py
+-rw-r--r--   0 root         (0) root         (0)     2702 2023-07-05 15:49:52.000000 stk-2023.7.5.0/src/stk/_internal/functional_group_factories/iodo_factory.py
+-rw-r--r--   0 root         (0) root         (0)     4602 2023-07-05 15:49:52.000000 stk-2023.7.5.0/src/stk/_internal/functional_group_factories/primary_amino_factory.py
+-rw-r--r--   0 root         (0) root         (0)     1326 2023-07-05 15:49:52.000000 stk-2023.7.5.0/src/stk/_internal/functional_group_factories/ring_amine_factory.py
+-rw-r--r--   0 root         (0) root         (0)     4411 2023-07-05 15:49:52.000000 stk-2023.7.5.0/src/stk/_internal/functional_group_factories/secondary_amino_factory.py
+-rw-r--r--   0 root         (0) root         (0)     3431 2023-07-05 15:49:52.000000 stk-2023.7.5.0/src/stk/_internal/functional_group_factories/smarts.py
+-rw-r--r--   0 root         (0) root         (0)     4479 2023-07-05 15:49:52.000000 stk-2023.7.5.0/src/stk/_internal/functional_group_factories/terminal_alkene_factory.py
+-rw-r--r--   0 root         (0) root         (0)     4154 2023-07-05 15:49:52.000000 stk-2023.7.5.0/src/stk/_internal/functional_group_factories/terminal_alkyne_factory.py
+-rw-r--r--   0 root         (0) root         (0)     4228 2023-07-05 15:49:52.000000 stk-2023.7.5.0/src/stk/_internal/functional_group_factories/thioacid_factory.py
+-rw-r--r--   0 root         (0) root         (0)     4386 2023-07-05 15:49:52.000000 stk-2023.7.5.0/src/stk/_internal/functional_group_factories/thiol_factory.py
+-rw-r--r--   0 root         (0) root         (0)      813 2023-07-05 15:49:52.000000 stk-2023.7.5.0/src/stk/_internal/functional_group_factories/utilities.py
+drwxr-xr-x   0 root         (0) root         (0)        0 2023-07-05 15:50:04.543074 stk-2023.7.5.0/src/stk/_internal/functional_groups/
+-rw-r--r--   0 root         (0) root         (0)        1 2023-07-05 15:49:52.000000 stk-2023.7.5.0/src/stk/_internal/functional_groups/__init__.py
+-rw-r--r--   0 root         (0) root         (0)     3224 2023-07-05 15:49:52.000000 stk-2023.7.5.0/src/stk/_internal/functional_groups/alcohol.py
+-rw-r--r--   0 root         (0) root         (0)     3730 2023-07-05 15:49:52.000000 stk-2023.7.5.0/src/stk/_internal/functional_groups/aldehyde.py
+-rw-r--r--   0 root         (0) root         (0)     4507 2023-07-05 15:49:52.000000 stk-2023.7.5.0/src/stk/_internal/functional_groups/alkene.py
+-rw-r--r--   0 root         (0) root         (0)     3581 2023-07-05 15:49:52.000000 stk-2023.7.5.0/src/stk/_internal/functional_groups/alkyne.py
+-rw-r--r--   0 root         (0) root         (0)     4815 2023-07-05 15:49:52.000000 stk-2023.7.5.0/src/stk/_internal/functional_groups/amide.py
+-rw-r--r--   0 root         (0) root         (0)     4869 2023-07-05 15:49:52.000000 stk-2023.7.5.0/src/stk/_internal/functional_groups/boronic_acid.py
+-rw-r--r--   0 root         (0) root         (0)     2545 2023-07-05 15:49:52.000000 stk-2023.7.5.0/src/stk/_internal/functional_groups/bromo.py
+-rw-r--r--   0 root         (0) root         (0)     3865 2023-07-05 15:49:52.000000 stk-2023.7.5.0/src/stk/_internal/functional_groups/carboxylic_acid.py
+-rw-r--r--   0 root         (0) root         (0)     3348 2023-07-05 15:49:52.000000 stk-2023.7.5.0/src/stk/_internal/functional_groups/dibromo.py
+-rw-r--r--   0 root         (0) root         (0)     3218 2023-07-05 15:49:52.000000 stk-2023.7.5.0/src/stk/_internal/functional_groups/difluoro.py
+-rw-r--r--   0 root         (0) root         (0)     4406 2023-07-05 15:49:52.000000 stk-2023.7.5.0/src/stk/_internal/functional_groups/diol.py
+-rw-r--r--   0 root         (0) root         (0)     2298 2023-07-05 15:49:52.000000 stk-2023.7.5.0/src/stk/_internal/functional_groups/fluoro.py
+-rw-r--r--   0 root         (0) root         (0)    11798 2023-07-05 15:49:52.000000 stk-2023.7.5.0/src/stk/_internal/functional_groups/functional_group.py
+-rw-r--r--   0 root         (0) root         (0)     4825 2023-07-05 15:49:52.000000 stk-2023.7.5.0/src/stk/_internal/functional_groups/generic_functional_group.py
+-rw-r--r--   0 root         (0) root         (0)     2200 2023-07-05 15:49:52.000000 stk-2023.7.5.0/src/stk/_internal/functional_groups/iodo.py
+-rw-r--r--   0 root         (0) root         (0)     3453 2023-07-05 15:49:52.000000 stk-2023.7.5.0/src/stk/_internal/functional_groups/primary_amino.py
+-rw-r--r--   0 root         (0) root         (0)     4671 2023-07-05 15:49:52.000000 stk-2023.7.5.0/src/stk/_internal/functional_groups/ring_amine.py
+-rw-r--r--   0 root         (0) root         (0)     3382 2023-07-05 15:49:52.000000 stk-2023.7.5.0/src/stk/_internal/functional_groups/secondary_amino.py
+-rw-r--r--   0 root         (0) root         (0)     1223 2023-07-05 15:49:52.000000 stk-2023.7.5.0/src/stk/_internal/functional_groups/single_atom.py
+-rw-r--r--   0 root         (0) root         (0)     3818 2023-07-05 15:49:52.000000 stk-2023.7.5.0/src/stk/_internal/functional_groups/thioacid.py
+-rw-r--r--   0 root         (0) root         (0)     2787 2023-07-05 15:49:52.000000 stk-2023.7.5.0/src/stk/_internal/functional_groups/thiol.py
+drwxr-xr-x   0 root         (0) root         (0)        0 2023-07-05 15:50:04.543074 stk-2023.7.5.0/src/stk/_internal/json_serde/
+-rw-r--r--   0 root         (0) root         (0)        1 2023-07-05 15:49:52.000000 stk-2023.7.5.0/src/stk/_internal/json_serde/__init__.py
+-rw-r--r--   0 root         (0) root         (0)     9926 2023-07-05 15:49:52.000000 stk-2023.7.5.0/src/stk/_internal/json_serde/constructed_molecule.py
+-rw-r--r--   0 root         (0) root         (0)     6009 2023-07-05 15:49:52.000000 stk-2023.7.5.0/src/stk/_internal/json_serde/molecule.py
+-rw-r--r--   0 root         (0) root         (0)     2164 2023-07-05 15:49:52.000000 stk-2023.7.5.0/src/stk/_internal/json_serde/utilities.py
+drwxr-xr-x   0 root         (0) root         (0)        0 2023-07-05 15:50:04.543074 stk-2023.7.5.0/src/stk/_internal/key_makers/
+-rw-r--r--   0 root         (0) root         (0)        1 2023-07-05 15:49:52.000000 stk-2023.7.5.0/src/stk/_internal/key_makers/__init__.py
+-rw-r--r--   0 root         (0) root         (0)     1702 2023-07-05 15:49:52.000000 stk-2023.7.5.0/src/stk/_internal/key_makers/inchi.py
+-rw-r--r--   0 root         (0) root         (0)     1532 2023-07-05 15:49:52.000000 stk-2023.7.5.0/src/stk/_internal/key_makers/inchi_key.py
+-rw-r--r--   0 root         (0) root         (0)     3164 2023-07-05 15:49:52.000000 stk-2023.7.5.0/src/stk/_internal/key_makers/molecule.py
+-rw-r--r--   0 root         (0) root         (0)     1335 2023-07-05 15:49:52.000000 stk-2023.7.5.0/src/stk/_internal/key_makers/smiles.py
+-rw-r--r--   0 root         (0) root         (0)     1677 2023-07-05 15:49:52.000000 stk-2023.7.5.0/src/stk/_internal/key_makers/utilities.py
+-rw-r--r--   0 root         (0) root         (0)    25466 2023-07-05 15:49:52.000000 stk-2023.7.5.0/src/stk/_internal/molecule.py
+drwxr-xr-x   0 root         (0) root         (0)        0 2023-07-05 15:50:04.543074 stk-2023.7.5.0/src/stk/_internal/optimizers/
+-rw-r--r--   0 root         (0) root         (0)        1 2023-07-05 15:49:52.000000 stk-2023.7.5.0/src/stk/_internal/optimizers/__init__.py
+-rw-r--r--   0 root         (0) root         (0)     3205 2023-07-05 15:49:52.000000 stk-2023.7.5.0/src/stk/_internal/optimizers/collapser.py
+-rw-r--r--   0 root         (0) root         (0)     4581 2023-07-05 15:49:52.000000 stk-2023.7.5.0/src/stk/_internal/optimizers/mchammer.py
+-rw-r--r--   0 root         (0) root         (0)      215 2023-07-05 15:49:52.000000 stk-2023.7.5.0/src/stk/_internal/optimizers/null.py
+-rw-r--r--   0 root         (0) root         (0)      632 2023-07-05 15:49:52.000000 stk-2023.7.5.0/src/stk/_internal/optimizers/optimizer.py
+-rw-r--r--   0 root         (0) root         (0)     3839 2023-07-05 15:49:52.000000 stk-2023.7.5.0/src/stk/_internal/optimizers/periodic_collapser.py
+-rw-r--r--   0 root         (0) root         (0)     4456 2023-07-05 15:49:52.000000 stk-2023.7.5.0/src/stk/_internal/optimizers/spinner.py
+-rw-r--r--   0 root         (0) root         (0)     2118 2023-07-05 15:49:52.000000 stk-2023.7.5.0/src/stk/_internal/optimizers/utilities.py
+-rw-r--r--   0 root         (0) root         (0)     4960 2023-07-05 15:49:52.000000 stk-2023.7.5.0/src/stk/_internal/periodic_info.py
+drwxr-xr-x   0 root         (0) root         (0)        0 2023-07-05 15:50:04.547074 stk-2023.7.5.0/src/stk/_internal/reaction_factories/
+-rw-r--r--   0 root         (0) root         (0)        1 2023-07-05 15:49:52.000000 stk-2023.7.5.0/src/stk/_internal/reaction_factories/__init__.py
+-rw-r--r--   0 root         (0) root         (0)     1352 2023-07-05 15:49:52.000000 stk-2023.7.5.0/src/stk/_internal/reaction_factories/dative_reaction_factory.py
+-rw-r--r--   0 root         (0) root         (0)     6034 2023-07-05 15:49:52.000000 stk-2023.7.5.0/src/stk/_internal/reaction_factories/generic_reaction_factory.py
+-rw-r--r--   0 root         (0) root         (0)     1488 2023-07-05 15:49:52.000000 stk-2023.7.5.0/src/stk/_internal/reaction_factories/reaction_factory.py
+drwxr-xr-x   0 root         (0) root         (0)        0 2023-07-05 15:50:04.547074 stk-2023.7.5.0/src/stk/_internal/reactions/
+-rw-r--r--   0 root         (0) root         (0)        1 2023-07-05 15:49:52.000000 stk-2023.7.5.0/src/stk/_internal/reactions/__init__.py
+drwxr-xr-x   0 root         (0) root         (0)        0 2023-07-05 15:50:04.547074 stk-2023.7.5.0/src/stk/_internal/reactions/dative_reaction/
+-rw-r--r--   0 root         (0) root         (0)        1 2023-07-05 15:49:52.000000 stk-2023.7.5.0/src/stk/_internal/reactions/dative_reaction/__init__.py
+-rw-r--r--   0 root         (0) root         (0)     1416 2023-07-05 15:49:52.000000 stk-2023.7.5.0/src/stk/_internal/reactions/dative_reaction/dative_reaction.py
+-rw-r--r--   0 root         (0) root         (0)      497 2023-07-05 15:49:52.000000 stk-2023.7.5.0/src/stk/_internal/reactions/dative_reaction/utilities.py
+-rw-r--r--   0 root         (0) root         (0)     1826 2023-07-05 15:49:52.000000 stk-2023.7.5.0/src/stk/_internal/reactions/one_one_reaction.py
+-rw-r--r--   0 root         (0) root         (0)     1992 2023-07-05 15:49:52.000000 stk-2023.7.5.0/src/stk/_internal/reactions/one_two_reaction.py
+drwxr-xr-x   0 root         (0) root         (0)        0 2023-07-05 15:50:04.547074 stk-2023.7.5.0/src/stk/_internal/reactions/reaction/
+-rw-r--r--   0 root         (0) root         (0)        1 2023-07-05 15:49:52.000000 stk-2023.7.5.0/src/stk/_internal/reactions/reaction/__init__.py
+-rw-r--r--   0 root         (0) root         (0)     2011 2023-07-05 15:49:52.000000 stk-2023.7.5.0/src/stk/_internal/reactions/reaction/new_atom.py
+-rw-r--r--   0 root         (0) root         (0)     3615 2023-07-05 15:49:52.000000 stk-2023.7.5.0/src/stk/_internal/reactions/reaction/reaction.py
+-rw-r--r--   0 root         (0) root         (0)     2098 2023-07-05 15:49:52.000000 stk-2023.7.5.0/src/stk/_internal/reactions/reaction/reaction_result.py
+-rw-r--r--   0 root         (0) root         (0)     3803 2023-07-05 15:49:52.000000 stk-2023.7.5.0/src/stk/_internal/reactions/ring_amine_reaction.py
+-rw-r--r--   0 root         (0) root         (0)     2925 2023-07-05 15:49:52.000000 stk-2023.7.5.0/src/stk/_internal/reactions/two_two_reaction.py
+drwxr-xr-x   0 root         (0) root         (0)        0 2023-07-05 15:50:04.547074 stk-2023.7.5.0/src/stk/_internal/topology_graphs/
+-rw-r--r--   0 root         (0) root         (0)        1 2023-07-05 15:49:52.000000 stk-2023.7.5.0/src/stk/_internal/topology_graphs/__init__.py
+drwxr-xr-x   0 root         (0) root         (0)        0 2023-07-05 15:50:04.551074 stk-2023.7.5.0/src/stk/_internal/topology_graphs/cage/
+-rw-r--r--   0 root         (0) root         (0)        1 2023-07-05 15:49:52.000000 stk-2023.7.5.0/src/stk/_internal/topology_graphs/cage/__init__.py
+-rw-r--r--   0 root         (0) root         (0)    42840 2023-07-05 15:49:52.000000 stk-2023.7.5.0/src/stk/_internal/topology_graphs/cage/cage.py
+-rw-r--r--   0 root         (0) root         (0)     8079 2023-07-05 15:49:52.000000 stk-2023.7.5.0/src/stk/_internal/topology_graphs/cage/cage_construction_state.py
+-rw-r--r--   0 root         (0) root         (0)     8062 2023-07-05 15:49:52.000000 stk-2023.7.5.0/src/stk/_internal/topology_graphs/cage/eight_plus_sixteen.py
+-rw-r--r--   0 root         (0) root         (0)     6824 2023-07-05 15:49:52.000000 stk-2023.7.5.0/src/stk/_internal/topology_graphs/cage/eight_plus_twelve.py
+-rw-r--r--   0 root         (0) root         (0)     5631 2023-07-05 15:49:52.000000 stk-2023.7.5.0/src/stk/_internal/topology_graphs/cage/five_plus_ten.py
+-rw-r--r--   0 root         (0) root         (0)     5034 2023-07-05 15:49:52.000000 stk-2023.7.5.0/src/stk/_internal/topology_graphs/cage/four_plus_eight.py
+-rw-r--r--   0 root         (0) root         (0)     4120 2023-07-05 15:49:52.000000 stk-2023.7.5.0/src/stk/_internal/topology_graphs/cage/four_plus_four.py
+-rw-r--r--   0 root         (0) root         (0)     4907 2023-07-05 15:49:52.000000 stk-2023.7.5.0/src/stk/_internal/topology_graphs/cage/four_plus_six.py
+-rw-r--r--   0 root         (0) root         (0)     4780 2023-07-05 15:49:52.000000 stk-2023.7.5.0/src/stk/_internal/topology_graphs/cage/four_plus_six_2.py
+-rw-r--r--   0 root         (0) root         (0)     7536 2023-07-05 15:49:52.000000 stk-2023.7.5.0/src/stk/_internal/topology_graphs/cage/m12l24.py
+-rw-r--r--   0 root         (0) root         (0)    13449 2023-07-05 15:49:52.000000 stk-2023.7.5.0/src/stk/_internal/topology_graphs/cage/m24l48.py
+-rw-r--r--   0 root         (0) root         (0)     5151 2023-07-05 15:49:52.000000 stk-2023.7.5.0/src/stk/_internal/topology_graphs/cage/m2l4_lantern.py
+-rw-r--r--   0 root         (0) root         (0)     8175 2023-07-05 15:49:52.000000 stk-2023.7.5.0/src/stk/_internal/topology_graphs/cage/m3l3_triangle.py
+-rw-r--r--   0 root         (0) root         (0)     7429 2023-07-05 15:49:52.000000 stk-2023.7.5.0/src/stk/_internal/topology_graphs/cage/m3l6.py
+-rw-r--r--   0 root         (0) root         (0)     7982 2023-07-05 15:49:52.000000 stk-2023.7.5.0/src/stk/_internal/topology_graphs/cage/m4l4_square.py
+-rw-r--r--   0 root         (0) root         (0)     7987 2023-07-05 15:49:52.000000 stk-2023.7.5.0/src/stk/_internal/topology_graphs/cage/m4l4_tetrahedron.py
+-rw-r--r--   0 root         (0) root         (0)     9248 2023-07-05 15:49:52.000000 stk-2023.7.5.0/src/stk/_internal/topology_graphs/cage/m4l6_tetrahedron.py
+-rw-r--r--   0 root         (0) root         (0)     8786 2023-07-05 15:49:52.000000 stk-2023.7.5.0/src/stk/_internal/topology_graphs/cage/m4l6_tetrahedron_spacer.py
+-rw-r--r--   0 root         (0) root         (0)     5904 2023-07-05 15:49:52.000000 stk-2023.7.5.0/src/stk/_internal/topology_graphs/cage/m4l8.py
+-rw-r--r--   0 root         (0) root         (0)     6744 2023-07-05 15:49:52.000000 stk-2023.7.5.0/src/stk/_internal/topology_graphs/cage/m6l12_cube.py
+-rw-r--r--   0 root         (0) root         (0)     9469 2023-07-05 15:49:52.000000 stk-2023.7.5.0/src/stk/_internal/topology_graphs/cage/m6l2l3_prism.py
+-rw-r--r--   0 root         (0) root         (0)     9502 2023-07-05 15:49:52.000000 stk-2023.7.5.0/src/stk/_internal/topology_graphs/cage/m8l6_cube.py
+-rw-r--r--   0 root         (0) root         (0)     6066 2023-07-05 15:49:52.000000 stk-2023.7.5.0/src/stk/_internal/topology_graphs/cage/one_plus_one.py
+-rw-r--r--   0 root         (0) root         (0)     6788 2023-07-05 15:49:52.000000 stk-2023.7.5.0/src/stk/_internal/topology_graphs/cage/six_plus_eight.py
+-rw-r--r--   0 root         (0) root         (0)     6089 2023-07-05 15:49:52.000000 stk-2023.7.5.0/src/stk/_internal/topology_graphs/cage/six_plus_nine.py
+-rw-r--r--   0 root         (0) root         (0)     6684 2023-07-05 15:49:52.000000 stk-2023.7.5.0/src/stk/_internal/topology_graphs/cage/six_plus_twelve.py
+-rw-r--r--   0 root         (0) root         (0)     8949 2023-07-05 15:49:52.000000 stk-2023.7.5.0/src/stk/_internal/topology_graphs/cage/ten_plus_twenty.py
+-rw-r--r--   0 root         (0) root         (0)     4697 2023-07-05 15:49:52.000000 stk-2023.7.5.0/src/stk/_internal/topology_graphs/cage/three_plus_six.py
+-rw-r--r--   0 root         (0) root         (0)    11770 2023-07-05 15:49:52.000000 stk-2023.7.5.0/src/stk/_internal/topology_graphs/cage/twelve_plus_thirty.py
+-rw-r--r--   0 root         (0) root         (0)    10975 2023-07-05 15:49:52.000000 stk-2023.7.5.0/src/stk/_internal/topology_graphs/cage/twenty_plus_thirty.py
+-rw-r--r--   0 root         (0) root         (0)     4234 2023-07-05 15:49:52.000000 stk-2023.7.5.0/src/stk/_internal/topology_graphs/cage/two_plus_four.py
+-rw-r--r--   0 root         (0) root         (0)     4044 2023-07-05 15:49:52.000000 stk-2023.7.5.0/src/stk/_internal/topology_graphs/cage/two_plus_three.py
+-rw-r--r--   0 root         (0) root         (0)     3635 2023-07-05 15:49:52.000000 stk-2023.7.5.0/src/stk/_internal/topology_graphs/cage/two_plus_two.py
+-rw-r--r--   0 root         (0) root         (0)    11358 2023-07-05 15:49:52.000000 stk-2023.7.5.0/src/stk/_internal/topology_graphs/cage/vertices.py
+drwxr-xr-x   0 root         (0) root         (0)        0 2023-07-05 15:50:04.555074 stk-2023.7.5.0/src/stk/_internal/topology_graphs/cof/
+-rw-r--r--   0 root         (0) root         (0)      412 2023-07-05 15:49:52.000000 stk-2023.7.5.0/src/stk/_internal/topology_graphs/cof/__init__.py
+-rw-r--r--   0 root         (0) root         (0)    27030 2023-07-05 15:49:52.000000 stk-2023.7.5.0/src/stk/_internal/topology_graphs/cof/cof.py
+-rw-r--r--   0 root         (0) root         (0)     1934 2023-07-05 15:49:52.000000 stk-2023.7.5.0/src/stk/_internal/topology_graphs/cof/edge.py
+-rw-r--r--   0 root         (0) root         (0)     8245 2023-07-05 15:49:52.000000 stk-2023.7.5.0/src/stk/_internal/topology_graphs/cof/hexagonal.py
+-rw-r--r--   0 root         (0) root         (0)     4890 2023-07-05 15:49:52.000000 stk-2023.7.5.0/src/stk/_internal/topology_graphs/cof/honeycomb.py
+-rw-r--r--   0 root         (0) root         (0)     6100 2023-07-05 15:49:52.000000 stk-2023.7.5.0/src/stk/_internal/topology_graphs/cof/kagome.py
+-rw-r--r--   0 root         (0) root         (0)     3904 2023-07-05 15:49:52.000000 stk-2023.7.5.0/src/stk/_internal/topology_graphs/cof/linkerless_honeycomb.py
+-rw-r--r--   0 root         (0) root         (0)    12091 2023-07-05 15:49:52.000000 stk-2023.7.5.0/src/stk/_internal/topology_graphs/cof/periodic_hexagonal.py
+-rw-r--r--   0 root         (0) root         (0)     8737 2023-07-05 15:49:52.000000 stk-2023.7.5.0/src/stk/_internal/topology_graphs/cof/periodic_honeycomb.py
+-rw-r--r--   0 root         (0) root         (0)    10199 2023-07-05 15:49:52.000000 stk-2023.7.5.0/src/stk/_internal/topology_graphs/cof/periodic_kagome.py
+-rw-r--r--   0 root         (0) root         (0)     7760 2023-07-05 15:49:52.000000 stk-2023.7.5.0/src/stk/_internal/topology_graphs/cof/periodic_linkerless_honeycomb.py
+-rw-r--r--   0 root         (0) root         (0)     8551 2023-07-05 15:49:52.000000 stk-2023.7.5.0/src/stk/_internal/topology_graphs/cof/periodic_square.py
+-rw-r--r--   0 root         (0) root         (0)     4851 2023-07-05 15:49:52.000000 stk-2023.7.5.0/src/stk/_internal/topology_graphs/cof/square.py
+-rw-r--r--   0 root         (0) root         (0)    11377 2023-07-05 15:49:52.000000 stk-2023.7.5.0/src/stk/_internal/topology_graphs/cof/vertices.py
+-rw-r--r--   0 root         (0) root         (0)     5569 2023-07-05 15:49:52.000000 stk-2023.7.5.0/src/stk/_internal/topology_graphs/edge.py
+-rw-r--r--   0 root         (0) root         (0)      887 2023-07-05 15:49:52.000000 stk-2023.7.5.0/src/stk/_internal/topology_graphs/edge_group.py
+drwxr-xr-x   0 root         (0) root         (0)        0 2023-07-05 15:50:04.555074 stk-2023.7.5.0/src/stk/_internal/topology_graphs/host_guest/
+-rw-r--r--   0 root         (0) root         (0)       62 2023-07-05 15:49:52.000000 stk-2023.7.5.0/src/stk/_internal/topology_graphs/host_guest/__init__.py
+-rw-r--r--   0 root         (0) root         (0)    17325 2023-07-05 15:49:52.000000 stk-2023.7.5.0/src/stk/_internal/topology_graphs/host_guest/complex.py
+-rw-r--r--   0 root         (0) root         (0)     2157 2023-07-05 15:49:52.000000 stk-2023.7.5.0/src/stk/_internal/topology_graphs/host_guest/vertices.py
+drwxr-xr-x   0 root         (0) root         (0)        0 2023-07-05 15:50:04.555074 stk-2023.7.5.0/src/stk/_internal/topology_graphs/macrocycle/
+-rw-r--r--   0 root         (0) root         (0)       65 2023-07-05 15:49:52.000000 stk-2023.7.5.0/src/stk/_internal/topology_graphs/macrocycle/__init__.py
+-rw-r--r--   0 root         (0) root         (0)    18837 2023-07-05 15:49:52.000000 stk-2023.7.5.0/src/stk/_internal/topology_graphs/macrocycle/macrocycle.py
+-rw-r--r--   0 root         (0) root         (0)     3688 2023-07-05 15:49:52.000000 stk-2023.7.5.0/src/stk/_internal/topology_graphs/macrocycle/vertices.py
+drwxr-xr-x   0 root         (0) root         (0)        0 2023-07-05 15:50:04.559074 stk-2023.7.5.0/src/stk/_internal/topology_graphs/metal_complex/
+-rw-r--r--   0 root         (0) root         (0)      207 2023-07-05 15:49:52.000000 stk-2023.7.5.0/src/stk/_internal/topology_graphs/metal_complex/__init__.py
+-rw-r--r--   0 root         (0) root         (0)     3322 2023-07-05 15:49:52.000000 stk-2023.7.5.0/src/stk/_internal/topology_graphs/metal_complex/bidentate_square_planar.py
+-rw-r--r--   0 root         (0) root         (0)     2919 2023-07-05 15:49:52.000000 stk-2023.7.5.0/src/stk/_internal/topology_graphs/metal_complex/cis_protected_square_planar.py
+-rw-r--r--   0 root         (0) root         (0)    26537 2023-07-05 15:49:52.000000 stk-2023.7.5.0/src/stk/_internal/topology_graphs/metal_complex/metal_complex.py
+-rw-r--r--   0 root         (0) root         (0)     3627 2023-07-05 15:49:52.000000 stk-2023.7.5.0/src/stk/_internal/topology_graphs/metal_complex/octahedral.py
+-rw-r--r--   0 root         (0) root         (0)     3944 2023-07-05 15:49:52.000000 stk-2023.7.5.0/src/stk/_internal/topology_graphs/metal_complex/octahedral_delta.py
+-rw-r--r--   0 root         (0) root         (0)     3948 2023-07-05 15:49:52.000000 stk-2023.7.5.0/src/stk/_internal/topology_graphs/metal_complex/octahedral_lambda.py
+-rw-r--r--   0 root         (0) root         (0)     4728 2023-07-05 15:49:52.000000 stk-2023.7.5.0/src/stk/_internal/topology_graphs/metal_complex/paddlewheel.py
+-rw-r--r--   0 root         (0) root         (0)     3290 2023-07-05 15:49:52.000000 stk-2023.7.5.0/src/stk/_internal/topology_graphs/metal_complex/porphyrin.py
+-rw-r--r--   0 root         (0) root         (0)     3269 2023-07-05 15:49:52.000000 stk-2023.7.5.0/src/stk/_internal/topology_graphs/metal_complex/square_planar.py
+-rw-r--r--   0 root         (0) root         (0)     4667 2023-07-05 15:49:52.000000 stk-2023.7.5.0/src/stk/_internal/topology_graphs/metal_complex/vertices.py
+drwxr-xr-x   0 root         (0) root         (0)        0 2023-07-05 15:50:04.559074 stk-2023.7.5.0/src/stk/_internal/topology_graphs/polymer/
+-rw-r--r--   0 root         (0) root         (0)       46 2023-07-05 15:49:52.000000 stk-2023.7.5.0/src/stk/_internal/topology_graphs/polymer/__init__.py
+drwxr-xr-x   0 root         (0) root         (0)        0 2023-07-05 15:50:04.559074 stk-2023.7.5.0/src/stk/_internal/topology_graphs/polymer/linear/
+-rw-r--r--   0 root         (0) root         (0)        1 2023-07-05 15:49:52.000000 stk-2023.7.5.0/src/stk/_internal/topology_graphs/polymer/linear/__init__.py
+-rw-r--r--   0 root         (0) root         (0)    24349 2023-07-05 15:49:52.000000 stk-2023.7.5.0/src/stk/_internal/topology_graphs/polymer/linear/linear.py
+-rw-r--r--   0 root         (0) root         (0)     6057 2023-07-05 15:49:52.000000 stk-2023.7.5.0/src/stk/_internal/topology_graphs/polymer/linear/vertices.py
+drwxr-xr-x   0 root         (0) root         (0)        0 2023-07-05 15:50:04.559074 stk-2023.7.5.0/src/stk/_internal/topology_graphs/rotaxane/
+-rw-r--r--   0 root         (0) root         (0)      116 2023-07-05 15:49:52.000000 stk-2023.7.5.0/src/stk/_internal/topology_graphs/rotaxane/__init__.py
+-rw-r--r--   0 root         (0) root         (0)    20644 2023-07-05 15:49:52.000000 stk-2023.7.5.0/src/stk/_internal/topology_graphs/rotaxane/nrotaxane.py
+-rw-r--r--   0 root         (0) root         (0)     2281 2023-07-05 15:49:52.000000 stk-2023.7.5.0/src/stk/_internal/topology_graphs/rotaxane/vertices.py
+drwxr-xr-x   0 root         (0) root         (0)        0 2023-07-05 15:50:04.559074 stk-2023.7.5.0/src/stk/_internal/topology_graphs/topology_graph/
+-rw-r--r--   0 root         (0) root         (0)        1 2023-07-05 15:49:52.000000 stk-2023.7.5.0/src/stk/_internal/topology_graphs/topology_graph/__init__.py
+-rw-r--r--   0 root         (0) root         (0)     2131 2023-07-05 15:49:52.000000 stk-2023.7.5.0/src/stk/_internal/topology_graphs/topology_graph/parallel.py
+-rw-r--r--   0 root         (0) root         (0)     1794 2023-07-05 15:49:52.000000 stk-2023.7.5.0/src/stk/_internal/topology_graphs/topology_graph/serial.py
+-rw-r--r--   0 root         (0) root         (0)    19701 2023-07-05 15:49:52.000000 stk-2023.7.5.0/src/stk/_internal/topology_graphs/topology_graph/topology_graph.py
+-rw-r--r--   0 root         (0) root         (0)     2579 2023-07-05 15:49:52.000000 stk-2023.7.5.0/src/stk/_internal/topology_graphs/topology_graph/utilities.py
+drwxr-xr-x   0 root         (0) root         (0)        0 2023-07-05 15:50:04.559074 stk-2023.7.5.0/src/stk/_internal/topology_graphs/utilities/
+-rw-r--r--   0 root         (0) root         (0)      113 2023-07-05 15:49:52.000000 stk-2023.7.5.0/src/stk/_internal/topology_graphs/utilities/__init__.py
+-rw-r--r--   0 root         (0) root         (0)     1124 2023-07-05 15:49:52.000000 stk-2023.7.5.0/src/stk/_internal/topology_graphs/utilities/edge_sorter.py
+-rw-r--r--   0 root         (0) root         (0)     1949 2023-07-05 15:49:52.000000 stk-2023.7.5.0/src/stk/_internal/topology_graphs/utilities/functional_group_sorter.py
+-rw-r--r--   0 root         (0) root         (0)     2389 2023-07-05 15:49:52.000000 stk-2023.7.5.0/src/stk/_internal/topology_graphs/utilities/sorter.py
+-rw-r--r--   0 root         (0) root         (0)     5099 2023-07-05 15:49:52.000000 stk-2023.7.5.0/src/stk/_internal/topology_graphs/vertex.py
+drwxr-xr-x   0 root         (0) root         (0)        0 2023-07-05 15:50:04.559074 stk-2023.7.5.0/src/stk/_internal/utilities/
+-rw-r--r--   0 root         (0) root         (0)        1 2023-07-05 15:49:52.000000 stk-2023.7.5.0/src/stk/_internal/utilities/__init__.py
+-rw-r--r--   0 root         (0) root         (0)      772 2023-07-05 15:49:52.000000 stk-2023.7.5.0/src/stk/_internal/utilities/molecule.py
+drwxr-xr-x   0 root         (0) root         (0)        0 2023-07-05 15:50:04.559074 stk-2023.7.5.0/src/stk/_internal/utilities/updaters/
+-rw-r--r--   0 root         (0) root         (0)        1 2023-07-05 15:49:52.000000 stk-2023.7.5.0/src/stk/_internal/utilities/updaters/__init__.py
+-rw-r--r--   0 root         (0) root         (0)      598 2023-07-05 15:49:52.000000 stk-2023.7.5.0/src/stk/_internal/utilities/updaters/mae.py
+-rw-r--r--   0 root         (0) root         (0)      745 2023-07-05 15:49:52.000000 stk-2023.7.5.0/src/stk/_internal/utilities/updaters/mdl_mol.py
+-rw-r--r--   0 root         (0) root         (0)      737 2023-07-05 15:49:52.000000 stk-2023.7.5.0/src/stk/_internal/utilities/updaters/pdb.py
+-rw-r--r--   0 root         (0) root         (0)     5796 2023-07-05 15:49:52.000000 stk-2023.7.5.0/src/stk/_internal/utilities/updaters/turbomole.py
+-rw-r--r--   0 root         (0) root         (0)     2086 2023-07-05 15:49:52.000000 stk-2023.7.5.0/src/stk/_internal/utilities/updaters/xyz.py
+-rw-r--r--   0 root         (0) root         (0)    23774 2023-07-05 15:49:52.000000 stk-2023.7.5.0/src/stk/_internal/utilities/utilities.py
+drwxr-xr-x   0 root         (0) root         (0)        0 2023-07-05 15:50:04.563074 stk-2023.7.5.0/src/stk/_internal/utilities/writers/
+-rw-r--r--   0 root         (0) root         (0)        1 2023-07-05 15:49:52.000000 stk-2023.7.5.0/src/stk/_internal/utilities/writers/__init__.py
+-rw-r--r--   0 root         (0) root         (0)     2729 2023-07-05 15:49:52.000000 stk-2023.7.5.0/src/stk/_internal/utilities/writers/mdl_mol.py
+-rw-r--r--   0 root         (0) root         (0)     2065 2023-07-05 15:49:52.000000 stk-2023.7.5.0/src/stk/_internal/utilities/writers/pdb.py
+-rw-r--r--   0 root         (0) root         (0)     1093 2023-07-05 15:49:52.000000 stk-2023.7.5.0/src/stk/_internal/utilities/writers/xyz.py
+drwxr-xr-x   0 root         (0) root         (0)        0 2023-07-05 15:50:04.563074 stk-2023.7.5.0/src/stk/_internal/writers/
+-rw-r--r--   0 root         (0) root         (0)        1 2023-07-05 15:49:52.000000 stk-2023.7.5.0/src/stk/_internal/writers/__init__.py
+-rw-r--r--   0 root         (0) root         (0)     4156 2023-07-05 15:49:52.000000 stk-2023.7.5.0/src/stk/_internal/writers/mdl_mol.py
+-rw-r--r--   0 root         (0) root         (0)     6082 2023-07-05 15:49:52.000000 stk-2023.7.5.0/src/stk/_internal/writers/pdb.py
+-rw-r--r--   0 root         (0) root         (0)     5051 2023-07-05 15:49:52.000000 stk-2023.7.5.0/src/stk/_internal/writers/turbomole.py
+-rw-r--r--   0 root         (0) root         (0)     2904 2023-07-05 15:49:52.000000 stk-2023.7.5.0/src/stk/_internal/writers/xyz.py
+-rw-r--r--   0 root         (0) root         (0)      171 2023-07-05 15:50:04.000000 stk-2023.7.5.0/src/stk/_version.py
+-rw-r--r--   0 root         (0) root         (0)     3243 2023-07-05 15:49:52.000000 stk-2023.7.5.0/src/stk/cage.py
+-rw-r--r--   0 root         (0) root         (0)     1363 2023-07-05 15:49:52.000000 stk-2023.7.5.0/src/stk/cof.py
+-rw-r--r--   0 root         (0) root         (0)      255 2023-07-05 15:49:52.000000 stk-2023.7.5.0/src/stk/host_guest.py
+-rw-r--r--   0 root         (0) root         (0)      190 2023-07-05 15:49:52.000000 stk-2023.7.5.0/src/stk/macrocycle.py
+-rw-r--r--   0 root         (0) root         (0)     1299 2023-07-05 15:49:52.000000 stk-2023.7.5.0/src/stk/metal_complex.py
+-rw-r--r--   0 root         (0) root         (0)      322 2023-07-05 15:49:52.000000 stk-2023.7.5.0/src/stk/polymer.py
+-rw-r--r--   0 root         (0) root         (0)      237 2023-07-05 15:49:52.000000 stk-2023.7.5.0/src/stk/rotaxane.py
+drwxr-xr-x   0 root         (0) root         (0)        0 2023-07-05 15:50:04.523074 stk-2023.7.5.0/src/stk.egg-info/
+-rw-r--r--   0 root         (0) root         (0)     6103 2023-07-05 15:50:04.000000 stk-2023.7.5.0/src/stk.egg-info/PKG-INFO
+-rw-r--r--   0 root         (0) root         (0)    15113 2023-07-05 15:50:04.000000 stk-2023.7.5.0/src/stk.egg-info/SOURCES.txt
+-rw-r--r--   0 root         (0) root         (0)        1 2023-07-05 15:50:04.000000 stk-2023.7.5.0/src/stk.egg-info/dependency_links.txt
+-rw-r--r--   0 root         (0) root         (0)      246 2023-07-05 15:50:04.000000 stk-2023.7.5.0/src/stk.egg-info/requires.txt
+-rw-r--r--   0 root         (0) root         (0)        4 2023-07-05 15:50:04.000000 stk-2023.7.5.0/src/stk.egg-info/top_level.txt
```

### Comparing `stk-2022.6.17.0/README.rst` & `stk-2023.7.5.0/README.rst`

 * *Files 12% similar despite different names*

```diff
@@ -1,14 +1,14 @@
 :maintainers:
     `lukasturcani <https://github.com/lukasturcani/>`_,
     `andrewtarzia <https://github.com/andrewtarzia/>`_
 :documentation: https://stk.readthedocs.io
 :discord: https://discord.gg/zbCUzuxe2B
 
-.. figure:: docs/source/figures/stk.png
+.. figure:: docs/source/_static/stk.png
 
 .. image:: https://github.com/lukasturcani/stk/workflows/tests/badge.svg?branch=master
     :target: https://github.com/lukasturcani/stk/actions?query=branch%3Amaster
 
 .. image:: https://readthedocs.org/projects/stk/badge/?version=latest
     :target: https://stk.readthedocs.io
 
@@ -16,15 +16,15 @@
 ========
 
 ``stk`` is a Python library which allows construction and
 manipulation of complex molecules, as well as automatic
 molecular design, and the creation of molecular, and molecular
 property, databases. The documentation of ``stk`` is available on
 https://stk.readthedocs.io and the project's Discord server can be
-joined through https://discord.gg/YvwdcjKf.
+joined through https://discord.gg/zbCUzuxe2B.
 
 Installation
 ============
 
 To get ``stk``, you can install it with pip::
 
     $ pip install stk
@@ -39,14 +39,19 @@
     https://github.com/lukasturcani/stk/releases
 
 There will be a corresponding release on ``pip`` for each release
 on GitHub, and you can update your ``stk`` with::
 
     $ pip install stk --upgrade
 
+``stk`` requires Python 3.11, if you are using an older version
+of Python you can use an older version of ``stk``::
+
+  $ pip install stk==2022.6.17.0
+
 How To Cite
 ===========
 
 If you use ``stk`` please cite
 
     https://github.com/lukasturcani/stk
 
@@ -62,23 +67,44 @@
 ---------
 
 * `stk: An Extendable Python Framework for Automated Molecular and
   Supramolecular Structure Assembly and Discovery`__
 
 __ https://aip.scitation.org/doi/10.1063/5.0049708
 
+* Describing metal-organic cage usage: `Unlocking the computational design of metal–organic cages`__
+
+__ https://pubs.rsc.org/en/content/articlelanding/2022/CC/D2CC00532H
+
 * (Out of date) `stk: A Python Toolkit for Supramolecular Assembly`__
   | chemrxiv__
 
 __ https://onlinelibrary.wiley.com/doi/abs/10.1002/jcc.25377
 __ https://chemrxiv.org/articles/STK_A_Python_Toolkit_for_Supramolecular_Assembly/6127826
 
 using stk
 ---------
 
+* `The effect of disorder in multi-component covalent organic frameworks`__
+
+__ https://pubs.rsc.org/en/content/articlehtml/2023/cc/d3cc01111a
+
+* `Tetramine Aspect Ratio and Flexibility Determine Framework Symmetry for Zn8L6 Self-Assembled Structures`__
+
+__ https://onlinelibrary.wiley.com/doi/10.1002/anie.202217987
+
+* `Orientational self-sorting in cuboctahedral Pd cages`__
+
+__ https://pubs.rsc.org/en/content/articlehtml/2022/sc/d2sc03856k
+
+* `Conformer-RL: A deep reinforcement learning library for conformer
+  generation`__
+
+__ https://onlinelibrary.wiley.com/doi/full/10.1002/jcc.26984
+
 * `High-throughput Computational Evaluation of Low Symmetry Pd2L4
   Cages to Aid in System Design`__
 
 __ https://onlinelibrary.wiley.com/doi/10.1002/anie.202106721
 
 * `Forecasting System of Computational Time of DFT/TDDFT Calculations
   under the Multiverse Ansatz via Machine Learning and
```

#### encoding

```diff
@@ -1 +1 @@
-us-ascii
+utf-8
```

### Comparing `stk-2022.6.17.0/src/stk/databases/constructed_molecule.py` & `stk-2023.7.5.0/src/stk/_internal/databases/molecule.py`

 * *Files 14% similar despite different names*

```diff
@@ -1,49 +1,37 @@
-"""
-Constructed Molecule Database
-=============================
-
-.. toctree::
-    :maxdepth: 2
-
-    Constructed Molecule MongoDB <\
-stk.databases.mongo_db.constructed_molecule\
->
-
-"""
-
-
-class ConstructedMoleculeDatabase:
+class MoleculeDatabase:
     """
-    Abstract base class for storing constructed molecules.
+    An abstract base class for storing and retrieving molecules.
 
     See Also
     --------
-    :class:`.MoleculeDatabase`
-        If you need to store and retrieve :class:`.Molecule`
-        instances.
+    :class:`.ConstructedMoleculeDatabase`
+        If you need to store and retrieve
+        :class:`.ConstructedMolecule` instances. You can put \
+        :class:`.ConstructedMolecule` instances into a \
+        :class:`.MoleculeDatabase`, however, you will only be able to \
+        retrieve them as plain :class:`.Molecule` instances.
 
     Examples
     --------
     *Subclass Implementation*
 
     The source code of the subclasses, listed in
-    :mod:`constructed_molecule_database \
-    <~.databases.constructed_molecule>`, can
-    serve as good examples.
+    :mod:`molecule_database <~.databases.molecule>`, can serve as
+    good examples.
 
     """
 
     def put(self, molecule):
         """
         Put `molecule` into the database.
 
         Parameters
         ----------
-        molecule : :class:`.ConstructedMolecule`
+        molecule : :class:`.Molecule`
             The molecule to place into the database.
 
         Returns
         -------
         None : :class:`NoneType`
 
         """
@@ -58,31 +46,31 @@
         ----------
         key : :class:`object`
             The key of a molecule, which is to be returned from the
             database.
 
         Returns
         -------
-        :class:`.ConstructedMolecule`
+        :class:`.Molecule`
             The molecule held in the database under `key`.
 
         Raises
         ------
         :class:`KeyError`
             If `key` is not found in the database.
 
         """
 
         raise NotImplementedError()
 
     def get_all(self):
         """
-        Get all entries in the database.
+        Get all molecules in the database.
 
         Yields
         ------
-        :class:`.ConstructedMolecule`
+        :class:`.Molecule`
             A molecule in the database.
 
         """
 
         raise NotImplementedError()
```

### Comparing `stk-2022.6.17.0/src/stk/databases/molecule.py` & `stk-2023.7.5.0/src/stk/_internal/databases/constructed_molecule.py`

 * *Files 18% similar despite different names*

```diff
@@ -1,49 +1,35 @@
-"""
-Molecule Database
-=================
-
-.. toctree::
-    :maxdepth: 2
-
-    Molecule MongoDB <stk.databases.mongo_db.molecule>
-
-"""
-
-
-class MoleculeDatabase:
+class ConstructedMoleculeDatabase:
     """
-    An abstract base class for storing and retrieving molecules.
+    Abstract base class for storing constructed molecules.
 
     See Also
     --------
-    :class:`.ConstructedMoleculeDatabase`
-        If you need to store and retrieve
-        :class:`.ConstructedMolecule` instances. You can put \
-        :class:`.ConstructedMolecule` instances into a \
-        :class:`.MoleculeDatabase`, however, you will only be able to \
-        retrieve them as plain :class:`.Molecule` instances.
+    :class:`.MoleculeDatabase`
+        If you need to store and retrieve :class:`.Molecule`
+        instances.
 
     Examples
     --------
     *Subclass Implementation*
 
     The source code of the subclasses, listed in
-    :mod:`molecule_database <~.databases.molecule>`, can serve as
-    good examples.
+    :mod:`constructed_molecule_database \
+    <~.databases.constructed_molecule>`, can
+    serve as good examples.
 
     """
 
     def put(self, molecule):
         """
         Put `molecule` into the database.
 
         Parameters
         ----------
-        molecule : :class:`.Molecule`
+        molecule : :class:`.ConstructedMolecule`
             The molecule to place into the database.
 
         Returns
         -------
         None : :class:`NoneType`
 
         """
@@ -58,31 +44,31 @@
         ----------
         key : :class:`object`
             The key of a molecule, which is to be returned from the
             database.
 
         Returns
         -------
-        :class:`.Molecule`
+        :class:`.ConstructedMolecule`
             The molecule held in the database under `key`.
 
         Raises
         ------
         :class:`KeyError`
             If `key` is not found in the database.
 
         """
 
         raise NotImplementedError()
 
     def get_all(self):
         """
-        Get all molecules in the database.
+        Get all entries in the database.
 
         Yields
         ------
-        :class:`.Molecule`
+        :class:`.ConstructedMolecule`
             A molecule in the database.
 
         """
 
         raise NotImplementedError()
```

### Comparing `stk-2022.6.17.0/src/stk/databases/mongo_db/constructed_molecule.py` & `stk-2023.7.5.0/src/stk/_internal/databases/mongo_db/constructed_molecule.py`

 * *Files 7% similar despite different names*

```diff
@@ -1,21 +1,15 @@
-"""
-Constructed Molecule MongoDB
-============================
-
-"""
-
 import itertools
 from functools import lru_cache
 
-from stk.serialization import (
+from stk._internal.json_serde.constructed_molecule import (
     ConstructedMoleculeDejsonizer,
     ConstructedMoleculeJsonizer,
 )
-from stk.utilities import dedupe
+from stk._internal.utilities.utilities import dedupe
 
 from ..constructed_molecule import ConstructedMoleculeDatabase
 from .utilities import HashableDict, get_any_value
 
 
 class ConstructedMoleculeMongoDb(ConstructedMoleculeDatabase):
     """
@@ -350,26 +344,26 @@
     of the second molecule matched by the key.
 
     """
 
     def __init__(
         self,
         mongo_client,
-        database='stk',
-        molecule_collection='molecules',
-        constructed_molecule_collection='constructed_molecules',
-        position_matrix_collection='position_matrices',
+        database="stk",
+        molecule_collection="molecules",
+        constructed_molecule_collection="constructed_molecules",
+        position_matrix_collection="position_matrices",
         building_block_position_matrix_collection=(
-            'building_block_position_matrices'
+            "building_block_position_matrices"
         ),
         jsonizer=ConstructedMoleculeJsonizer(),
         dejsonizer=ConstructedMoleculeDejsonizer(),
         put_lru_cache_size=128,
         get_lru_cache_size=128,
-        indices=('InChIKey', ),
+        indices=("InChIKey",),
     ):
         """
         Initialize a :class:`.ConstructedMoleculeMongoDb`.
 
         Parameters
         ----------
         mongo_client : :class:`pymongo.MongoClient`
@@ -421,136 +415,129 @@
             The names of molecule keys, on which an index should be
             created, in order to minimize lookup time.
 
         """
 
         database = mongo_client[database]
         self._molecules = database[molecule_collection]
-        self._constructed_molecules = database[
-            constructed_molecule_collection
-        ]
+        self._constructed_molecules = database[constructed_molecule_collection]
         self._position_matrices = database[position_matrix_collection]
         self._building_block_position_matrices = database[
             building_block_position_matrix_collection
         ]
         self._jsonizer = jsonizer
         self._dejsonizer = dejsonizer
 
         self._get = lru_cache(maxsize=get_lru_cache_size)(self._get)
         self._put = lru_cache(maxsize=put_lru_cache_size)(self._put)
 
         for index in indices:
             # Do not create the same index twice.
-            if f'{index}_1' not in self._molecules.index_information():
+            if f"{index}_1" not in self._molecules.index_information():
                 self._molecules.create_index(index)
             if (
-                f'{index}_1'
+                f"{index}_1"
                 not in self._constructed_molecules.index_information()
             ):
                 self._constructed_molecules.create_index(index)
-            if (
-                f'{index}_1'
-                not in self._position_matrices.index_information()
-            ):
+            if f"{index}_1" not in self._position_matrices.index_information():
                 self._position_matrices.create_index(index)
 
-            if (
-                f'{index}_1'
-                not in
-                self._building_block_position_matrices
-                .index_information()
-            ):
+            index_information = (
+                self._building_block_position_matrices.index_information()
+            )
+            if f"{index}_1" not in index_information:
                 self._building_block_position_matrices.create_index(
                     index,
                 )
 
     def put(self, molecule):
         molecule = molecule.with_canonical_atom_ordering()
         json = self._jsonizer.to_json(molecule)
         # lru_cache requires that the parameters to the cached function
         # are hashable objects.
-        json['matrix']['m'] = tuple(
-            tuple(row) for row in json['matrix']['m']
+        json["matrix"]["m"] = tuple(tuple(row) for row in json["matrix"]["m"])
+        json["matrix"] = HashableDict(json["matrix"])
+        json["molecule"] = HashableDict(json["molecule"])
+        json["constructedMolecule"] = HashableDict(json["constructedMolecule"])
+        json["constructedMolecule"]["BB"] = tuple(
+            map(
+                HashableDict,
+                json["constructedMolecule"]["BB"],
+            )
         )
-        json['matrix'] = HashableDict(json['matrix'])
-        json['molecule'] = HashableDict(json['molecule'])
-        json['constructedMolecule'] = HashableDict(
-            json['constructedMolecule']
-        )
-        json['constructedMolecule']['BB'] = tuple(map(
-            HashableDict,
-            json['constructedMolecule']['BB'],
-        ))
 
         def make_hashable(json):
-            json['matrix']['m'] = tuple(
-                tuple(row) for row in json['matrix']['m']
+            json["matrix"]["m"] = tuple(
+                tuple(row) for row in json["matrix"]["m"]
             )
-            json['matrix'] = HashableDict(json['matrix'])
-            json['molecule'] = HashableDict(json['molecule'])
+            json["matrix"] = HashableDict(json["matrix"])
+            json["molecule"] = HashableDict(json["molecule"])
             return HashableDict(json)
 
-        json['buildingBlocks'] = tuple(map(
-            make_hashable,
-            json['buildingBlocks'],
-        ))
+        json["buildingBlocks"] = tuple(
+            map(
+                make_hashable,
+                json["buildingBlocks"],
+            )
+        )
         return self._put(HashableDict(json))
 
     @staticmethod
     def _get_query(json):
-        keys = dict(json['matrix'])
-        keys.pop('m')
+        keys = dict(json["matrix"])
+        keys.pop("m")
 
-        query = {'$or': []}
+        query = {"$or": []}
         for key, value in keys.items():
-            query['$or'].append({key: value})
+            query["$or"].append({key: value})
         return query
 
     def _put(self, json):
         query = self._get_query(json)
         self._molecules.update_many(
             filter=query,
             update={
-                '$set': json['molecule'],
+                "$set": json["molecule"],
             },
             upsert=True,
         )
         self._position_matrices.update_many(
             filter=query,
             update={
-                '$set': json['matrix'],
+                "$set": json["matrix"],
             },
             upsert=True,
         )
 
         self._add_building_block_keys_from_database(
             query=query,
-            building_block_keys=json['constructedMolecule']['BB'],
+            building_block_keys=json["constructedMolecule"]["BB"],
         )
 
         self._constructed_molecules.update_many(
             filter=query,
             update={
-                '$set': json['constructedMolecule'],
+                "$set": json["constructedMolecule"],
             },
             upsert=True,
         )
-        for building_block_json in json['buildingBlocks']:
+        for building_block_json in json["buildingBlocks"]:
             building_block_query = self._get_query(building_block_json)
             self._molecules.update_many(
                 filter=building_block_query,
                 update={
-                    '$set': building_block_json['molecule'],
+                    "$set": building_block_json["molecule"],
                 },
                 upsert=True,
             )
             self._building_block_position_matrices.update_many(
                 filter=building_block_query,
                 update={
-                    '$set': building_block_json['matrix'],
+                    "$set": building_block_json["matrix"],
                 },
                 upsert=True,
             )
 
     def _add_building_block_keys_from_database(
         self,
         query,
@@ -604,17 +591,16 @@
         Returns
         -------
         None : :class:`NoneType`
 
         """
 
         database_building_block_keys = (
-            molecule_entry['BB']
-            for molecule_entry
-            in self._constructed_molecules.find(query)
+            molecule_entry["BB"]
+            for molecule_entry in self._constructed_molecules.find(query)
         )
         for entry_building_block_keys in database_building_block_keys:
             for keys1, keys2 in zip(
                 building_block_keys,
                 entry_building_block_keys,
             ):
                 keys1.update(keys2)
@@ -640,188 +626,185 @@
             The molecule held in the database under `key`.
 
         """
 
         molecule_json = self._molecules.find_one(key)
         if molecule_json is None:
             raise KeyError(
-                'No molecule found in the database with a key of: '
-                f'{key}'
+                "No molecule found in the database with a key of: " f"{key}"
             )
 
-        constructed_molecule_json = (
-            self._constructed_molecules.find_one(key)
-        )
+        constructed_molecule_json = self._constructed_molecules.find_one(key)
         if constructed_molecule_json is None:
             raise KeyError(
-                'No molecule found in the database with a key of: '
-                f'{key}'
+                "No molecule found in the database with a key of: " f"{key}"
             )
 
         position_matrix = self._position_matrices.find_one(key)
         if position_matrix is None:
             raise KeyError(
-                'No position matrix found in the database with a key '
-                f'of: {key}'
+                "No position matrix found in the database with a key "
+                f"of: {key}"
             )
 
         return self._dejsonizer.from_json(
             json={
-                'molecule': molecule_json,
-                'constructedMolecule': constructed_molecule_json,
-                'matrix': position_matrix,
-                'buildingBlocks': tuple(map(
-                    self._get_building_block,
-                    constructed_molecule_json['BB'],
-                ))
+                "molecule": molecule_json,
+                "constructedMolecule": constructed_molecule_json,
+                "matrix": position_matrix,
+                "buildingBlocks": tuple(
+                    map(
+                        self._get_building_block,
+                        constructed_molecule_json["BB"],
+                    )
+                ),
             },
         )
 
     def _get_building_block(self, key):
         return {
-            'molecule': self._molecules.find_one(key),
-            'matrix':
-                self._building_block_position_matrices.find_one(key),
+            "molecule": self._molecules.find_one(key),
+            "matrix": self._building_block_position_matrices.find_one(key),
         }
 
     def get_all(self):
         # Get all potential indices.
         indices = itertools.chain(
             self._position_matrices.index_information().values(),
             self._molecules.index_information().values(),
             self._constructed_molecules.index_information().values(),
         )
-        keys = tuple(dedupe(
-            index['key'][0][0]
-            for index in indices
-            # Ignore "_id" index which is unique in a collection and
-            # cannot be used to match molecular data split across
-            # collections.
-            if index['key'][0][0] != '_id'
-        ))
+        keys = tuple(
+            dedupe(
+                index["key"][0][0]
+                for index in indices
+                # Ignore "_id" index which is unique in a collection and
+                # cannot be used to match molecular data split across
+                # collections.
+                if index["key"][0][0] != "_id"
+            )
+        )
 
         query = [
             {
-                '$match': {
-                    '$or': [
-                        {key: {'$exists': True}}
-                        for key in keys
-                    ],
+                "$match": {
+                    "$or": [{key: {"$exists": True}} for key in keys],
                 },
             },
         ]
         query.extend(
             {
-                '$lookup': {
-                    'from': self._position_matrices.name,
-                    'let': {
-                        'molecule_key': f'${key}',
+                "$lookup": {
+                    "from": self._position_matrices.name,
+                    "let": {
+                        "molecule_key": f"${key}",
                     },
-                    'as': f'posmat_{key}',
-                    'pipeline': [
+                    "as": f"posmat_{key}",
+                    "pipeline": [
                         {
-                            '$match': {
-                                key: {'$ne': None},
+                            "$match": {
+                                key: {"$ne": None},
                             },
                         },
                         {
-                            '$match': {
-                                '$expr': {
-                                    '$eq': [
-                                        f'${key}',
-                                        '$$molecule_key',
+                            "$match": {
+                                "$expr": {
+                                    "$eq": [
+                                        f"${key}",
+                                        "$$molecule_key",
                                     ],
                                 },
                             },
                         },
                     ],
                 },
             }
             for key in keys
         )
         query.extend(
             {
-                '$lookup': {
-                    'from': self._molecules.name,
-                    'let': {
-                        'molecule_key': f'${key}',
+                "$lookup": {
+                    "from": self._molecules.name,
+                    "let": {
+                        "molecule_key": f"${key}",
                     },
-                    'as': f'mol_{key}',
-                    'pipeline': [
+                    "as": f"mol_{key}",
+                    "pipeline": [
                         {
-                            '$match': {
-                                key: {'$ne': None},
+                            "$match": {
+                                key: {"$ne": None},
                             },
                         },
                         {
-                            '$match': {
-                                '$expr': {
-                                    '$eq': [
-                                        f'${key}',
-                                        '$$molecule_key',
+                            "$match": {
+                                "$expr": {
+                                    "$eq": [
+                                        f"${key}",
+                                        "$$molecule_key",
                                     ],
                                 },
                             },
                         },
                     ],
                 },
             }
             for key in keys
         )
         query.append(
             {
-                '$match': {
-                    '$expr': {
-                        '$or': [
+                "$match": {
+                    "$expr": {
+                        "$or": [
                             {
-                                '$gt': [
-                                    {'$size': f'$posmat_{key}'},
-                                    0
+                                "$gt": [
+                                    {"$size": f"$posmat_{key}"},
+                                    0,
                                 ],
                             }
                             for key in keys
                         ],
                     },
                 },
             },
         )
         query.append(
             {
-                '$match': {
-                    '$expr': {
-                        '$or': [
+                "$match": {
+                    "$expr": {
+                        "$or": [
                             {
-                                '$gt': [
-                                    {'$size': f'$mol_{key}'},
-                                    0
-                                ],
+                                "$gt": [{"$size": f"$mol_{key}"}, 0],
                             }
                             for key in keys
                         ],
                     },
                 },
             },
         )
 
         cursor = self._constructed_molecules.aggregate(query)
         for entry in cursor:
             molecule_document = get_any_value(
                 mapping=entry,
-                keys=(f'mol_{key}' for key in keys),
+                keys=(f"mol_{key}" for key in keys),
             )
             position_matrix_document = get_any_value(
                 mapping=entry,
-                keys=(f'posmat_{key}' for key in keys),
+                keys=(f"posmat_{key}" for key in keys),
             )
             if (
                 molecule_document is not None
                 and position_matrix_document is not None
             ):
-                yield self._dejsonizer.from_json({
-                    'molecule': molecule_document,
-                    'constructedMolecule': entry,
-                    'matrix': position_matrix_document,
-                    'buildingBlocks': tuple(map(
-                        self._get_building_block,
-                        entry['BB'],
-                    )),
-                })
+                yield self._dejsonizer.from_json(
+                    {
+                        "molecule": molecule_document,
+                        "constructedMolecule": entry,
+                        "matrix": position_matrix_document,
+                        "buildingBlocks": tuple(
+                            map(
+                                self._get_building_block,
+                                entry["BB"],
+                            )
+                        ),
+                    }
+                )
```

### Comparing `stk-2022.6.17.0/src/stk/databases/mongo_db/molecule.py` & `stk-2023.7.5.0/src/stk/_internal/databases/mongo_db/molecule.py`

 * *Files 7% similar despite different names*

```diff
@@ -3,16 +3,19 @@
 ================
 
 """
 
 import itertools
 from functools import lru_cache
 
-from stk.serialization import MoleculeDejsonizer, MoleculeJsonizer
-from stk.utilities import dedupe
+from stk._internal.json_serde.molecule import (
+    MoleculeDejsonizer,
+    MoleculeJsonizer,
+)
+from stk._internal.utilities.utilities import dedupe
 
 from ..molecule import MoleculeDatabase
 from .utilities import HashableDict, get_any_value
 
 
 class MoleculeMongoDb(MoleculeDatabase):
     """
@@ -314,22 +317,22 @@
     of the second molecule matched by the key.
 
     """
 
     def __init__(
         self,
         mongo_client,
-        database='stk',
-        molecule_collection='molecules',
-        position_matrix_collection='building_block_position_matrices',
+        database="stk",
+        molecule_collection="molecules",
+        position_matrix_collection="building_block_position_matrices",
         jsonizer=MoleculeJsonizer(),
         dejsonizer=MoleculeDejsonizer(),
         put_lru_cache_size=128,
         get_lru_cache_size=128,
-        indices=('InChIKey', ),
+        indices=("InChIKey",),
     ):
         """
         Initialize a :class:`.MoleculeMongoDb` instance.
 
         Parameters
         ----------
         mongo_client : :class:`pymongo.MongoClient`
@@ -380,53 +383,48 @@
         self._dejsonizer = dejsonizer
 
         self._get = lru_cache(maxsize=get_lru_cache_size)(self._get)
         self._put = lru_cache(maxsize=put_lru_cache_size)(self._put)
 
         for index in indices:
             # Do not create the same index twice.
-            if f'{index}_1' not in self._molecules.index_information():
+            if f"{index}_1" not in self._molecules.index_information():
                 self._molecules.create_index(index)
-            if (
-                f'{index}_1'
-                not in self._position_matrices.index_information()
-            ):
+            if f"{index}_1" not in self._position_matrices.index_information():
                 self._position_matrices.create_index(index)
 
     def put(self, molecule):
         molecule = molecule.with_canonical_atom_ordering()
         json = self._jsonizer.to_json(molecule)
         # lru_cache requires that the parameters to the cached function
         # are hashable objects.
-        json['matrix']['m'] = tuple(
-            tuple(row) for row in json['matrix']['m']
-        )
-        json['matrix'] = HashableDict(json['matrix'])
-        json['molecule'] = HashableDict(json['molecule'])
+        json["matrix"]["m"] = tuple(tuple(row) for row in json["matrix"]["m"])
+        json["matrix"] = HashableDict(json["matrix"])
+        json["molecule"] = HashableDict(json["molecule"])
         return self._put(HashableDict(json))
 
     def _put(self, json):
-        keys = dict(json['matrix'])
-        keys.pop('m')
+        keys = dict(json["matrix"])
+        keys.pop("m")
 
-        query = {'$or': []}
+        query = {"$or": []}
         for key, value in keys.items():
-            query['$or'].append({key: value})
+            query["$or"].append({key: value})
 
         self._molecules.update_many(
             filter=query,
             update={
-                '$set': json['molecule'],
+                "$set": json["molecule"],
             },
             upsert=True,
         )
         self._position_matrices.update_many(
             filter=query,
             update={
-                '$set': json['matrix'],
+                "$set": json["matrix"],
             },
             upsert=True,
         )
 
     def get(self, key):
         # lru_cache requires that the parameters to the cached function
         # are hashable objects.
@@ -448,105 +446,107 @@
             The molecule held in the database under `key`.
 
         """
 
         json = self._molecules.find_one(key)
         if json is None:
             raise KeyError(
-                'No molecule found in the database with a key of: '
-                f'{key}'
+                "No molecule found in the database with a key of: " f"{key}"
             )
         position_matrix = self._position_matrices.find_one(key)
         if position_matrix is None:
             raise KeyError(
-                'No position matrix found in the database with a key '
-                f'of: {key}'
+                "No position matrix found in the database with a key "
+                f"of: {key}"
             )
 
-        return self._dejsonizer.from_json({
-            'molecule': json,
-            'matrix': position_matrix,
-        })
+        return self._dejsonizer.from_json(
+            {
+                "molecule": json,
+                "matrix": position_matrix,
+            }
+        )
 
     def get_all(self):
         # Get all potential indices.
         indices = itertools.chain(
             self._position_matrices.index_information().values(),
             self._molecules.index_information().values(),
         )
-        keys = tuple(dedupe(
-            index['key'][0][0]
-            for index in indices
-            # Ignore "_id" index which is unique in a collection and
-            # cannot be used to match molecular data split across
-            # collections.
-            if index['key'][0][0] != '_id'
-        ))
+        keys = tuple(
+            dedupe(
+                index["key"][0][0]
+                for index in indices
+                # Ignore "_id" index which is unique in a collection and
+                # cannot be used to match molecular data split across
+                # collections.
+                if index["key"][0][0] != "_id"
+            )
+        )
 
         query = [
             {
-                '$match': {
-                    '$or': [
-                        {key: {'$exists': True}}
-                        for key in keys
-                    ],
+                "$match": {
+                    "$or": [{key: {"$exists": True}} for key in keys],
                 },
             },
         ]
         query.extend(
             {
-                '$lookup': {
-                    'from': self._position_matrices.name,
-                    'let': {
-                        'molecule_key': f'${key}',
+                "$lookup": {
+                    "from": self._position_matrices.name,
+                    "let": {
+                        "molecule_key": f"${key}",
                     },
-                    'as': f'posmat_{key}',
-                    'pipeline': [
+                    "as": f"posmat_{key}",
+                    "pipeline": [
                         {
-                            '$match': {
-                                key: {'$ne': None},
+                            "$match": {
+                                key: {"$ne": None},
                             },
                         },
                         {
-                            '$match': {
-                                '$expr': {
-                                    '$eq': [
-                                        f'${key}',
-                                        '$$molecule_key',
+                            "$match": {
+                                "$expr": {
+                                    "$eq": [
+                                        f"${key}",
+                                        "$$molecule_key",
                                     ],
                                 },
                             },
                         },
                     ],
                 },
             }
             for key in keys
         )
         query.append(
             {
-                '$match': {
-                    '$expr': {
-                        '$or': [
+                "$match": {
+                    "$expr": {
+                        "$or": [
                             {
-                                '$gt': [
-                                    {'$size': f'$posmat_{key}'},
-                                    0
+                                "$gt": [
+                                    {"$size": f"$posmat_{key}"},
+                                    0,
                                 ],
                             }
                             for key in keys
                         ],
                     },
                 },
             },
         )
 
         cursor = self._molecules.aggregate(query)
         for entry in cursor:
             position_matrix_document = get_any_value(
                 mapping=entry,
-                keys=(f'posmat_{key}' for key in keys),
+                keys=(f"posmat_{key}" for key in keys),
             )
             if position_matrix_document is not None:
-                yield self._dejsonizer.from_json({
-                    'molecule': entry,
-                    'matrix': position_matrix_document,
-                })
+                yield self._dejsonizer.from_json(
+                    {
+                        "molecule": entry,
+                        "matrix": position_matrix_document,
+                    }
+                )
```

### Comparing `stk-2022.6.17.0/src/stk/databases/mongo_db/utilities.py` & `stk-2023.7.5.0/src/stk/_internal/databases/mongo_db/utilities.py`

 * *Files 1% similar despite different names*

```diff
@@ -6,18 +6,20 @@
 
 from collections.abc import Sequence
 from typing import Iterable, Optional
 
 
 class HashableDict(dict):
     def __hash__(self):
-        return hash((
-            frozenset(self),
-            frozenset(_to_hashable(list(self.values()))),
-        ))
+        return hash(
+            (
+                frozenset(self),
+                frozenset(_to_hashable(list(self.values()))),
+            )
+        )
 
     def __eq__(self, other):
         return super().__eq__(other)
 
 
 def _to_hashable(item):
     if isinstance(item, list):
```

### Comparing `stk-2022.6.17.0/src/stk/databases/mongo_db/value.py` & `stk-2023.7.5.0/src/stk/_internal/databases/mongo_db/value.py`

 * *Files 3% similar despite different names*

```diff
@@ -1,16 +1,10 @@
-"""
-Value MongoDB
-=============
-
-"""
-
 from functools import lru_cache
 
-from stk.molecular import InchiKey
+from stk._internal.key_makers.inchi_key import InchiKey
 
 from ..value import ValueDatabase
 from .utilities import HashableDict
 
 
 class ValueMongoDb(ValueDatabase):
     """
@@ -100,19 +94,19 @@
 
     """
 
     def __init__(
         self,
         mongo_client,
         collection,
-        database='stk',
-        key_makers=(InchiKey(), ),
+        database="stk",
+        key_makers=(InchiKey(),),
         put_lru_cache_size=128,
         get_lru_cache_size=128,
-        indices=('InChIKey', ),
+        indices=("InChIKey",),
     ):
         """
         Initialize a :class:`.ValueMongoDb` instance.
 
         Parameters
         ----------
         mongo_client : :class:`pymongo.MongoClient`
@@ -151,62 +145,55 @@
 
         self._values = mongo_client[database][collection]
         self._key_makers = key_makers
         self._put = lru_cache(maxsize=put_lru_cache_size)(self._put)
         self._get = lru_cache(maxsize=get_lru_cache_size)(self._get)
 
         index_information = self._values.index_information()
-        if 'v_1' not in index_information:
-            self._values.create_index('v')
+        if "v_1" not in index_information:
+            self._values.create_index("v")
 
         for index in indices:
             # Do not create the same index twice.
-            if f'{index}_1' not in index_information:
+            if f"{index}_1" not in index_information:
                 self._values.create_index(index)
 
     def put(self, molecule, value):
-        json = {'v': value}
+        json = {"v": value}
         for key_maker in self._key_makers:
-            json[key_maker.get_key_name()] = (
-                key_maker.get_key(molecule)
-            )
+            json[key_maker.get_key_name()] = key_maker.get_key(molecule)
         # lru_cache requires that the parameters to the cached function
         # are hashable objects.
         return self._put(HashableDict(json))
 
     def _put(self, json):
         keys = dict(json)
-        keys.pop('v')
+        keys.pop("v")
 
-        query = {'$or': []}
+        query = {"$or": []}
         for key, value in keys.items():
-            query['$or'].append({key: value})
+            query["$or"].append({key: value})
 
         self._values.update_many(
             filter=query,
-            update={
-                '$set': json
-            },
+            update={"$set": json},
             upsert=True,
         )
 
     def get(self, molecule):
-
         def make_dict(key_maker):
-            return HashableDict({
-                key_maker.get_key_name():
-                key_maker.get_key(molecule)
-            })
+            return HashableDict(
+                {key_maker.get_key_name(): key_maker.get_key(molecule)}
+            )
 
-        key = {'$or': tuple(map(make_dict, self._key_makers))}
+        key = {"$or": tuple(map(make_dict, self._key_makers))}
         # lru_cache requires that the parameters to the cached function
         # are hashable objects.
         return self._get(HashableDict(key))
 
     def _get(self, key):
         value = self._values.find_one(key)
         if value is None:
             raise KeyError(
-                'No molecule found in the database with a key of: '
-                f'{key}'
+                "No molecule found in the database with a key of: " f"{key}"
             )
-        return value['v']
+        return value["v"]
```

### Comparing `stk-2022.6.17.0/src/stk/databases/value.py` & `stk-2023.7.5.0/src/stk/_internal/databases/value.py`

 * *Files 12% similar despite different names*

```diff
@@ -1,19 +1,7 @@
-"""
-Value Database
-==============
-
-.. toctree::
-    :maxdepth: 2
-
-    Value MongoDB <stk.databases.mongo_db.value>
-
-"""
-
-
 class ValueDatabase:
     """
     Abstract base class for storing of molecular property values.
 
     Examples
     --------
     *Subclass Implementation*
```

### Comparing `stk-2022.6.17.0/src/stk/ea/crossover/crossers/compound/random.py` & `stk-2023.7.5.0/src/stk/_internal/ea/crossover/random.py`

 * *Files 15% similar despite different names*

```diff
@@ -1,206 +1,211 @@
-"""
-Random Crosser
-==============
+import typing
+from collections.abc import Iterable, Iterator, Sequence
 
-"""
+import numpy as np
 
+from stk._internal.ea.crossover.molecule_crosser import MoleculeCrosser
+from stk._internal.ea.crossover.record import CrossoverRecord
 
-import numpy as np
+T = typing.TypeVar("T")
 
 
-class RandomCrosser:
+class RandomCrosser(typing.Generic[T]):
     """
     Use some other crosser at random.
 
-    Examples
-    --------
-    *Use One of Several Crossers at Random*
-
-    .. testcode:: use-one-of-several-crossers-at-random
-
-        import stk
-
-        def get_functional_group_type(building_block):
-            fg, = building_block.get_functional_groups(0)
-            return type(fg)
-
-        def get_num_functional_groups(building_block):
-           return building_block.get_num_functional_groups()
-
-        crosser = stk.RandomCrosser(
-            crossers=(
-                stk.GeneticRecombination(get_functional_group_type),
-                stk.GeneticRecombination(get_num_functional_groups),
-            ),
-            random_seed=12,
-        )
+    Examples:
 
-        record1 = stk.MoleculeRecord(
-            topology_graph=stk.cage.FourPlusSix(
-                building_blocks=(
-                    stk.BuildingBlock(
-                        smiles='O=CC(C=O)CC=O',
-                        functional_groups=[stk.AldehydeFactory()],
-                    ),
-                    stk.BuildingBlock(
-                        smiles='NCCN',
-                        functional_groups=[stk.PrimaryAminoFactory()],
-                    ),
-                ),
-            ),
-        )
-        record2 = stk.MoleculeRecord(
-            topology_graph=stk.cage.FourPlusSix(
-                building_blocks=(
-                    stk.BuildingBlock(
-                        smiles='O=CNC(C=O)CC=O',
-                        functional_groups=[stk.AldehydeFactory()],
-                    ),
-                    stk.BuildingBlock(
-                        smiles='NCNCN',
-                        functional_groups=[stk.PrimaryAminoFactory()],
-                    ),
-                ),
-            ),
-        )
+        *Use One of Several Crossers at Random*
 
-        # Use one of the component crossers at random.
-        crossover_records1 = tuple(crosser.cross((record1, record2)))
-        # A different crosser may get selected at random the second,
-        # third, etc, time.
-        crossover_records2 = tuple(crosser.cross((record1, record2)))
+        .. testcode:: use-one-of-several-crossers-at-random
 
-    .. testcode:: use-one-of-several-crossers-at-random
-        :hide:
+            import stk
 
-        _expected_results = (
-            stk.ConstructedMolecule(
-                topology_graph=stk.cage.FourPlusSix(
-                    building_blocks=(
-                        stk.BuildingBlock(
-                            smiles='O=CNC(C=O)CC=O',
-                            functional_groups=[stk.AldehydeFactory()],
-                        ),
-                        stk.BuildingBlock(
-                            smiles='NCNCN',
-                            functional_groups=[
-                                stk.PrimaryAminoFactory(),
-                            ],
-                        ),
-                    ),
+            def get_functional_group_type(building_block):
+                fg, = building_block.get_functional_groups(0)
+                return type(fg)
+
+            def get_num_functional_groups(building_block):
+               return building_block.get_num_functional_groups()
+
+            crosser = stk.RandomCrosser(
+                crossers=(
+                    stk.GeneticRecombination(get_functional_group_type),
+                    stk.GeneticRecombination(get_num_functional_groups),
                 ),
-            ),
-            stk.ConstructedMolecule(
+                random_seed=12,
+            )
+
+            record1 = stk.MoleculeRecord(
                 topology_graph=stk.cage.FourPlusSix(
                     building_blocks=(
                         stk.BuildingBlock(
                             smiles='O=CC(C=O)CC=O',
                             functional_groups=[stk.AldehydeFactory()],
                         ),
                         stk.BuildingBlock(
                             smiles='NCCN',
-                            functional_groups=[
-                                stk.PrimaryAminoFactory(),
-                            ],
+                            functional_groups=[stk.PrimaryAminoFactory()],
                         ),
                     ),
                 ),
-            ),
-            stk.ConstructedMolecule(
+            )
+            record2 = stk.MoleculeRecord(
                 topology_graph=stk.cage.FourPlusSix(
                     building_blocks=(
                         stk.BuildingBlock(
                             smiles='O=CNC(C=O)CC=O',
                             functional_groups=[stk.AldehydeFactory()],
                         ),
                         stk.BuildingBlock(
-                            smiles='NCCN',
-                            functional_groups=[
-                                stk.PrimaryAminoFactory(),
-                            ],
-                        ),
-                    ),
-                ),
-            ),
-            stk.ConstructedMolecule(
-                topology_graph=stk.cage.FourPlusSix(
-                    building_blocks=(
-                        stk.BuildingBlock(
-                            smiles='O=CC(C=O)CC=O',
-                            functional_groups=[stk.AldehydeFactory()],
-                        ),
-                        stk.BuildingBlock(
                             smiles='NCNCN',
-                            functional_groups=[
-                                stk.PrimaryAminoFactory(),
-                            ],
+                            functional_groups=[stk.PrimaryAminoFactory()],
                         ),
                     ),
                 ),
-            ),
-        )
+            )
 
-        def _get_smiles(item):
-            if isinstance(item, stk.ConstructedMolecule):
-               return stk.Smiles().get_key(item)
-            return stk.Smiles().get_key(
-                molecule=item.get_molecule_record().get_molecule(),
-             )
-
-        _expected_smiles = set(map(_get_smiles, _expected_results))
-
-        _crossover_smiles1 = set(map(_get_smiles, crossover_records1))
-        _crossover_smiles2 = set(map(_get_smiles, crossover_records2))
-        assert _expected_smiles == _crossover_smiles1
-        assert _expected_smiles == _crossover_smiles2
+            # Use one of the component crossers at random.
+            crossover_records1 = tuple(crosser.cross((record1, record2)))
+            # A different crosser may get selected at random the second,
+            # third, etc, time.
+            crossover_records2 = tuple(crosser.cross((record1, record2)))
+
+        .. testcode:: use-one-of-several-crossers-at-random
+            :hide:
+
+            _expected_results = (
+                stk.ConstructedMolecule(
+                    topology_graph=stk.cage.FourPlusSix(
+                        building_blocks=(
+                            stk.BuildingBlock(
+                                smiles='O=CNC(C=O)CC=O',
+                                functional_groups=[stk.AldehydeFactory()],
+                            ),
+                            stk.BuildingBlock(
+                                smiles='NCNCN',
+                                functional_groups=[
+                                    stk.PrimaryAminoFactory(),
+                                ],
+                            ),
+                        ),
+                    ),
+                ),
+                stk.ConstructedMolecule(
+                    topology_graph=stk.cage.FourPlusSix(
+                        building_blocks=(
+                            stk.BuildingBlock(
+                                smiles='O=CC(C=O)CC=O',
+                                functional_groups=[stk.AldehydeFactory()],
+                            ),
+                            stk.BuildingBlock(
+                                smiles='NCCN',
+                                functional_groups=[
+                                    stk.PrimaryAminoFactory(),
+                                ],
+                            ),
+                        ),
+                    ),
+                ),
+                stk.ConstructedMolecule(
+                    topology_graph=stk.cage.FourPlusSix(
+                        building_blocks=(
+                            stk.BuildingBlock(
+                                smiles='O=CNC(C=O)CC=O',
+                                functional_groups=[stk.AldehydeFactory()],
+                            ),
+                            stk.BuildingBlock(
+                                smiles='NCCN',
+                                functional_groups=[
+                                    stk.PrimaryAminoFactory(),
+                                ],
+                            ),
+                        ),
+                    ),
+                ),
+                stk.ConstructedMolecule(
+                    topology_graph=stk.cage.FourPlusSix(
+                        building_blocks=(
+                            stk.BuildingBlock(
+                                smiles='O=CC(C=O)CC=O',
+                                functional_groups=[stk.AldehydeFactory()],
+                            ),
+                            stk.BuildingBlock(
+                                smiles='NCNCN',
+                                functional_groups=[
+                                    stk.PrimaryAminoFactory(),
+                                ],
+                            ),
+                        ),
+                    ),
+                ),
+            )
+
+            def _get_smiles(item):
+                if isinstance(item, stk.ConstructedMolecule):
+                   return stk.Smiles().get_key(item)
+                return stk.Smiles().get_key(
+                    molecule=item.get_molecule_record().get_molecule(),
+                 )
+
+            _expected_smiles = set(map(_get_smiles, _expected_results))
+
+            _crossover_smiles1 = set(map(_get_smiles, crossover_records1))
+            _crossover_smiles2 = set(map(_get_smiles, crossover_records2))
+            assert _expected_smiles == _crossover_smiles1
+            assert _expected_smiles == _crossover_smiles2
 
     """
 
-    def __init__(self, crossers, weights=None, random_seed=None):
+    def __init__(
+        self,
+        crossers: Iterable[MoleculeCrosser[T]],
+        weights: Iterable[float] | None = None,
+        random_seed: int | np.random.Generator | None = None,
+    ) -> None:
         """
-        Initialize a :class:`.RandomCrosser` instance.
+        Parameters:
 
-        Parameters
-        ----------
-        crossers : :class:`tuple`
-            Holds instances which have :meth:`.cross` method. The
-            :meth:`.cross` method must return an instance of
-            :class:`.CrossoverRecord`.
-
-        weights : :class:`tuple` of :class:`float`, optional
-            For each crosser, the probability that it will be chosen
-            whenever :meth:`.cross` is called.
-            If ``None`` all `crossers` will have equal chance of being
-            selected.
-
-        random_seed : :class:`int`, optional
-            The random seed to use.
+            crossers (list[MoleculeCrosser[T]]):
+                A selection of crossers, each time :meth:`.cross` is called,
+                one will be selected at random to perform crossover.
+
+            weights (list[float] | None):
+                For each crosser, the probability that it will be chosen
+                whenever :meth:`.cross` is called.
+                If ``None`` all `crossers` will have equal chance of being
+                selected.
 
+            random_seed:
+                The random seed to use.
         """
 
-        self._crossers = crossers
+        if weights is not None:
+            weights = tuple(weights)
+
+        if random_seed is None or isinstance(random_seed, int):
+            random_seed = np.random.default_rng(random_seed)
+
+        self._crossers = tuple(crossers)
         self._weights = weights
-        self._generator = np.random.RandomState(random_seed)
+        self._generator = random_seed
 
-    def cross(self, records):
+    def cross(self, records: Sequence[T]) -> Iterator[CrossoverRecord[T]]:
         """
         Cross `records`.
 
-        Parameters
-        ----------
-        records : :class:`iterable` of :class:`.MoleculeRecord`
-            The molecule records on which a crossover operation is
-            performed.
-
-        Yields
-        ------
-        :class:`.CrossoverRecord`
+        Parameters:
+            molecules (list[T]):
+                The molecules on which a crossover operation is
+                performed.
+
+        Yields:
             A record of a crossover operation.
 
         """
 
         crosser = self._generator.choice(
-            a=self._crossers,
+            a=self._crossers,  # type: ignore
             p=self._weights,
         )
         return crosser.cross(records)
```

### Comparing `stk-2022.6.17.0/src/stk/ea/crossover/crossers/molecule/crosser.py` & `stk-2023.7.5.0/src/stk/_internal/ea/crossover/molecule_crosser.py`

 * *Files 22% similar despite different names*

```diff
@@ -1,49 +1,39 @@
-"""
-Molecule Crosser
-================
+import typing
+from collections.abc import Iterator, Sequence
 
-.. toctree::
-    :maxdepth: 2
+from stk._internal.ea.crossover.record import CrossoverRecord
 
-    Genetic Recombination <\
-stk.ea.crossover.crossers.molecule.genetic_recombination\
->
+T = typing.TypeVar("T")
 
-"""
 
-
-class MoleculeCrosser:
+class MoleculeCrosser(typing.Protocol[T]):
     """
-    Abstract base class for molecule crossers.
+    Performs crossover operations.
 
     Crossers take multiple molecules and recombine them to make
     new, offspring, molecules.
 
-    Examples
-    --------
-    *Subclass Implementation*
-
-    You only need to implement :meth:`.cross`. The source code of any
-    of the classes listed in :mod:`.crosser` can serve as good
-    examples.
+    Examples:
+
+        *Implementing crossover operations*
+
+        You only need to implement :meth:`.cross`. The source code of any
+        of the classes listed in :mod:`.crosser` can serve as good
+        examples.
 
     """
 
-    def cross(self, records):
+    def cross(self, records: Sequence[T]) -> Iterator[CrossoverRecord[T]]:
         """
         Cross `records`.
 
-        Parameters
-        ----------
-        records : :class:`iterable` of :class:`.MoleculeRecord`
-            The molecule records on which a crossover operation is
-            performed.
-
-        Yields
-        ------
-        :class:`.CrossoverRecord`
+        Parameters:
+            records (list[T]):
+                The molecule records on which a crossover operation is
+                performed.
+
+        Yields:
             A record of a crossover operation.
 
         """
-
-        raise NotImplementedError()
+        ...
```

### Comparing `stk-2022.6.17.0/src/stk/ea/crossover/crossers/molecule/genetic_recombination.py` & `stk-2023.7.5.0/src/stk/_internal/ea/crossover/genetic_recombination.py`

 * *Files 5% similar despite different names*

```diff
@@ -1,22 +1,18 @@
-"""
-Genetic Recombination
-=====================
-
-"""
-
-import itertools as it
+import itertools
+import typing
 from collections import defaultdict
+from collections.abc import Callable, Iterable, Iterator, Sequence
 
-from ....molecule_records import MoleculeRecord
-from ...records import CrossoverRecord
-from .crosser import MoleculeCrosser
+from stk._internal.building_block import BuildingBlock
+from stk._internal.ea.crossover.record import CrossoverRecord
+from stk._internal.ea.molecule_records.molecule import MoleculeRecord
 
 
-class GeneticRecombination(MoleculeCrosser):
+class GeneticRecombination:
     """
     Recombine building blocks using biological systems as a model.
 
     Overall, this crosser mimics how animals and plants inherit
     DNA from their parents, except generalized to work with any
     number of parents. First it is worth discussing some
     terminology. A gene is a the smallest packet of genetic
@@ -104,152 +100,151 @@
     the `get_gene` parameter. Then, to generate a single offspring, it
     picks a building block for every gene. The picked
     building blocks are used to construct the offspring. The
     topology graph of the offspring is one of the parent's.
     For obvious reasons, this approach works with any number of
     parents.
 
-    Examples
-    --------
-    *Crossing Constructed Molecules*
-
-    Note that any number of parents can be used for the crossover
-
-    .. testcode:: crossing-constructed-molecules
-
-        import stk
-
-        # Create the molecule records which will be crossed.
+    Examples:
+        *Crossing Constructed Molecules*
 
-        bb1 = stk.BuildingBlock('NCCN', [stk.PrimaryAminoFactory()])
-        bb2 = stk.BuildingBlock('O=CCCCC=O', [stk.AldehydeFactory()])
-        graph1 = stk.polymer.Linear((bb1, bb2), 'AB', 2)
-        polymer1  = stk.ConstructedMolecule(graph1)
-        record1 = stk.MoleculeRecord(graph1)
+        Note that any number of parents can be used for the crossover
 
-        bb3 = stk.BuildingBlock('NCCCN', [stk.PrimaryAminoFactory()])
-        bb4 = stk.BuildingBlock(
-            smiles='O=C[Si]CCC=O',
-            functional_groups=[stk.AldehydeFactory()],
-        )
-        graph2 = stk.polymer.Linear((bb3, bb4), 'AB', 2)
-        polymer2  = stk.ConstructedMolecule(graph2)
-        record2 = stk.MoleculeRecord(graph2)
+        .. testcode:: crossing-constructed-molecules
 
-        # Create the crosser.
+            import stk
 
-        def get_functional_group_type(building_block):
-            fg, = building_block.get_functional_groups(0)
-            return type(fg)
+            # Create the molecule records which will be crossed.
 
-        recombination = stk.GeneticRecombination(
-            get_gene=get_functional_group_type,
-        )
+            bb1 = stk.BuildingBlock('NCCN', [stk.PrimaryAminoFactory()])
+            bb2 = stk.BuildingBlock('O=CCCCC=O', [stk.AldehydeFactory()])
+            graph1 = stk.polymer.Linear((bb1, bb2), 'AB', 2)
+            polymer1  = stk.ConstructedMolecule(graph1)
+            record1 = stk.MoleculeRecord(graph1)
 
-        # Get the offspring molecules.
+            bb3 = stk.BuildingBlock('NCCCN', [stk.PrimaryAminoFactory()])
+            bb4 = stk.BuildingBlock(
+                smiles='O=C[Si]CCC=O',
+                functional_groups=[stk.AldehydeFactory()],
+            )
+            graph2 = stk.polymer.Linear((bb3, bb4), 'AB', 2)
+            polymer2  = stk.ConstructedMolecule(graph2)
+            record2 = stk.MoleculeRecord(graph2)
+
+            # Create the crosser.
+
+            def get_functional_group_type(building_block):
+                fg, = building_block.get_functional_groups(0)
+                return type(fg)
 
-        cohort1 = tuple(recombination.cross(
-            records=(record1, record2),
-        ))
+            recombination = stk.GeneticRecombination(
+                get_gene=get_functional_group_type,
+            )
 
-    .. testcode:: crossing-constructed-molecules
-        :hide:
+            # Get the offspring molecules.
 
-        _expected_cohort = (
-            polymer1,
-            polymer2,
-            stk.ConstructedMolecule(
-                topology_graph=stk.polymer.Linear(
-                    building_blocks=(bb1, bb4),
-                    repeating_unit='AB',
-                    num_repeating_units=2,
+            cohort1 = tuple(recombination.cross(
+                records=(record1, record2),
+            ))
+
+        .. testcode:: crossing-constructed-molecules
+            :hide:
+
+            _expected_cohort = (
+                polymer1,
+                polymer2,
+                stk.ConstructedMolecule(
+                    topology_graph=stk.polymer.Linear(
+                        building_blocks=(bb1, bb4),
+                        repeating_unit='AB',
+                        num_repeating_units=2,
+                    ),
                 ),
-            ),
-            stk.ConstructedMolecule(
-                topology_graph=stk.polymer.Linear(
-                    building_blocks=(bb2, bb3),
-                    repeating_unit='AB',
-                    num_repeating_units=2,
+                stk.ConstructedMolecule(
+                    topology_graph=stk.polymer.Linear(
+                        building_blocks=(bb2, bb3),
+                        repeating_unit='AB',
+                        num_repeating_units=2,
+                    ),
                 ),
-            ),
-        )
+            )
 
-        def _get_smiles(item):
-            if isinstance(item, stk.ConstructedMolecule):
-               return stk.Smiles().get_key(item)
-            return stk.Smiles().get_key(
-                molecule=item.get_molecule_record().get_molecule(),
-             )
-
-        _expected_smiles = set(map(_get_smiles, _expected_cohort))
-        _cohort_smiles = set(map(_get_smiles, cohort1))
-        assert _expected_smiles == _cohort_smiles
+            def _get_smiles(item):
+                if isinstance(item, stk.ConstructedMolecule):
+                   return stk.Smiles().get_key(item)
+                return stk.Smiles().get_key(
+                    molecule=item.get_molecule_record().get_molecule(),
+                 )
+
+            _expected_smiles = set(map(_get_smiles, _expected_cohort))
+            _cohort_smiles = set(map(_get_smiles, cohort1))
+            assert _expected_smiles == _cohort_smiles
 
     """
 
     def __init__(
         self,
-        get_gene,
-        name='GeneticRecombination',
-    ):
+        get_gene: Callable[[BuildingBlock], typing.Any],
+        name: str = "GeneticRecombination",
+    ) -> None:
         """
-        Initialize a :class:`GeneticRecombination` instance.
-
-        Parameters
-        ----------
-        get_gene : :class:`callable`
-            A :class:`callable`, which takes a :class:`.BuildingBlock`
-            object and returns its gene. To produce an offspring, one
-            of the building blocks from each gene is picked.
-
-        name : :class:`str`, optional
-            A name to identify the crosser instance.
+        Parameters:
+            get_gene:
+                A function, which takes a :class:`.BuildingBlock`
+                and returns its gene. To produce an offspring, one
+                of the building blocks from each gene is picked.
 
+            name:
+                A name to identify the crosser instance.
         """
 
         self._get_gene = get_gene
         self._name = name
 
-    def cross(self, records):
-        topology_graphs = (
-            record.get_topology_graph() for record in records
-        )
-        for topology_graph, alleles in it.product(
+    def cross(
+        self,
+        records: Sequence[MoleculeRecord],
+    ) -> Iterator[CrossoverRecord[MoleculeRecord]]:
+        topology_graphs = (record.get_topology_graph() for record in records)
+        for topology_graph, alleles in itertools.product(
             topology_graphs,
             self._get_alleles(records),
         ):
 
-            def get_replacement(building_block):
+            def get_replacement(
+                building_block: BuildingBlock,
+            ) -> BuildingBlock:
                 gene = self._get_gene(building_block)
                 return next(
-                    allele for allele in alleles
+                    allele
+                    for allele in alleles
                     if self._get_gene(allele) == gene
                 )
 
             topology_graph = topology_graph.with_building_blocks(
                 building_block_map={
                     building_block: get_replacement(building_block)
-                    for building_block
-                    in topology_graph.get_building_blocks()
+                    for building_block in topology_graph.get_building_blocks()
                 },
             )
             yield CrossoverRecord(
                 molecule_record=MoleculeRecord(
                     topology_graph=topology_graph,
                 ),
                 crosser_name=self._name,
             )
 
-    def _get_alleles(self, records):
+    def _get_alleles(
+        self,
+        records: Sequence[MoleculeRecord],
+    ) -> Iterable[tuple[BuildingBlock, ...]]:
         """
         Yield every possible combination of alleles.
 
         """
 
         genes = defaultdict(list)
-        topology_graphs = (
-            record.get_topology_graph() for record in records
-        )
+        topology_graphs = (record.get_topology_graph() for record in records)
         for topology_graph in topology_graphs:
             for allele in topology_graph.get_building_blocks():
                 genes[self._get_gene(allele)].append(allele)
-        return it.product(*genes.values())
+        return itertools.product(*genes.values())
```

### Comparing `stk-2022.6.17.0/src/stk/ea/crossover/records/record.py` & `stk-2023.7.5.0/src/stk/_internal/ea/crossover/record.py`

 * *Files 22% similar despite different names*

```diff
@@ -1,62 +1,54 @@
-"""
-Crossover Record
-=================
+import typing
 
-"""
+T = typing.TypeVar("T")
 
 
-class CrossoverRecord:
+class CrossoverRecord(typing.Generic[T]):
     """
     Abstract base class for a record of a crossover operation.
 
-    Notes
-    -----
-    You might notice that the public methods of this abstract base
-    class are implemented. This is just a default implementation, which
-    can be used directly by users and subclasses, but can also be
-    freely replaced during subclass implementation, if need be.
+    Notes:
+
+        You might notice that the public methods of this abstract base
+        class are implemented. This is just a default implementation, which
+        can be used directly by users and subclasses, but can also be
+        freely replaced during subclass implementation, if need be.
 
     """
 
-    def __init__(self, molecule_record, crosser_name):
+    def __init__(self, molecule_record: T, crosser_name: str) -> None:
         """
-        Initialize a :class:`.CrossoverRecord` instance.
+        Parameters:
 
-        Parameters
-        ----------
-        molecule_record : :class:`.MoleculeRecord`
-            The molecule produced by the crossover operation.
+            molecule_record:
+                The molecule produced by the crossover operation.
 
-        crosser_name : :class:`str`
-            The name of the crosser which carried out the crossover.
+            crosser_name:
+                The name of the crosser which carried out the crossover.
 
         """
 
         self._molecule_record = molecule_record
         self._crosser_name = crosser_name
 
-    def get_molecule_record(self):
+    def get_molecule_record(self) -> T:
         """
-        Get the :class:`.MoleculeRecord` produced by the crossover.
+        Get the molecule record produced by the crossover.
 
-        Returns
-        -------
-        :class:`.MoleculeRecord`
+        Returns:
             The molecule record.
 
         """
 
         return self._molecule_record
 
-    def get_crosser_name(self):
+    def get_crosser_name(self) -> str:
         """
         Get the name of the crosser which carried out the crossover.
 
-        Returns
-        -------
-        :class:`str`
+        Returns:
             The name of the crosser.
 
         """
 
         return self._crosser_name
```

### Comparing `stk-2022.6.17.0/src/stk/ea/evolutionary_algorithm/evolutionary_algorithm.py` & `stk-2023.7.5.0/src/stk/_internal/ea/evolutionary_algorithm/evolutionary_algorithm.py`

 * *Files 1% similar despite different names*

```diff
@@ -2,18 +2,19 @@
 Evolutionary Algorithm
 ======================
 
 """
 
 import logging
 
-from stk.molecular import Inchi
+from stk._internal.key_makers.inchi import Inchi
 
-from ..fitness_normalizers import NullFitnessNormalizer
-from .implementations import Parallel, Serial
+from ..fitness_normalizers.null import NullFitnessNormalizer
+from .implementations.parallel import Parallel
+from .implementations.serial import Serial
 
 logger = logging.getLogger(__name__)
 
 
 class EvolutionaryAlgorithm:
     """
     An abstract base class for evolutionary algorithms.
```

### Comparing `stk-2022.6.17.0/src/stk/ea/evolutionary_algorithm/implementations/implementation.py` & `stk-2023.7.5.0/src/stk/_internal/ea/evolutionary_algorithm/implementations/implementation.py`

 * *Files 5% similar despite different names*

```diff
@@ -2,15 +2,15 @@
 Evolutionary Algorithm Implementation
 =====================================
 
 """
 
 import itertools as it
 
-from stk.utilities import dedupe
+from stk._internal.utilities.utilities import dedupe
 
 from ...generation import Generation
 
 
 class Implementation:
     """
     An implementation of the default evolutionary algorithm.
@@ -51,89 +51,86 @@
             return self._mutator.mutate(batch[0])
 
         def get_key(record):
             return self._key_maker.get_key(record.get_molecule())
 
         population = self._initial_population
 
-        self._logger.info(
-            'Calculating fitness values of initial population.'
-        )
+        self._logger.info("Calculating fitness values of initial population.")
         population = tuple(self._with_fitness_values(map_, population))
-        population = tuple(self._fitness_normalizer.normalize(
-            population=population,
-        ))
+        population = tuple(
+            self._fitness_normalizer.normalize(
+                population=population,
+            )
+        )
         yield Generation(
             molecule_records=population,
             mutation_records=(),
             crossover_records=(),
         )
 
         for generation in range(1, num_generations):
-            self._logger.info(f'Starting generation {generation}.')
-            self._logger.info(
-                f'Population size is {len(population)}.'
-            )
+            self._logger.info(f"Starting generation {generation}.")
+            self._logger.info(f"Population size is {len(population)}.")
 
-            self._logger.info('Doing crossovers.')
-            crossover_records = tuple(
-                self._get_crossover_records(population)
-            )
+            self._logger.info("Doing crossovers.")
+            crossover_records = tuple(self._get_crossover_records(population))
 
-            self._logger.info('Doing mutations.')
+            self._logger.info("Doing mutations.")
             mutation_records = tuple(
-                record for record in map(
+                record
+                for record in map(
                     get_mutation_record,
                     self._mutation_selector.select(population),
                 )
                 if record is not None
             )
 
-            self._logger.info('Calculating fitness values.')
+            self._logger.info("Calculating fitness values.")
 
             offspring = (
-                record.get_molecule_record()
-                for record in crossover_records
+                record.get_molecule_record() for record in crossover_records
             )
             mutants = (
-                record.get_molecule_record()
-                for record in mutation_records
+                record.get_molecule_record() for record in mutation_records
             )
 
-            population = tuple(self._with_fitness_values(
-                map_=map_,
-                population=tuple(dedupe(
-                    iterable=it.chain(population, offspring, mutants),
-                    key=get_key,
-                )),
-            ))
             population = tuple(
-                self._fitness_normalizer.normalize(population)
+                self._with_fitness_values(
+                    map_=map_,
+                    population=tuple(
+                        dedupe(
+                            iterable=it.chain(population, offspring, mutants),
+                            key=get_key,
+                        )
+                    ),
+                )
             )
+            population = tuple(self._fitness_normalizer.normalize(population))
 
             population = tuple(
                 molecule_record
-                for molecule_record,
-                in self._generation_selector.select(population)
+                for molecule_record, in self._generation_selector.select(
+                    population
+                )
             )
 
             yield Generation(
                 molecule_records=population,
                 mutation_records=mutation_records,
                 crossover_records=crossover_records,
             )
 
     def _get_crossover_records(self, population):
         for batch in self._crossover_selector.select(population):
             yield from self._crosser.cross(batch)
 
     def _with_fitness_values(self, map_, population):
-        molecules = (record.get_molecule() for record in population)
         fitness_values = map_(
             self._fitness_calculator.get_fitness_value,
-            molecules,
+            population,
         )
         for record, fitness_value in zip(population, fitness_values):
             yield record.with_fitness_value(
                 fitness_value=fitness_value,
                 normalized=False,
             )
```

### Comparing `stk-2022.6.17.0/src/stk/ea/evolutionary_algorithm/implementations/parallel.py` & `stk-2023.7.5.0/src/stk/_internal/ea/evolutionary_algorithm/implementations/parallel.py`

 * *Files 0% similar despite different names*

```diff
@@ -25,15 +25,14 @@
         mutation_selector,
         crossover_selector,
         fitness_normalizer,
         key_maker,
         logger,
         num_processes,
     ):
-
         super().__init__(
             initial_population=initial_population,
             fitness_calculator=fitness_calculator,
             mutator=mutator,
             crosser=crosser,
             generation_selector=generation_selector,
             mutation_selector=mutation_selector,
```

### Comparing `stk-2022.6.17.0/src/stk/ea/fitness_calculators/fitness_function.py` & `stk-2023.7.5.0/src/stk/_internal/ea/fitness_calculators/fitness_function.py`

 * *Files 11% similar despite different names*

```diff
@@ -1,262 +1,270 @@
-"""
-Fitness Calculator
-==================
+import typing
+from collections import abc
 
-"""
+from stk._internal.databases.value import ValueDatabase
+from stk._internal.ea.molecule_records.molecule import MoleculeRecord
 
 from .fitness_calculator import FitnessCalculator
 
 
 class FitnessFunction(FitnessCalculator):
     """
     Takes a function and uses it as a fitness calculator.
 
-    Examples
-    --------
-    *Calculating Fitness Values*
-
-    .. testcode:: calculating-fitness-values
-
-        import stk
-
-        # First create a function to use as the fitness function. For
-        # example, assume that the fitness value is given by the number
-        # of atoms.
-        def get_num_atoms(molecule):
-            return molecule.get_num_atoms()
-
-        # Then use it to create a fitness calculator.
-        fitness_calculator = stk.FitnessFunction(
-            fitness_function=get_num_atoms,
-        )
-
-        # Use the fitness calculator to get fitness values.
-        value1 = fitness_calculator.get_fitness_value(
-            molecule=stk.BuildingBlock('BrCCBr'),
-        )
-
-    .. testcode:: calculating-fitness-values
-        :hide:
-
-        assert value1 == stk.BuildingBlock('BrCCBr').get_num_atoms()
-
-    *Storing Fitness Values in a Database*
-
-    Sometimes you want to store fitness values in a database, you
-    can do this by providing the `output_database` parameter.
-
-    .. testsetup:: storing-fitness-values-in-a-database
-
-        import stk
-
-        # Change the database used, so that when a developer
-        # runs the doctests locally, their "stk" database is not
-        # contaminated.
-        _test_database = '_stk_doctest_database'
-        _old_init = stk.ValueMongoDb
-        stk.ValueMongoDb = lambda mongo_client, collection: (
-            _old_init(
-                mongo_client=mongo_client,
-                database=_test_database,
-                collection=collection,
-            )
-        )
-
-        # Change the database MongoClient will connect to.
-
-        import os
-        import pymongo
-
-        _mongo_client = pymongo.MongoClient
-        _mongodb_uri = os.environ.get(
-            'MONGODB_URI',
-            'mongodb://localhost:27017/'
-        )
-        pymongo.MongoClient = lambda: _mongo_client(_mongodb_uri)
-
-    .. testcode:: storing-fitness-values-in-a-database
-
-        import stk
-        import pymongo
-
-        # Create a database which stores the fitness value of each
-        # molecule.
-        fitness_db = stk.ValueMongoDb(
-            # This connects to a local database - so make sure you have
-            # local MongoDB server running. You can also connect to
-            # a remote MongoDB with MongoClient(), read to pymongo
-            # docs to see how to do that.
-            mongo_client=pymongo.MongoClient(),
-            collection='fitness_values',
-        )
-
-        # Define a fitness function.
-        def get_num_atoms(molecule):
-            return molecule.get_num_atoms()
-
-        # Create a fitness calculator.
-        fitness_calculator = stk.FitnessFunction(
-            fitness_function=get_num_atoms,
-            output_database=fitness_db,
-        )
-
-        # Calculate fitness values.
-        value = fitness_calculator.get_fitness_value(
-            molecule=stk.BuildingBlock('BrCCBr'),
-        )
-
-        # You can retrieve the fitness values from the database.
-        value1 = fitness_db.get(stk.BuildingBlock('BrCCBr'))
-
-    .. testcode:: storing-fitness-values-in-a-database
-        :hide:
-
-        assert value == value1
-
-    .. testcleanup:: storing-fitness-values-in-a-database
-
-        stk.ValueMongoDb = _old_init
-        pymongo.MongoClient().drop_database(_test_database)
-        pymongo.MongoClient = _mongo_client
-
-    *Caching Fitness Values*
-
-    Usually, if you calculate the fitness value of a molecule, you
-    do not want to re-calculate it, because this may be expensive,
-    and the fitness value is going to be the
-    same anyway. By using the `input_database` parameter, together
-    with the `output_database` parameter, you can make sure you store
-    and retrieve calculated fitness values instead of repeating the
-    same calculation multiple times.
-
-    The `input_database` is checked before a calculation happens, to
-    see if the value already exists, while the `output_database` has
-    the calculated fitness value deposited into it.
-
-    .. testsetup:: caching-fitness-values
-
-        import stk
-
-        # Change the database used, so that when a developer
-        # runs the doctests locally, their "stk" database is not
-        # contaminated.
-        _test_database = '_stk_doctest_database'
-        _old_init = stk.ValueMongoDb
-        stk.ValueMongoDb = lambda mongo_client, collection: (
-            _old_init(
-                mongo_client=mongo_client,
-                database=_test_database,
-                collection=collection,
-            )
-        )
-
-        # Change the database MongoClient will connect to.
-
-        import os
-        import pymongo
-
-        _mongo_client = pymongo.MongoClient
-        _mongodb_uri = os.environ.get(
-            'MONGODB_URI',
-            'mongodb://localhost:27017/'
-        )
-        pymongo.MongoClient = lambda: _mongo_client(_mongodb_uri)
-
-    .. testcode:: caching-fitness-values
-
-        import stk
-        import pymongo
-
-        # You can use the same database for both the input_database
-        # and output_database parameters.
-        fitness_db = stk.ValueMongoDb(
-            # This connects to a local database - so make sure you have
-            # local MongoDB server running. You can also connect to
-            # a remote MongoDB with MongoClient(), read to pymongo
-            # docs to see how to do that.
-            mongo_client=pymongo.MongoClient(),
-            collection='fitness_values',
-        )
-
-        # Define a fitness function.
-        def get_num_atoms(molecule):
-            return molecule.get_num_atoms()
-
-        # Create a fitness calculator.
-        fitness_calculator = stk.FitnessFunction(
-            fitness_function=get_num_atoms,
-            input_database=fitness_db,
-            output_database=fitness_db,
-        )
-
-        # Assuming that a fitness value for this molecule was not
-        # deposited into the database in a previous session, this
-        # will calculate the fitness value.
-        value1 = fitness_calculator.get_fitness_value(
-            molecule=stk.BuildingBlock('BrCCBr'),
-        )
-        # This will not re-calculate the fitness value, instead,
-        # value1 will be retrieved from the database.
-        value2 = fitness_calculator.get_fitness_value(
-            molecule=stk.BuildingBlock('BrCCBr'),
-        )
-
-    .. testcode:: caching-fitness-values
-        :hide:
-
-        assert value1 == value2
-
-    .. testcleanup:: caching-fitness-values
-
-        stk.ValueMongoDb = _old_init
-        pymongo.MongoClient().drop_database(_test_database)
-        pymongo.MongoClient = _mongo_client
+    Examples:
 
+        *Calculating Fitness Values*
+
+        .. testcode:: calculating-fitness-values
+
+            import stk
+
+            # First create a function to use as the fitness function. For
+            # example, assume that the fitness value is given by the number
+            # of atoms.
+            def get_num_atoms(record):
+                return record.get_molecule().get_num_atoms()
+
+            # Then use it to create a fitness calculator.
+            fitness_calculator = stk.FitnessFunction(
+                fitness_function=get_num_atoms,
+            )
+
+            # Use the fitness calculator to get fitness values.
+            record = stk.MoleculeRecord(
+                topology_graph=stk.polymer.Linear(
+                    building_blocks=(stk.BuildingBlock('BrCCBr'), ),
+                    repeating_unit='A',
+                    num_repeating_units=1,
+                ),
+            )
+            value1 = fitness_calculator.get_fitness_value(record)
+
+        .. testcode:: calculating-fitness-values
+            :hide:
+
+            assert value1 == stk.BuildingBlock('BrCCBr').get_num_atoms()
+
+        *Storing Fitness Values in a Database*
+
+        Sometimes you want to store fitness values in a database, you
+        can do this by providing the `output_database` parameter.
+
+        .. testsetup:: storing-fitness-values-in-a-database
+
+            import stk
+
+            # Change the database used, so that when a developer
+            # runs the doctests locally, their "stk" database is not
+            # contaminated.
+            _test_database = '_stk_doctest_database'
+            _old_init = stk.ValueMongoDb
+            stk.ValueMongoDb = lambda mongo_client, collection: (
+                _old_init(
+                    mongo_client=mongo_client,
+                    database=_test_database,
+                    collection=collection,
+                )
+            )
+
+            # Change the database MongoClient will connect to.
+
+            import os
+            import pymongo
+
+            _mongo_client = pymongo.MongoClient
+            _mongodb_uri = os.environ.get(
+                'MONGODB_URI',
+                'mongodb://localhost:27017/'
+            )
+            pymongo.MongoClient = lambda: _mongo_client(_mongodb_uri)
+
+        .. testcode:: storing-fitness-values-in-a-database
+
+            import stk
+            import pymongo
+
+            # Create a database which stores the fitness value of each
+            # molecule.
+            fitness_db = stk.ValueMongoDb(
+                # This connects to a local database - so make sure you have
+                # local MongoDB server running. You can also connect to
+                # a remote MongoDB with MongoClient(), read to pymongo
+                # docs to see how to do that.
+                mongo_client=pymongo.MongoClient(),
+                collection='fitness_values',
+            )
+
+            # Define a fitness function.
+            def get_num_atoms(record):
+                return record.get_molecule().get_num_atoms()
+
+            # Create a fitness calculator.
+            fitness_calculator = stk.FitnessFunction(
+                fitness_function=get_num_atoms,
+                output_database=fitness_db,
+            )
+
+            # Calculate fitness values.
+            record = stk.MoleculeRecord(
+                topology_graph=stk.polymer.Linear(
+                    building_blocks=(stk.BuildingBlock('BrCCBr'), ),
+                    repeating_unit='A',
+                    num_repeating_units=1,
+                ),
+            )
+            value = fitness_calculator.get_fitness_value(record)
+
+            # You can retrieve the fitness values from the database.
+            value1 = fitness_db.get(stk.BuildingBlock('BrCCBr'))
+
+        .. testcode:: storing-fitness-values-in-a-database
+            :hide:
+
+            assert value == value1
+
+        .. testcleanup:: storing-fitness-values-in-a-database
+
+            stk.ValueMongoDb = _old_init
+            pymongo.MongoClient().drop_database(_test_database)
+            pymongo.MongoClient = _mongo_client
+
+        *Caching Fitness Values*
+
+        Usually, if you calculate the fitness value of a molecule, you
+        do not want to re-calculate it, because this may be expensive,
+        and the fitness value is going to be the
+        same anyway. By using the `input_database` parameter, together
+        with the `output_database` parameter, you can make sure you store
+        and retrieve calculated fitness values instead of repeating the
+        same calculation multiple times.
+
+        The `input_database` is checked before a calculation happens, to
+        see if the value already exists, while the `output_database` has
+        the calculated fitness value deposited into it.
+
+        .. testsetup:: caching-fitness-values
+
+            import stk
+
+            # Change the database used, so that when a developer
+            # runs the doctests locally, their "stk" database is not
+            # contaminated.
+            _test_database = '_stk_doctest_database'
+            _old_init = stk.ValueMongoDb
+            stk.ValueMongoDb = lambda mongo_client, collection: (
+                _old_init(
+                    mongo_client=mongo_client,
+                    database=_test_database,
+                    collection=collection,
+                )
+            )
+
+            # Change the database MongoClient will connect to.
+
+            import os
+            import pymongo
+
+            _mongo_client = pymongo.MongoClient
+            _mongodb_uri = os.environ.get(
+                'MONGODB_URI',
+                'mongodb://localhost:27017/'
+            )
+            pymongo.MongoClient = lambda: _mongo_client(_mongodb_uri)
+
+        .. testcode:: caching-fitness-values
+
+            import stk
+            import pymongo
+
+            # You can use the same database for both the input_database
+            # and output_database parameters.
+            fitness_db = stk.ValueMongoDb(
+                # This connects to a local database - so make sure you have
+                # local MongoDB server running. You can also connect to
+                # a remote MongoDB with MongoClient(), read to pymongo
+                # docs to see how to do that.
+                mongo_client=pymongo.MongoClient(),
+                collection='fitness_values',
+            )
+
+            # Define a fitness function.
+            def get_num_atoms(record):
+                return record.get_molecule().get_num_atoms()
+
+            # Create a fitness calculator.
+            fitness_calculator = stk.FitnessFunction(
+                fitness_function=get_num_atoms,
+                input_database=fitness_db,
+                output_database=fitness_db,
+            )
+
+            # Assuming that a fitness value for this molecule was not
+            # deposited into the database in a previous session, this
+            # will calculate the fitness value.
+            record = stk.MoleculeRecord(
+                topology_graph=stk.polymer.Linear(
+                    building_blocks=(stk.BuildingBlock('BrCCBr'), ),
+                    repeating_unit='A',
+                    num_repeating_units=1,
+                ),
+            )
+            value1 = fitness_calculator.get_fitness_value(record)
+            # This will not re-calculate the fitness value, instead,
+            # value1 will be retrieved from the database.
+            value2 = fitness_calculator.get_fitness_value(record)
+
+        .. testcode:: caching-fitness-values
+            :hide:
+
+            assert value1 == value2
+
+        .. testcleanup:: caching-fitness-values
+
+            stk.ValueMongoDb = _old_init
+            pymongo.MongoClient().drop_database(_test_database)
+            pymongo.MongoClient = _mongo_client
     """
 
     def __init__(
         self,
-        fitness_function,
-        input_database=None,
-        output_database=None,
-    ):
+        fitness_function: abc.Callable[[MoleculeRecord], typing.Any],
+        input_database: ValueDatabase | None = None,
+        output_database: ValueDatabase | None = None,
+    ) -> None:
         """
-        Initialize a :class:`.FitnessFunction` instance.
-
-        Parameters
-        ----------
-        fitness_function : :class:`callable`
-            Takes a single parameter, the
-            :class:`.ConstructedMolecule` whose
-            fitness needs to be calculated, and returns its
-            fitness value.
-
-        input_database : :class:`.ValueDatabase`, optional
-            A database to check before calling `fitness_function`. If a
-            fitness value exists for a molecule in the database, the
-            stored value is returned, instead of calling
-            `fitness_function`.
-
-        output_database : :class:`.ValueDatabase`, optional
-            A database into which the calculate fitness value is
-            placed.
-
+        Parameters:
+            fitness_function:
+                Takes a single parameter, the molecule
+                whose fitness needs to be calculated, and returns its
+                fitness value.
+
+            input_database:
+                A database to check before calling `fitness_function`. If a
+                fitness value exists for a molecule in the database, the
+                stored value is returned, instead of calling
+                `fitness_function`.
+
+            output_database:
+                A database into which the calculate fitness value is
+                placed.
         """
-
         self._fitness_function = fitness_function
         self._input_database = input_database
         self._output_database = output_database
 
-    def get_fitness_value(self, molecule):
+    def get_fitness_value(self, record: MoleculeRecord) -> typing.Any:
         if self._input_database is not None:
             try:
-                fitness_value = self._input_database.get(molecule)
+                fitness_value = self._input_database.get(
+                    molecule=record.get_molecule(),
+                )
             except KeyError:
-                fitness_value = self._fitness_function(molecule)
+                fitness_value = self._fitness_function(record)
         else:
-            fitness_value = self._fitness_function(molecule)
+            fitness_value = self._fitness_function(record)
 
         if self._output_database is not None:
-            self._output_database.put(molecule, fitness_value)
+            self._output_database.put(record.get_molecule(), fitness_value)
 
         return fitness_value
```

### Comparing `stk-2022.6.17.0/src/stk/ea/fitness_calculators/property_vector.py` & `stk-2023.7.5.0/src/stk/_internal/ea/fitness_calculators/property_vector.py`

 * *Files 22% similar despite different names*

```diff
@@ -1,309 +1,315 @@
-"""
-Property Vector
-===============
+import typing
+from collections import abc
 
-"""
+from stk._internal.databases.value import ValueDatabase
+from stk._internal.ea.molecule_records.molecule import MoleculeRecord
 
 from .fitness_calculator import FitnessCalculator
 
 
 class PropertyVector(FitnessCalculator):
     """
     Uses multiple molecular properties as a fitness value.
 
-    Examples
-    --------
-    *Calculating Fitness Values*
-
-    .. testcode:: calculating-fitness-values
-
-        import stk
-
-        # First, create the functions which calculate the properties
-        # of molecules.
-        def get_num_atoms(molecule):
-            return molecule.get_num_atoms()
-
-        def get_num_bonds(molecule):
-            return molecule.get_num_bonds()
-
-        def get_diameter(molecule):
-            return molecule.get_maximum_diameter()
-
-        # Next, create the fitness calculator.
-        fitness_calculator = stk.PropertyVector(
-            property_functions=(
-                get_num_atoms,
-                get_num_bonds,
-                get_diameter,
-            ),
-        )
-
-        # Calculate the fitness value of a molecule.
-        # "value" is a tuple, holding the number of atoms, number of
-        # bonds and the diameter of the molecule.
-        value = fitness_calculator.get_fitness_value(
-            molecule=stk.BuildingBlock('BrCCBr'),
-        )
-
-    .. testcode:: calculating-fitness-values
-        :hide:
-
-        _bb = stk.BuildingBlock('BrCCBr')
-        assert value == (
-            _bb.get_num_atoms(),
-            _bb.get_num_bonds(),
-            _bb.get_maximum_diameter(),
-        )
-
-    *Storing Fitness Values in a Database*
-
-    Sometimes you want to store fitness values in a database, you
-    can do this by providing the `output_database` parameter.
-
-    .. testsetup:: storing-fitness-values-in-a-database
-
-        import stk
-
-        # Change the database used, so that when a developer
-        # runs the doctests locally, their "stk" database is not
-        # contaminated.
-        _test_database = '_stk_doctest_database'
-        _old_init = stk.ValueMongoDb
-        stk.ValueMongoDb = lambda mongo_client, collection: (
-            _old_init(
-                mongo_client=mongo_client,
-                database=_test_database,
-                collection=collection,
-            )
-        )
-
-        # Change the database MongoClient will connect to.
-
-        import os
-        import pymongo
-
-        _mongo_client = pymongo.MongoClient
-        _mongodb_uri = os.environ.get(
-            'MONGODB_URI',
-            'mongodb://localhost:27017/'
-        )
-        pymongo.MongoClient = lambda: _mongo_client(_mongodb_uri)
-
-    .. testcode:: storing-fitness-values-in-a-database
-
-        import stk
-        import pymongo
-
-        # Create a database which stores the fitness value of each
-        # molecule.
-        fitness_db = stk.ValueMongoDb(
-            # This connects to a local database - so make sure you have
-            # local MongoDB server running. You can also connect to
-            # a remote MongoDB with MongoClient(), read to pymongo
-            # docs to see how to do that.
-            mongo_client=pymongo.MongoClient(),
-            collection='fitness_values',
-        )
-
-        # Define the functions which calculate molecular properties.
-        def get_num_atoms(molecule):
-            return molecule.get_num_atoms()
-
-        def get_num_bonds(molecule):
-            return molecule.get_num_bonds()
-
-        def get_diameter(molecule):
-            return molecule.get_maximum_diameter()
-
-        # Create the fitness calculator.
-        fitness_calculator = stk.PropertyVector(
-            property_functions=(
-                get_num_atoms,
-                get_num_bonds,
-                get_diameter,
-            ),
-            output_database=fitness_db,
-        )
-
-        # Calculate fitness values.
-        value1 = fitness_calculator.get_fitness_value(
-            molecule=stk.BuildingBlock('BrCCBr'),
-        )
-
-        # You can retrieve the fitness values from the database.
-        value2 = fitness_db.get(stk.BuildingBlock('BrCCBr'))
-
-    .. testcode:: storing-fitness-values-in-a-database
-        :hide:
-
-        assert value1 == tuple(value2)
-
-    .. testcleanup:: storing-fitness-values-in-a-database
-
-        stk.ValueMongoDb = _old_init
-        pymongo.MongoClient().drop_database(_test_database)
-        pymongo.MongoClient = _mongo_client
-
-    *Caching Fitness Values*
-
-    Usually, if you calculate the fitness value of a molecule, you
-    do not want to re-calculate it, because this may be expensive,
-    and the fitness value is going to be the
-    same anyway. By using the `input_database` parameter, together
-    with the `output_database` parameter, you can make sure you store
-    and retrieve calculated fitness values instead of repeating the
-    same calculation multiple times.
-
-    The `input_database` is checked before a calculation happens, to
-    see if the value already exists, while the `output_database` has
-    the calculated fitness value deposited into it.
-
-    .. testsetup:: caching-fitness-values
-
-        import stk
-
-        # Change the database used, so that when a developer
-        # runs the doctests locally, their "stk" database is not
-        # contaminated.
-        _test_database = '_stk_doctest_database'
-        _old_init = stk.ValueMongoDb
-        stk.ValueMongoDb = lambda mongo_client, collection: (
-            _old_init(
-                mongo_client=mongo_client,
-                database=_test_database,
-                collection=collection,
-            )
-        )
-
-        # Change the database MongoClient will connect to.
-
-        import os
-        import pymongo
-
-        _mongo_client = pymongo.MongoClient
-        _mongodb_uri = os.environ.get(
-            'MONGODB_URI',
-            'mongodb://localhost:27017/'
-        )
-        pymongo.MongoClient = lambda: _mongo_client(_mongodb_uri)
-
-    .. testcode:: caching-fitness-values
-
-        import stk
-        import pymongo
-
-        # You can use the same database for both the input_database
-        # and output_database parameters.
-        fitness_db = stk.ValueMongoDb(
-            # This connects to a local database - so make sure you have
-            # local MongoDB server running. You can also connect to
-            # a remote MongoDB with MongoClient(), read to pymongo
-            # docs to see how to do that.
-            mongo_client=pymongo.MongoClient(),
-            collection='fitness_values',
-        )
-
-        # Define the functions which calculate molecular properties.
-        def get_num_atoms(molecule):
-            return molecule.get_num_atoms()
-
-        def get_num_bonds(molecule):
-            return molecule.get_num_bonds()
-
-        def get_diameter(molecule):
-            return molecule.get_maximum_diameter()
-
-        # Create the fitness calculator.
-        fitness_calculator = stk.PropertyVector(
-            property_functions=(
-                get_num_atoms,
-                get_num_bonds,
-                get_diameter,
-            ),
-            input_database=fitness_db,
-            output_database=fitness_db,
-        )
-
-        # Assuming that a fitness value for this molecule was not
-        # deposited into the database in a previous session, this
-        # will calculate the fitness value.
-        value1 = fitness_calculator.get_fitness_value(
-            molecule=stk.BuildingBlock('BrCCBr'),
-        )
-        # This will not re-calculate the fitness value, instead,
-        # value1 will be retrieved from the database.
-        value2 = fitness_calculator.get_fitness_value(
-            molecule=stk.BuildingBlock('BrCCBr'),
-        )
-
-    .. testcode:: caching-fitness-values
-        :hide:
-
-        value3 = fitness_calculator.get_fitness_value(
-            molecule=stk.BuildingBlock('BrCCBr'),
-        )
-        assert value2 is value3
-
-    .. testcleanup:: caching-fitness-values
-
-        stk.ValueMongoDb = _old_init
-        pymongo.MongoClient().drop_database(_test_database)
-        pymongo.MongoClient = _mongo_client
+    Examples:
+
+        *Calculating Fitness Values*
+
+        .. testcode:: calculating-fitness-values
+
+            import stk
+
+            # First, create the functions which calculate the properties
+            # of molecules.
+            def get_num_atoms(record):
+                return record.get_molecule().get_num_atoms()
+
+            def get_num_bonds(record):
+                return record.get_molecule().get_num_bonds()
+
+            def get_diameter(record):
+                return record.get_molecule().get_maximum_diameter()
+
+            # Next, create the fitness calculator.
+            fitness_calculator = stk.PropertyVector(
+                property_functions=(
+                    get_num_atoms,
+                    get_num_bonds,
+                    get_diameter,
+                ),
+            )
+
+            # Calculate the fitness value of a molecule.
+            # "value" is a tuple, holding the number of atoms, number of
+            # bonds and the diameter of the molecule.
+            record = stk.MoleculeRecord(
+                topology_graph=stk.polymer.Linear(
+                    building_blocks=(stk.BuildingBlock('BrCCBr'), ),
+                    repeating_unit='A',
+                    num_repeating_units=1,
+                ),
+            )
+            value = fitness_calculator.get_fitness_value(record)
+
+        .. testcode:: calculating-fitness-values
+            :hide:
+
+            _bb = stk.BuildingBlock('BrCCBr')
+            assert value == (
+                _bb.get_num_atoms(),
+                _bb.get_num_bonds(),
+                _bb.get_maximum_diameter(),
+            )
+
+        *Storing Fitness Values in a Database*
+
+        Sometimes you want to store fitness values in a database, you
+        can do this by providing the `output_database` parameter.
+
+        .. testsetup:: storing-fitness-values-in-a-database
+
+            import stk
+
+            # Change the database used, so that when a developer
+            # runs the doctests locally, their "stk" database is not
+            # contaminated.
+            _test_database = '_stk_doctest_database'
+            _old_init = stk.ValueMongoDb
+            stk.ValueMongoDb = lambda mongo_client, collection: (
+                _old_init(
+                    mongo_client=mongo_client,
+                    database=_test_database,
+                    collection=collection,
+                )
+            )
+
+            # Change the database MongoClient will connect to.
+
+            import os
+            import pymongo
+
+            _mongo_client = pymongo.MongoClient
+            _mongodb_uri = os.environ.get(
+                'MONGODB_URI',
+                'mongodb://localhost:27017/'
+            )
+            pymongo.MongoClient = lambda: _mongo_client(_mongodb_uri)
+
+        .. testcode:: storing-fitness-values-in-a-database
+
+            import stk
+            import pymongo
+
+            # Create a database which stores the fitness value of each
+            # molecule.
+            fitness_db = stk.ValueMongoDb(
+                # This connects to a local database - so make sure you have
+                # local MongoDB server running. You can also connect to
+                # a remote MongoDB with MongoClient(), read to pymongo
+                # docs to see how to do that.
+                mongo_client=pymongo.MongoClient(),
+                collection='fitness_values',
+            )
+
+            # Define the functions which calculate molecular properties.
+            def get_num_atoms(record):
+                return record.get_molecule().get_num_atoms()
+
+            def get_num_bonds(record):
+                return record.get_molecule().get_num_bonds()
+
+            def get_diameter(record):
+                return record.get_molecule().get_maximum_diameter()
+
+            # Create the fitness calculator.
+            fitness_calculator = stk.PropertyVector(
+                property_functions=(
+                    get_num_atoms,
+                    get_num_bonds,
+                    get_diameter,
+                ),
+                output_database=fitness_db,
+            )
+
+            # Calculate fitness values.
+            record = stk.MoleculeRecord(
+                topology_graph=stk.polymer.Linear(
+                    building_blocks=(stk.BuildingBlock('BrCCBr'), ),
+                    repeating_unit='A',
+                    num_repeating_units=1,
+                ),
+            )
+            value1 = fitness_calculator.get_fitness_value(record)
+
+            # You can retrieve the fitness values from the database.
+            value2 = fitness_db.get(record.get_molecule())
+
+        .. testcode:: storing-fitness-values-in-a-database
+            :hide:
+
+            assert value1 == tuple(value2)
+
+        .. testcleanup:: storing-fitness-values-in-a-database
+
+            stk.ValueMongoDb = _old_init
+            pymongo.MongoClient().drop_database(_test_database)
+            pymongo.MongoClient = _mongo_client
+
+        *Caching Fitness Values*
+
+        Usually, if you calculate the fitness value of a molecule, you
+        do not want to re-calculate it, because this may be expensive,
+        and the fitness value is going to be the
+        same anyway. By using the `input_database` parameter, together
+        with the `output_database` parameter, you can make sure you store
+        and retrieve calculated fitness values instead of repeating the
+        same calculation multiple times.
+
+        The `input_database` is checked before a calculation happens, to
+        see if the value already exists, while the `output_database` has
+        the calculated fitness value deposited into it.
+
+        .. testsetup:: caching-fitness-values
+
+            import stk
+
+            # Change the database used, so that when a developer
+            # runs the doctests locally, their "stk" database is not
+            # contaminated.
+            _test_database = '_stk_doctest_database'
+            _old_init = stk.ValueMongoDb
+            stk.ValueMongoDb = lambda mongo_client, collection: (
+                _old_init(
+                    mongo_client=mongo_client,
+                    database=_test_database,
+                    collection=collection,
+                )
+            )
+
+            # Change the database MongoClient will connect to.
+
+            import os
+            import pymongo
+
+            _mongo_client = pymongo.MongoClient
+            _mongodb_uri = os.environ.get(
+                'MONGODB_URI',
+                'mongodb://localhost:27017/'
+            )
+            pymongo.MongoClient = lambda: _mongo_client(_mongodb_uri)
+
+        .. testcode:: caching-fitness-values
+
+            import stk
+            import pymongo
+
+            # You can use the same database for both the input_database
+            # and output_database parameters.
+            fitness_db = stk.ValueMongoDb(
+                # This connects to a local database - so make sure you have
+                # local MongoDB server running. You can also connect to
+                # a remote MongoDB with MongoClient(), read to pymongo
+                # docs to see how to do that.
+                mongo_client=pymongo.MongoClient(),
+                collection='fitness_values',
+            )
+
+            # Define the functions which calculate molecular properties.
+            def get_num_atoms(record):
+                return record.get_molecule().get_num_atoms()
+
+            def get_num_bonds(record):
+                return record.get_molecule().get_num_bonds()
+
+            def get_diameter(record):
+                return record.get_molecule().get_maximum_diameter()
+
+            # Create the fitness calculator.
+            fitness_calculator = stk.PropertyVector(
+                property_functions=(
+                    get_num_atoms,
+                    get_num_bonds,
+                    get_diameter,
+                ),
+                input_database=fitness_db,
+                output_database=fitness_db,
+            )
+
+            # Assuming that a fitness value for this molecule was not
+            # deposited into the database in a previous session, this
+            # will calculate the fitness value.
+            record = stk.MoleculeRecord(
+                topology_graph=stk.polymer.Linear(
+                    building_blocks=(stk.BuildingBlock('BrCCBr'), ),
+                    repeating_unit='A',
+                    num_repeating_units=1,
+                ),
+            )
+            value1 = fitness_calculator.get_fitness_value(record)
+            # This will not re-calculate the fitness value, instead,
+            # value1 will be retrieved from the database.
+            value2 = fitness_calculator.get_fitness_value(record)
+
+        .. testcode:: caching-fitness-values
+            :hide:
+
+            value3 = fitness_calculator.get_fitness_value(record)
+            assert value2 is value3
+
+        .. testcleanup:: caching-fitness-values
+
+            stk.ValueMongoDb = _old_init
+            pymongo.MongoClient().drop_database(_test_database)
+            pymongo.MongoClient = _mongo_client
 
     """
 
     def __init__(
         self,
-        property_functions,
-        input_database=None,
-        output_database=None,
-    ):
-
+        property_functions: abc.Iterable[
+            abc.Callable[[MoleculeRecord], typing.Any]
+        ],
+        input_database: ValueDatabase | None = None,
+        output_database: ValueDatabase | None = None,
+    ) -> None:
         """
-        Initialize a :class:`.PropertyVector` instance.
-
-        Parameters
-        ----------
-        property_functions: :class:`tuple` of :class:`callable`
-            A group of :class:`function`, each of which is used to
-            calculate a single property of the molecule. Each function
-            must take one parameter, `mol`, which accepts
-            a :class:`.Molecule` object. This is the molecule used to
-            calculate the property.
-
-        input_database : :class:`.ValueDatabase`, optional
-            A database to check before calling `fitness_function`. If a
-            fitness value exists for a molecule in the database, the
-            stored value is returned, instead of calling
-            `fitness_function`.
-
-        output_database : :class:`.ValueDatabase`, optional
-            A database into which the calculate fitness value is
-            placed.
-
+        Parameters:
+            property_functions:
+                A group of functions, each of which is used to
+                calculate a single property of the molecule.
+
+            input_database:
+                A database to check before calling `fitness_function`. If a
+                fitness value exists for a molecule in the database, the
+                stored value is returned, instead of calling
+                `fitness_function`.
+
+            output_database:
+                A database into which the calculate fitness value is
+                placed.
         """
-
-        self._property_functions = property_functions
+        self._property_functions = tuple(property_functions)
         self._input_database = input_database
         self._output_database = output_database
 
-    def get_fitness_value(self, molecule):
+    def get_fitness_value(self, molecule: MoleculeRecord) -> typing.Any:
         if self._input_database is not None:
             try:
-                fitness_value = self._input_database.get(molecule)
+                fitness_value = self._input_database.get(
+                    molecule=molecule.get_molecule(),
+                )
             except KeyError:
                 fitness_value = tuple(
                     property_function(molecule)
                     for property_function in self._property_functions
                 )
         else:
             fitness_value = tuple(
                 property_function(molecule)
                 for property_function in self._property_functions
             )
 
         if self._output_database is not None:
-            self._output_database.put(molecule, fitness_value)
+            self._output_database.put(molecule.get_molecule(), fitness_value)
 
         return fitness_value
```

### Comparing `stk-2022.6.17.0/src/stk/ea/fitness_normalizers/add.py` & `stk-2023.7.5.0/src/stk/_internal/ea/fitness_normalizers/add.py`

 * *Files identical despite different names*

### Comparing `stk-2022.6.17.0/src/stk/ea/fitness_normalizers/divide_by_mean.py` & `stk-2023.7.5.0/src/stk/_internal/ea/fitness_normalizers/divide_by_mean.py`

 * *Files 4% similar despite different names*

```diff
@@ -125,15 +125,15 @@
             partial(self._filter, population),
             population,
         )
         mean = np.mean(
             a=[record.get_fitness_value() for record in filtered],
             axis=0,
         )
-        logger.debug(f'Means used: {mean}')
+        logger.debug(f"Means used: {mean}")
 
         for record in population:
             if self._filter(population, record):
                 yield record.with_fitness_value(
                     fitness_value=np.divide(
                         record.get_fitness_value(),
                         mean,
```

### Comparing `stk-2022.6.17.0/src/stk/ea/fitness_normalizers/multiply.py` & `stk-2023.7.5.0/src/stk/_internal/ea/fitness_normalizers/multiply.py`

 * *Files identical despite different names*

### Comparing `stk-2022.6.17.0/src/stk/ea/fitness_normalizers/power.py` & `stk-2023.7.5.0/src/stk/_internal/ea/fitness_normalizers/power.py`

 * *Files identical despite different names*

### Comparing `stk-2022.6.17.0/src/stk/ea/fitness_normalizers/replace_fitness.py` & `stk-2023.7.5.0/src/stk/_internal/ea/fitness_normalizers/replace_fitness.py`

 * *Files identical despite different names*

### Comparing `stk-2022.6.17.0/src/stk/ea/fitness_normalizers/sequence.py` & `stk-2023.7.5.0/src/stk/_internal/ea/fitness_normalizers/sequence.py`

 * *Files identical despite different names*

### Comparing `stk-2022.6.17.0/src/stk/ea/fitness_normalizers/shift_up.py` & `stk-2023.7.5.0/src/stk/_internal/ea/fitness_normalizers/shift_up.py`

 * *Files 2% similar despite different names*

```diff
@@ -186,17 +186,15 @@
 
     def normalize(self, population):
         filtered = filter(
             partial(self._filter, population),
             population,
         )
         # Get all the fitness arrays in a matrix.
-        fmat = np.array([
-            record.get_fitness_value() for record in filtered
-        ])
+        fmat = np.array([record.get_fitness_value() for record in filtered])
 
         # Get the minimum value of each element across the population.
         # keepdims ensures that np.min returns a 1-D array, because
         # it will be True if fitness values are scalar and False if
         # they are array-valued.
         mins = np.min(fmat, axis=0, keepdims=len(fmat.shape) == 1)
```

### Comparing `stk-2022.6.17.0/src/stk/ea/fitness_normalizers/sum.py` & `stk-2023.7.5.0/src/stk/_internal/ea/fitness_normalizers/sum.py`

 * *Files identical despite different names*

### Comparing `stk-2022.6.17.0/src/stk/ea/generation.py` & `stk-2023.7.5.0/src/stk/_internal/ea/generation.py`

 * *Files identical despite different names*

### Comparing `stk-2022.6.17.0/src/stk/ea/mutation/mutators/compound/random.py` & `stk-2023.7.5.0/src/stk/_internal/ea/mutation/random_building_block.py`

 * *Files 20% similar despite different names*

```diff
@@ -1,157 +1,142 @@
-"""
-Random Mutator
-==============
-
-"""
-
+from collections.abc import Callable, Iterable
 
 import numpy as np
 
+from stk._internal.building_block import BuildingBlock
+from stk._internal.ea.molecule_records.molecule import MoleculeRecord
+from stk._internal.ea.mutation.record import MutationRecord
+
 
-class RandomMutator:
+class RandomBuildingBlock:
     """
-    Use some other mutator at random.
+    Substitutes random building blocks.
+
+    This mutator takes a :class:`.ConstructedMolecule` and substitutes
+    the building blocks with one chosen at random from a given set.
+
+    Examples:
+
+        *Constructed Molecule Mutation*
 
-    Examples
-    --------
-    *Use One of Several Mutators at Random*
-
-    .. testcode:: use-one-of-several-mutators-at-random
-
-        import stk
-
-        random_seed = 12
-        mutator = stk.RandomMutator(
-            mutators=(
-                stk.RandomBuildingBlock(
-                    building_blocks=(
-                        stk.BuildingBlock(
-                            smiles='BrCCBr',
-                            functional_groups=[stk.BromoFactory()],
-                        ),
-                        stk.BuildingBlock(
-                            smiles='BrCCCBr',
-                            functional_groups=[stk.BromoFactory()],
-                        ),
-                    ),
-                    is_replaceable=lambda building_block: True,
-                    random_seed=random_seed,
+        .. testcode:: constructed-molecule-mutation
+
+            import stk
+
+            # Create a molecule which is to be mutated.
+            bb1 = stk.BuildingBlock('NCCN', [stk.PrimaryAminoFactory()])
+            bb2 = stk.BuildingBlock('O=CCC=O', [stk.AldehydeFactory()])
+            polymer = stk.MoleculeRecord(
+                topology_graph=stk.polymer.Linear((bb1, bb2), 'AB', 3),
+            )
+
+            # Create molecules used to substitute building blocks.
+            building_blocks = (
+                stk.BuildingBlock(
+                    smiles='NC[Si]CCN',
+                    functional_groups=[stk.PrimaryAminoFactory()],
                 ),
-                stk.SimilarBuildingBlock(
-                    building_blocks=(
-                        stk.BuildingBlock(
-                            smiles='BrCCCCBr',
-                            functional_groups=[stk.BromoFactory()],
-                        ),
-                        stk.BuildingBlock(
-                            smiles='BrCCCCCBr',
-                            functional_groups=[stk.BromoFactory()],
-                        ),
-                    ),
-                    is_replaceable=lambda building_block: True,
-                    random_seed=random_seed,
+                stk.BuildingBlock(
+                    smiles='NCCCCCCCN',
+                    functional_groups=[stk.PrimaryAminoFactory()],
                 ),
-                stk.RandomBuildingBlock(
-                    building_blocks=(
-                        stk.BuildingBlock(
-                            smiles='BrCCNCBr',
-                            functional_groups=[stk.BromoFactory()],
-                        ),
-                        stk.BuildingBlock(
-                            smiles='BrCNCBr',
-                            functional_groups=[stk.BromoFactory()],
-                        ),
-                    ),
-                    is_replaceable=lambda building_block: True,
-                    random_seed=random_seed,
+                stk.BuildingBlock(
+                    smiles='NC1CCCCC1N',
+                    functional_groups=[stk.PrimaryAminoFactory()],
                 ),
-            ),
-        )
-        building_block = stk.BuildingBlock(
-            smiles='BrCNNCBr',
-            functional_groups=[stk.BromoFactory()],
-        )
-        record = stk.MoleculeRecord(
-            topology_graph=stk.polymer.Linear(
-                building_blocks=(building_block, ),
-                repeating_unit='A',
-                num_repeating_units=2,
-            ),
-        )
-        # Use one of the component mutators at random.
-        mutation_record1 = mutator.mutate(record)
-        # A different mutator may get selected at random the second,
-        # third, etc, time.
-        mutation_record2 = mutator.mutate(record)
+            )
 
-    .. testcode:: use-one-of-several-mutators-at-random
-        :hide:
+            # Create the mutator.
 
-        _smiles = stk.Smiles()
-        assert _smiles.get_key(record.get_molecule()) == 'BrCNNCCNNCBr'
+            def has_primary_amino_group(building_block):
+                fg, = building_block.get_functional_groups(0)
+                return type(fg) is stk.PrimaryAmino
 
-        _molecule1 = (
-            mutation_record1.get_molecule_record().get_molecule()
-        )
-        assert _smiles.get_key(_molecule1) != 'BrCNNCNNCBr'
+            random_bb = stk.RandomBuildingBlock(
+                building_blocks=building_blocks,
+                is_replaceable=has_primary_amino_group,
+            )
 
-        _molecule2 = (
-            mutation_record2.get_molecule_record().get_molecule()
-        )
-        assert _smiles.get_key(_molecule2) != 'BrCNNCNNCBr'
+            # Mutate a molecule.
+            mutation_record1 = random_bb.mutate(polymer)
 
+            # Mutate the molecule a second time.
+            mutation_record2 = random_bb.mutate(polymer)
 
     """
 
-    def __init__(self, mutators, weights=None, random_seed=None):
+    def __init__(
+        self,
+        building_blocks: Iterable[BuildingBlock],
+        is_replaceable: Callable[[BuildingBlock], bool],
+        name: str = "RandomBuildingBlock",
+        random_seed: int | np.random.Generator | None = None,
+    ) -> None:
         """
-        Initialize a :class:`.RandomMutator` instance.
+        Parameters:
+            building_blocks (list[BuildingBlock]):
+                A group of molecules which are used to replace building
+                blocks in molecules being mutated.
+
+            is_replaceable:
+                This function is applied to every building block in
+                the molecule being mutated. Building blocks
+                which returned ``True`` are liable for substitution
+                by one of the molecules in `building_blocks`.
 
-        Parameters
-        ----------
-        mutators : :class:`tuple`
-            Holds instances which have :meth:`.mutate` method. The
-            :meth:`.mutate` method must return an instance of
-            :class:`.MutationRecord`.
-
-        weights : :class:`tuple` of :class:`float`, optional
-            For each mutator, the probability that it will be chosen
-            whenever :meth:`.mutate` is called.
-            If ``None`` all `mutators` will have equal chance of being
-            selected.
-
-        random_seed : :class:`int`, optional
-            The random seed to use.
+            name:
+                A name to help identify the mutator instance.
 
+            random_seed:
+                The random seed to use.
         """
+        if random_seed is None or isinstance(random_seed, int):
+            random_seed = np.random.default_rng(random_seed)
 
-        self._mutators = mutators
-        self._weights = weights
-        self._generator = np.random.RandomState(random_seed)
+        self._building_blocks = tuple(building_blocks)
+        self._is_replaceable = is_replaceable
+        self._name = name
+        self._generator = random_seed
 
-    def mutate(self, record):
+    def mutate(self, record: MoleculeRecord) -> MutationRecord[MoleculeRecord]:
         """
         Return a mutant of `record`.
 
-        Parameters
-        ----------
-        record : :class:`.MoleculeRecord`
-            The molecule to be mutated.
-
-        Returns
-        -------
-        :class:`.MutationRecord`
-            A record of the mutation. The exact subclass of
-            :class:`.MutationRecord` depends on which mutator was
-            used.
-
-        None : :class:`NoneType`
-            If `record` cannot be mutated.
+        Parameters:
+            record:
+                The molecule to be mutated.
 
+        Returns:
+            A record of the mutation.
         """
+        # Choose the building block which undergoes mutation.
+        replaceable_building_blocks = tuple(
+            filter(
+                self._is_replaceable,
+                (
+                    bb
+                    for bb in record.get_molecule().get_building_blocks()
+                    # TODO: this is actually a type error -- maybe
+                    # get_building_blocks needs to return BuildingBlock
+                    # instances?
+                    if isinstance(bb, BuildingBlock)
+                ),
+            )
+        )
+        replaced_building_block = self._generator.choice(
+            a=replaceable_building_blocks,  # type: ignore
+        )
+        # Choose a replacement building block.
+        replacement = self._generator.choice(
+            self._building_blocks,  # type: ignore
+        )
 
-        mutator = self._generator.choice(
-            a=self._mutators,
-            p=self._weights,
+        # Build the new ConstructedMolecule.
+        graph = record.get_topology_graph().with_building_blocks(
+            {
+                replaced_building_block: replacement,
+            }
+        )
+        return MutationRecord(
+            molecule_record=MoleculeRecord(graph),
+            mutator_name=self._name,
         )
-        return mutator.mutate(record)
```

### Comparing `stk-2022.6.17.0/src/stk/ea/mutation/mutators/molecule/random_topology_graph.py` & `stk-2023.7.5.0/src/stk/_internal/ea/mutation/random_topology_graph.py`

 * *Files 18% similar despite different names*

```diff
@@ -1,93 +1,102 @@
-"""
-Random Topology Graph
-=====================
-
-"""
+from collections.abc import Callable, Iterable
 
 import numpy as np
 
-from ....molecule_records import MoleculeRecord
-from ...records import MutationRecord
-from .mutator import MoleculeMutator
+from stk._internal.ea.molecule_records.molecule import MoleculeRecord
+from stk._internal.ea.mutation.record import MutationRecord
+from stk._internal.topology_graphs.topology_graph.topology_graph import (
+    TopologyGraph,
+)
 
 
-class RandomTopologyGraph(MoleculeMutator):
+class RandomTopologyGraph:
     """
     Changes topology graphs at random.
 
-    Examples
-    --------
-    *Constructed Molecule Mutation*
-
-    .. testcode:: constructed-molecule-mutation
-
-        import stk
-
-        # Create a molecule which is to be mutated.
-        bb1 = stk.BuildingBlock('NCCN', [stk.PrimaryAminoFactory()])
-        bb2 = stk.BuildingBlock(
-            smiles='O=CCC(C=O)CC=O',
-            functional_groups=[stk.AldehydeFactory()],
-        )
-        cage = stk.MoleculeRecord(
-            topology_graph=stk.cage.FourPlusSix((bb1, bb2)),
-        )
+    Examples:
+        *Constructed Molecule Mutation*
 
-        # Create functions which replace the topology graph.
-        replacement_funcs = (
-            lambda graph:
-                stk.cage.TwoPlusThree(graph.get_building_blocks()),
-            lambda graph:
-                stk.cage.EightPlusTwelve(graph.get_building_blocks()),
-            lambda graph:
-                stk.cage.TwentyPlusThirty(graph.get_building_blocks()),
-        )
+        .. testcode:: constructed-molecule-mutation
+
+            import stk
+
+            # Create a molecule which is to be mutated.
+            bb1 = stk.BuildingBlock('NCCN', [stk.PrimaryAminoFactory()])
+            bb2 = stk.BuildingBlock(
+                smiles='O=CCC(C=O)CC=O',
+                functional_groups=[stk.AldehydeFactory()],
+            )
+            cage = stk.MoleculeRecord(
+                topology_graph=stk.cage.FourPlusSix((bb1, bb2)),
+            )
+
+            # Create functions which replace the topology graph.
+            replacement_funcs = (
+                lambda graph:
+                    stk.cage.TwoPlusThree(graph.get_building_blocks()),
+                lambda graph:
+                    stk.cage.EightPlusTwelve(graph.get_building_blocks()),
+                lambda graph:
+                    stk.cage.TwentyPlusThirty(graph.get_building_blocks()),
+            )
 
-        # Create the mutator.
-        random_topology = stk.RandomTopologyGraph(replacement_funcs)
+            # Create the mutator.
+            random_topology = stk.RandomTopologyGraph(replacement_funcs)
 
-        # Mutate a molecule.
-        mutation_record1 = random_topology.mutate(cage)
+            # Mutate a molecule.
+            mutation_record1 = random_topology.mutate(cage)
 
-        # Mutate the molecule a second time.
-        mutation_record2 = random_topology.mutate(cage)
+            # Mutate the molecule a second time.
+            mutation_record2 = random_topology.mutate(cage)
 
     """
 
     def __init__(
         self,
-        replacement_funcs,
-        name='RandomTopologyGraph',
-        random_seed=None,
-    ):
+        replacement_funcs: Iterable[Callable[[TopologyGraph], TopologyGraph]],
+        name: str = "RandomTopologyGraph",
+        random_seed: int | np.random.Generator | None = None,
+    ) -> None:
         """
-        Initialize a :class:`.RandomTopology` instance.
+        Parameters:
+            replacement_funcs \
+(list[collections.abc.Callable[[TopologyGraph], TopologyGraph]]):
+                Functions which take a topology graph and return
+                its replacement. One is selected at random each
+                time :meth:`.mutate` is called.
 
-        Parameters
-        ----------
-        replacement_funcs : :class:`tuple` of :class:`callable`
-            Each :class:`callable` takes a single parameter, a
-            :class:`.TopologyGraph`, and returns the
-            :class:`.TopologyGraph` which should replace it.
+            name:
+                A name to help identify the mutator instance.
 
-        name : :class:`str`, optional
-            A name to help identify the mutator instance.
-
-        random_seed : :class:`bool`, optional
-            The random seed to use.
+            random_seed:
+                The random seed to use.
 
         """
 
-        self._replacement_funcs = replacement_funcs
+        if random_seed is None or isinstance(random_seed, int):
+            random_seed = np.random.default_rng(random_seed)
+
+        self._replacement_funcs = tuple(replacement_funcs)
         self._name = name
-        self._generator = np.random.RandomState(random_seed)
+        self._generator = random_seed
 
-    def mutate(self, record):
+    def mutate(self, record: MoleculeRecord) -> MutationRecord[MoleculeRecord]:
+        """
+        Return a mutant of `record`.
+
+        Parameters:
+            record:
+                The molecule to be mutated.
+
+        Returns:
+            A record of the mutation or ``None``
+            if `record` cannot be mutated.
+        """
         replacement_func = self._generator.choice(
-            a=self._replacement_funcs,
+            a=self._replacement_funcs,  # type: ignore
         )
         replacement = replacement_func(record.get_topology_graph())
         return MutationRecord(
             molecule_record=MoleculeRecord(replacement),
             mutator_name=self._name,
         )
```

### Comparing `stk-2022.6.17.0/src/stk/ea/mutation/mutators/molecule/similar_building_block.py` & `stk-2023.7.5.0/src/stk/_internal/ea/mutation/similar_building_block.py`

 * *Files 13% similar despite different names*

```diff
@@ -1,189 +1,208 @@
-"""
-Similar Building Block
-======================
-
-"""
-
+import typing
+from collections.abc import Callable, Iterable, Iterator
 from functools import partial
 
 import numpy as np
 
-from stk.molecular import Inchi
-from stk.utilities import dice_similarity
-
-from ....molecule_records import MoleculeRecord
-from ...records import MutationRecord
-from .mutator import MoleculeMutator
+from stk._internal.building_block import BuildingBlock
+from stk._internal.ea.molecule_records.molecule import MoleculeRecord
+from stk._internal.ea.mutation.record import MutationRecord
+from stk._internal.key_makers.inchi import Inchi
+from stk._internal.key_makers.molecule import MoleculeKeyMaker
+from stk._internal.utilities.utilities import dice_similarity
 
 
-class SimilarBuildingBlock(MoleculeMutator):
+class SimilarBuildingBlock:
     """
     Substitutes similar building blocks.
 
     This mutator takes a :class:`.ConstructedMolecule` and substitutes
     the building blocks with the most similar one from a given set.
     Repeated mutations on the same molecule will substituted the next
     most similar molecule from the set.
 
-    Examples
-    --------
-    *Constructed Molecule Mutation*
-
-    .. testcode:: constructed-molecule-mutation
-
-        import stk
-
-        # Create a molecule which is to be mutated.
-        bb1 = stk.BuildingBlock('NCCN', [stk.PrimaryAminoFactory()])
-        bb2 = stk.BuildingBlock('O=CCC=O', [stk.AldehydeFactory()])
-        polymer = stk.MoleculeRecord(
-            topology_graph=stk.polymer.Linear((bb1, bb2), 'AB', 3),
-        )
+    Examples:
 
-        # Create molecules used to substitute building blocks.
-        building_blocks = (
-            stk.BuildingBlock(
-                smiles='NC[Si]CCN',
-                functional_groups=[stk.PrimaryAminoFactory()],
-            ),
-            stk.BuildingBlock(
-                smiles='NCCCCCCCN',
-                functional_groups=[stk.PrimaryAminoFactory()],
-            ),
-            stk.BuildingBlock(
-                smiles='NC1CCCCC1N',
-                functional_groups=[stk.PrimaryAminoFactory()],
-            ),
-        )
+        *Constructed Molecule Mutation*
 
-        # Create the mutator.
+        .. testcode:: constructed-molecule-mutation
 
-        def has_primary_amino_group(building_block):
-            fg, = building_block.get_functional_groups(0)
-            return type(fg) is stk.PrimaryAmino
-
-        similar_bb = stk.SimilarBuildingBlock(
-            building_blocks=building_blocks,
-            is_replaceable=has_primary_amino_group,
-        )
+            import stk
 
-        # Mutate a molecule.
-        mutation_record1 = similar_bb.mutate(polymer)
+            # Create a molecule which is to be mutated.
+            bb1 = stk.BuildingBlock('NCCN', [stk.PrimaryAminoFactory()])
+            bb2 = stk.BuildingBlock('O=CCC=O', [stk.AldehydeFactory()])
+            polymer = stk.MoleculeRecord(
+                topology_graph=stk.polymer.Linear((bb1, bb2), 'AB', 3),
+            )
+
+            # Create molecules used to substitute building blocks.
+            building_blocks = (
+                stk.BuildingBlock(
+                    smiles='NC[Si]CCN',
+                    functional_groups=[stk.PrimaryAminoFactory()],
+                ),
+                stk.BuildingBlock(
+                    smiles='NCCCCCCCN',
+                    functional_groups=[stk.PrimaryAminoFactory()],
+                ),
+                stk.BuildingBlock(
+                    smiles='NC1CCCCC1N',
+                    functional_groups=[stk.PrimaryAminoFactory()],
+                ),
+            )
+
+            # Create the mutator.
+
+            def has_primary_amino_group(building_block):
+                fg, = building_block.get_functional_groups(0)
+                return type(fg) is stk.PrimaryAmino
+
+            similar_bb = stk.SimilarBuildingBlock(
+                building_blocks=building_blocks,
+                is_replaceable=has_primary_amino_group,
+            )
 
-        # Mutate the molecule a second time.
-        mutation_record2 = similar_bb.mutate(polymer)
+            # Mutate a molecule.
+            mutation_record1 = similar_bb.mutate(polymer)
+
+            # Mutate the molecule a second time.
+            mutation_record2 = similar_bb.mutate(polymer)
 
     """
 
     def __init__(
         self,
-        building_blocks,
-        is_replaceable,
-        key_maker=Inchi(),
-        name='SimilarBuildingBlock',
-        random_seed=None,
-    ):
+        building_blocks: Iterable[BuildingBlock],
+        is_replaceable: Callable[[BuildingBlock], bool],
+        key_maker: MoleculeKeyMaker = Inchi(),
+        name: str = "SimilarBuildingBlock",
+        random_seed: int | np.random.Generator | None = None,
+    ) -> None:
         """
-        Initialize a :class:`.SimilarBuildingBlock` instance.
-
-        Parameters
-        ----------
-        building_blocks : :class:`tuple` of :class:`.BuildingBlock`
-            A group of molecules which are used to replace building
-            blocks in molecules being mutated.
-
-        is_replaceable : :class:`callable`
-            A function which takes a :class:`.BuildingBlock` and
-            returns ``True`` or ``False``. This function is applied to
-            every building block in the molecule being mutated.
-            Building blocks which returned ``True`` are liable for
-            substitution by one of the molecules in `building_blocks`.
-
-        key_maker : :class:`.MoleculeKeyMaker`, optional
-            Molecules which return the same key, will iterate through
-            the same set of similar molecules.
+        Parameters:
 
-        name : :class:`str`, optional
-            A name to help identify the mutator instance.
+            building_blocks (list[BuildingBlock]):
+                A group of molecules which are used to replace building
+                blocks in molecules being mutated.
+
+            is_replaceable:
+                This function is applied to every building block in
+                the molecule being mutated. Building blocks
+                which returned ``True`` are liable for substitution
+                by one of the molecules in `building_blocks`.
+
+            key_maker:
+                Molecules which return the same key, will iterate through
+                the same set of similar molecules.
 
-        random_seed : :class:`bool`, optional
-            The random seed to use.
+            name:
+                A name to help identify the mutator instance.
 
+            random_seed:
+                The random seed to use.
         """
-
-        self._building_blocks = building_blocks
+        if random_seed is None or isinstance(random_seed, int):
+            random_seed = np.random.default_rng(random_seed)
+        self._building_blocks = tuple(building_blocks)
         self._is_replaceable = is_replaceable
         self._key_maker = key_maker
         self._name = name
-        self._generator = np.random.RandomState(random_seed)
-        self._similar_building_blocks = {}
+        self._generator = random_seed
+        self._similar_building_blocks: dict[
+            typing.Any, dict[typing.Any, Iterator[BuildingBlock]]
+        ] = {}
 
-    def mutate(self, record):
+    def mutate(self, record: MoleculeRecord) -> MutationRecord[MoleculeRecord]:
+        """
+        Return a mutant of `record`.
+
+        Parameters:
+            record:
+                The molecule to be mutated.
+
+        Returns:
+            A record of the mutation or ``None``
+            if `record` cannot be mutated.
+        """
         key = self._key_maker.get_key(record.get_molecule())
         if key not in self._similar_building_blocks:
             # Maps the key to a dict. The dict maps each
             # building block to an iterator.
             # The iterators yield the next most similar molecules in
             # `building_blocks` to the building block.
             self._similar_building_blocks[key] = {}
 
         similar_building_blocks = self._similar_building_blocks[key]
 
         # Choose the building block which undergoes mutation.
-        replaceable_building_blocks = tuple(filter(
-            self._is_replaceable,
-            record.get_molecule().get_building_blocks(),
-        ))
+        replaceable_building_blocks = tuple(
+            filter(
+                self._is_replaceable,
+                (
+                    bb
+                    for bb in record.get_molecule().get_building_blocks()
+                    # TODO: this is actually a type error -- maybe
+                    # get_building_blocks needs to return BuildingBlock
+                    # instances?
+                    if isinstance(bb, BuildingBlock)
+                ),
+            )
+        )
         replaced_building_block = self._generator.choice(
-            a=replaceable_building_blocks,
+            a=replaceable_building_blocks,  # type: ignore
         )
 
         # If the building block has not been chosen before, create an
         # iterator yielding similar molecules from `building_blocks`
         # for it.
         replaced_key = self._key_maker.get_key(replaced_building_block)
         if replaced_key not in similar_building_blocks:
-            similar_building_blocks[replaced_key] = iter(sorted(
-                self._building_blocks,
-                key=partial(dice_similarity, replaced_building_block),
-                reverse=True,
-            ))
+            similar_building_blocks[replaced_key] = iter(
+                sorted(
+                    self._building_blocks,
+                    key=partial(dice_similarity, replaced_building_block),
+                    reverse=True,
+                )
+            )
 
         try:
             replacement = next(similar_building_blocks[replaced_key])
         except StopIteration:
-            similar_building_blocks[replaced_key] = iter(sorted(
-                self._building_blocks,
-                key=partial(dice_similarity, replaced_building_block),
-                reverse=True,
-            ))
+            similar_building_blocks[replaced_key] = iter(
+                sorted(
+                    self._building_blocks,
+                    key=partial(dice_similarity, replaced_building_block),
+                    reverse=True,
+                )
+            )
             replacement = next(similar_building_blocks[replaced_key])
 
         # If the most similar molecule in `building_blocks` is itself,
         # then take the next most similar one.
         if self._key_maker.get_key(replacement) == replaced_key:
             try:
-                replacement = next(
-                    similar_building_blocks[replaced_key]
-                )
+                replacement = next(similar_building_blocks[replaced_key])
             except StopIteration:
-                similar_building_blocks[replaced_key] = iter(sorted(
-                    self._building_blocks,
-                    key=partial(
-                        dice_similarity,
-                        replaced_building_block,
-                    ),
-                    reverse=True,
-                ))
-                replacement = next(
-                    similar_building_blocks[replaced_key]
+                similar_building_blocks[replaced_key] = iter(
+                    sorted(
+                        self._building_blocks,
+                        key=partial(
+                            dice_similarity,
+                            replaced_building_block,
+                        ),
+                        reverse=True,
+                    )
                 )
+                replacement = next(similar_building_blocks[replaced_key])
 
         # Build the new ConstructedMolecule.
-        graph = record.get_topology_graph().with_building_blocks({
-            replaced_building_block: replacement,
-        })
+        graph = record.get_topology_graph().with_building_blocks(
+            {
+                replaced_building_block: replacement,
+            }
+        )
         return MutationRecord(
             molecule_record=MoleculeRecord(graph),
             mutator_name=self._name,
         )
```

### Comparing `stk-2022.6.17.0/src/stk/ea/plotters/progress.py` & `stk-2023.7.5.0/src/stk/_internal/ea/plotters/progress.py`

 * *Files 10% similar despite different names*

```diff
@@ -1,323 +1,322 @@
-"""
-Progress Plotter
-================
-
-"""
+import typing
+from collections.abc import Callable, Iterable
 
 import matplotlib.pyplot as plt
 import numpy as np
 import pandas as pd
 import seaborn as sns
 
-plt.switch_backend('agg')
+from stk._internal.ea.generation import Generation
+from stk._internal.ea.molecule_records.molecule import MoleculeRecord
+
+plt.switch_backend("agg")
 
 
 class ProgressPlotter:
     """
     Plots how a property changes during an EA run.
 
     The produced plot will show the EA generations on the x axis and
     the min, mean and max values of an attribute on the y axis.
 
-    Examples
-    --------
-    *Plotting How Fitness Values Change Across Generations*
-
-    .. testcode:: plotting-how-fitness-values-change-across-generations
-
-        import stk
-
-        # Initialize an EA somehow.
-        ea = stk.EvolutionaryAlgorithm(
-            initial_population=(
-                stk.MoleculeRecord(
-                    topology_graph=stk.polymer.Linear(
-                        building_blocks=(
-                            stk.BuildingBlock(
-                                smiles='BrCCBr',
-                                functional_groups=[stk.BromoFactory()],
+    Examples:
+
+        *Plotting How Fitness Values Change Across Generations*
+
+        .. testcode:: plotting-how-fitness-values-change-across-generations
+
+            import stk
+
+            # Initialize an EA somehow.
+            ea = stk.EvolutionaryAlgorithm(
+                initial_population=(
+                    stk.MoleculeRecord(
+                        topology_graph=stk.polymer.Linear(
+                            building_blocks=(
+                                stk.BuildingBlock(
+                                    smiles='BrCCBr',
+                                    functional_groups=[stk.BromoFactory()],
+                                ),
                             ),
+                            repeating_unit='A',
+                            num_repeating_units=i,
+                        ),
+                    )
+                    for i in range(2, 22)
+                ),
+                fitness_calculator=stk.FitnessFunction(
+                    fitness_function=lambda record:
+                        record.get_molecule().get_num_atoms(),
+                ),
+                mutator=stk.RandomBuildingBlock(
+                    building_blocks=(
+                        stk.BuildingBlock(
+                            smiles='BrC[Si]CCBr',
+                            functional_groups=[stk.BromoFactory()],
+                        ),
+                        stk.BuildingBlock(
+                            smiles='BrCCCCCCCBr',
+                            functional_groups=[stk.BromoFactory()],
                         ),
-                        repeating_unit='A',
-                        num_repeating_units=i,
-                    ),
-                )
-                for i in range(2, 22)
-            ),
-            fitness_calculator=stk.FitnessFunction(
-                fitness_function=lambda molecule:
-                    molecule.get_num_atoms(),
-            ),
-            mutator=stk.RandomBuildingBlock(
-                building_blocks=(
-                    stk.BuildingBlock(
-                        smiles='BrC[Si]CCBr',
-                        functional_groups=[stk.BromoFactory()],
-                    ),
-                    stk.BuildingBlock(
-                        smiles='BrCCCCCCCBr',
-                        functional_groups=[stk.BromoFactory()],
                     ),
+                    is_replaceable=lambda building_block: True
+                ),
+                crosser=stk.GeneticRecombination(
+                    get_gene=lambda building_block: 0
                 ),
-                is_replaceable=lambda building_block: True
-            ),
-            crosser=stk.GeneticRecombination(
-                get_gene=lambda building_block: 0
-            ),
-            generation_selector=stk.Best(
-                num_batches=22,
-                duplicate_molecules=False,
-            ),
-            mutation_selector=stk.Roulette(
-                num_batches=5,
-                random_seed=10,
-            ),
-            crossover_selector=stk.Roulette(
-                num_batches=5,
-                batch_size=2,
-                random_seed=10,
-            ),
-            num_processes=1,
-        )
-
-        generations = []
-        for generation in ea.get_generations(10):
-            generations.append(generation)
-
-        # Make the plotter which plots the fitness change across
-        # generations.
-        progress = stk.ProgressPlotter(
-            generations=generations,
-            get_property=lambda record: record.get_fitness_value(),
-            y_label='Fitness'
-        )
-        progress.write('fitness_plot.png')
-
-    .. testcode:: plotting-how-fitness-values-change-across-generations
-        :hide:
-
-        import os
-
-        assert os.path.exists('fitness_plot.png')
-        os.remove('fitness_plot.png')
-
-    *Plotting How a Molecular Property Changes Across Generations*
-
-    As an example, plotting how the number of atoms changes across
-    generations
-
-    .. testcode:: plotting-how-a-molecular-property-changes
-
-        import stk
-
-        # Initialize an EA somehow.
-        ea = stk.EvolutionaryAlgorithm(
-            initial_population=(
-                stk.MoleculeRecord(
-                    topology_graph=stk.polymer.Linear(
-                        building_blocks=(
-                            stk.BuildingBlock(
-                                smiles='BrCCBr',
-                                functional_groups=[stk.BromoFactory()],
+                generation_selector=stk.Best(
+                    num_batches=22,
+                    duplicate_molecules=False,
+                ),
+                mutation_selector=stk.Roulette(
+                    num_batches=5,
+                    random_seed=10,
+                ),
+                crossover_selector=stk.Roulette(
+                    num_batches=5,
+                    batch_size=2,
+                    random_seed=10,
+                ),
+                num_processes=1,
+            )
+
+            generations = []
+            for generation in ea.get_generations(10):
+                generations.append(generation)
+
+            # Make the plotter which plots the fitness change across
+            # generations.
+            progress = stk.ProgressPlotter(
+                generations=generations,
+                get_property=lambda record: record.get_fitness_value(),
+                y_label='Fitness'
+            )
+            progress.write('fitness_plot.png')
+
+        .. testcode:: plotting-how-fitness-values-change-across-generations
+            :hide:
+
+            import os
+
+            assert os.path.exists('fitness_plot.png')
+            os.remove('fitness_plot.png')
+
+        *Plotting How a Molecular Property Changes Across Generations*
+
+        As an example, plotting how the number of atoms changes across
+        generations
+
+        .. testcode:: plotting-how-a-molecular-property-changes
+
+            import stk
+
+            # Initialize an EA somehow.
+            ea = stk.EvolutionaryAlgorithm(
+                initial_population=(
+                    stk.MoleculeRecord(
+                        topology_graph=stk.polymer.Linear(
+                            building_blocks=(
+                                stk.BuildingBlock(
+                                    smiles='BrCCBr',
+                                    functional_groups=[stk.BromoFactory()],
+                                ),
                             ),
+                            repeating_unit='A',
+                            num_repeating_units=i,
+                        ),
+                    )
+                    for i in range(2, 22)
+                ),
+                fitness_calculator=stk.FitnessFunction(
+                    fitness_function=lambda record:
+                        record.get_molecule().get_num_atoms(),
+                ),
+                mutator=stk.RandomBuildingBlock(
+                    building_blocks=(
+                        stk.BuildingBlock(
+                            smiles='BrC[Si]CCBr',
+                            functional_groups=[stk.BromoFactory()],
+                        ),
+                        stk.BuildingBlock(
+                            smiles='BrCCCCCCCBr',
+                            functional_groups=[stk.BromoFactory()],
                         ),
-                        repeating_unit='A',
-                        num_repeating_units=i,
-                    ),
-                )
-                for i in range(2, 22)
-            ),
-            fitness_calculator=stk.FitnessFunction(
-                fitness_function=lambda molecule:
-                    molecule.get_num_atoms(),
-            ),
-            mutator=stk.RandomBuildingBlock(
-                building_blocks=(
-                    stk.BuildingBlock(
-                        smiles='BrC[Si]CCBr',
-                        functional_groups=[stk.BromoFactory()],
-                    ),
-                    stk.BuildingBlock(
-                        smiles='BrCCCCCCCBr',
-                        functional_groups=[stk.BromoFactory()],
                     ),
+                    is_replaceable=lambda building_block: True
                 ),
-                is_replaceable=lambda building_block: True
-            ),
-            crosser=stk.GeneticRecombination(
-                get_gene=lambda building_block: 0
-            ),
-            generation_selector=stk.Best(
-                num_batches=22,
-                duplicate_molecules=False,
-            ),
-            mutation_selector=stk.Roulette(
-                num_batches=5,
-                random_seed=10,
-            ),
-            crossover_selector=stk.Roulette(
-                num_batches=5,
-                batch_size=2,
-                random_seed=10,
-            ),
-            num_processes=1,
-        )
-
-        generations = []
-        for generation in ea.get_generations(10):
-            generations.append(generation)
-
-        # Make the plotter which plots the number of atoms across
-        # generations.
-        progress = stk.ProgressPlotter(
-            generations=generations,
-            get_property=lambda record:
-                record.get_molecule().get_num_atoms(),
-            y_label='Number of Atoms'
-        )
-        progress.write('number_of_atoms_plot.png')
-
-    .. testcode:: plotting-how-a-molecular-property-changes
-        :hide:
-
-        import os
-
-        assert os.path.exists('number_of_atoms_plot.png')
-        os.remove('number_of_atoms_plot.png')
-
-    *Excluding Molecules From the Plot*
-
-    Sometimes, you want to ignore some molecules from the plot you
-    make. For example, If the fitness calculation failed on a
-    molecule, you not want to include in a plot of fitness.
-
-    .. testcode:: excluding-molecules-from-the-plot
-
-        import stk
-
-        # Initialize an EA somehow.
-        ea = stk.EvolutionaryAlgorithm(
-            initial_population=(
-                stk.MoleculeRecord(
-                    topology_graph=stk.polymer.Linear(
-                        building_blocks=(
-                            stk.BuildingBlock(
-                                smiles='BrCCBr',
-                                functional_groups=[stk.BromoFactory()],
+                crosser=stk.GeneticRecombination(
+                    get_gene=lambda building_block: 0
+                ),
+                generation_selector=stk.Best(
+                    num_batches=22,
+                    duplicate_molecules=False,
+                ),
+                mutation_selector=stk.Roulette(
+                    num_batches=5,
+                    random_seed=10,
+                ),
+                crossover_selector=stk.Roulette(
+                    num_batches=5,
+                    batch_size=2,
+                    random_seed=10,
+                ),
+                num_processes=1,
+            )
+
+            generations = []
+            for generation in ea.get_generations(10):
+                generations.append(generation)
+
+            # Make the plotter which plots the number of atoms across
+            # generations.
+            progress = stk.ProgressPlotter(
+                generations=generations,
+                get_property=lambda record:
+                    record.get_molecule().get_num_atoms(),
+                y_label='Number of Atoms'
+            )
+            progress.write('number_of_atoms_plot.png')
+
+        .. testcode:: plotting-how-a-molecular-property-changes
+            :hide:
+
+            import os
+
+            assert os.path.exists('number_of_atoms_plot.png')
+            os.remove('number_of_atoms_plot.png')
+
+        *Excluding Molecules From the Plot*
+
+        Sometimes, you want to ignore some molecules from the plot you
+        make. For example, If the fitness calculation failed on a
+        molecule, you not want to include in a plot of fitness.
+
+        .. testcode:: excluding-molecules-from-the-plot
+
+            import stk
+
+            # Initialize an EA somehow.
+            ea = stk.EvolutionaryAlgorithm(
+                initial_population=(
+                    stk.MoleculeRecord(
+                        topology_graph=stk.polymer.Linear(
+                            building_blocks=(
+                                stk.BuildingBlock(
+                                    smiles='BrCCBr',
+                                    functional_groups=[stk.BromoFactory()],
+                                ),
                             ),
+                            repeating_unit='A',
+                            num_repeating_units=i,
+                        ),
+                    )
+                    for i in range(2, 22)
+                ),
+                fitness_calculator=stk.FitnessFunction(
+                    fitness_function=lambda record:
+                        record.get_molecule().get_num_atoms(),
+                ),
+                mutator=stk.RandomBuildingBlock(
+                    building_blocks=(
+                        stk.BuildingBlock(
+                            smiles='BrC[Si]CCBr',
+                            functional_groups=[stk.BromoFactory()],
+                        ),
+                        stk.BuildingBlock(
+                            smiles='BrCCCCCCCBr',
+                            functional_groups=[stk.BromoFactory()],
                         ),
-                        repeating_unit='A',
-                        num_repeating_units=i,
-                    ),
-                )
-                for i in range(2, 22)
-            ),
-            fitness_calculator=stk.FitnessFunction(
-                fitness_function=lambda molecule:
-                    molecule.get_num_atoms(),
-            ),
-            mutator=stk.RandomBuildingBlock(
-                building_blocks=(
-                    stk.BuildingBlock(
-                        smiles='BrC[Si]CCBr',
-                        functional_groups=[stk.BromoFactory()],
-                    ),
-                    stk.BuildingBlock(
-                        smiles='BrCCCCCCCBr',
-                        functional_groups=[stk.BromoFactory()],
                     ),
+                    is_replaceable=lambda building_block: True
+                ),
+                crosser=stk.GeneticRecombination(
+                    get_gene=lambda building_block: 0
+                ),
+                generation_selector=stk.Best(
+                    num_batches=22,
+                    duplicate_molecules=False,
+                ),
+                mutation_selector=stk.Roulette(
+                    num_batches=5,
+                    random_seed=10,
+                ),
+                crossover_selector=stk.Roulette(
+                    num_batches=5,
+                    batch_size=2,
+                    random_seed=10,
                 ),
-                is_replaceable=lambda building_block: True
-            ),
-            crosser=stk.GeneticRecombination(
-                get_gene=lambda building_block: 0
-            ),
-            generation_selector=stk.Best(
-                num_batches=22,
-                duplicate_molecules=False,
-            ),
-            mutation_selector=stk.Roulette(
-                num_batches=5,
-                random_seed=10,
-            ),
-            crossover_selector=stk.Roulette(
-                num_batches=5,
-                batch_size=2,
-                random_seed=10,
-            ),
-            num_processes=1,
-        )
-
-        generations = []
-        for generation in ea.get_generations(10):
-            generations.append(generation)
-
-        # Make the plotter which plots the fitness change across
-        # generations.
-        progress = stk.ProgressPlotter(
-            generations=generations,
-            get_property=lambda record: record.get_fitness_value(),
-            y_label='Fitness',
-            # Only plot records whose unnormalized fitness value is not
-            # None, which means the fitness calculation did not fail.
-            filter=lambda record:
-                record.get_fitness_value(normalized=False) is not None,
-        )
-        progress.write('fitness_plot.png')
+                num_processes=1,
+            )
+
+            generations = []
+            for generation in ea.get_generations(10):
+                generations.append(generation)
+
+            # Make the plotter which plots the fitness change across
+            # generations.
+            progress = stk.ProgressPlotter(
+                generations=generations,
+                get_property=lambda record: record.get_fitness_value(),
+                y_label='Fitness',
+                # Only plot records whose unnormalized fitness value is not
+                # None, which means the fitness calculation did not fail.
+                filter=lambda record:
+                    record.get_fitness_value(normalized=False) is not None,
+            )
+            progress.write('fitness_plot.png')
 
-    .. testcode:: excluding-molecules-from-the-plot
-        :hide:
+        .. testcode:: excluding-molecules-from-the-plot
+            :hide:
 
-        import os
+            import os
 
-        assert os.path.exists('fitness_plot.png')
-        os.remove('fitness_plot.png')
+            assert os.path.exists('fitness_plot.png')
+            os.remove('fitness_plot.png')
 
     """
 
     def __init__(
         self,
-        generations,
-        get_property,
-        y_label,
-        filter=lambda record: True,
-    ):
+        generations: Iterable[Generation],
+        get_property: Callable[[MoleculeRecord], float],
+        y_label: str,
+        filter: Callable[[MoleculeRecord], bool] = lambda record: True,
+    ) -> None:
         """
-        Initialize a :class:`ProgressPlotter` instance.
+        Parameters:
 
-        Parameters
-        ----------
-        generations : :class:`iterable` of :class:`.Generation`
-            The generations of the EA, which are plotted.
-
-        get_property : :class:`callable`
-            A :class:`callable` which takes a :class:`.MoleculeRecord`
-            and returns a property value of that molecule, which is
-            used for the plot. The :class:`callable` must return a
-            valid value for each
-            :class:`.MoleculeRecord` in `generations`.
-
-        y_label : :class:`str`
-            The y label for the produced graph.
-
-        filter : :class:`callable`, optional
-            Takes an :class:`.MoleculeRecord` and returns
-            ``True`` or ``False``. Only records which return ``True``
-            are included in the plot. By default, all records will be
-            plotted.
+            generations (list[Generation]):
+                The generations of the EA, which are plotted.
 
+            get_property:
+                A :class:`callable` which takes a :class:`.MoleculeRecord`
+                and returns a property value of that molecule, which is
+                used for the plot. The :class:`callable` must return a
+                valid value for each
+                :class:`.MoleculeRecord` in `generations`.
+
+            y_label:
+                The y label for the produced graph.
+
+            filter:
+                Takes an :class:`.MoleculeRecord` and returns
+                ``True`` or ``False``. Only records which return ``True``
+                are included in the plot. By default, all records will be
+                plotted.
         """
-
         self._get_property = get_property
         self._y_label = y_label
         self._filter = filter
         self._plot_data = self._get_plot_data(generations)
 
-    def _get_plot_data(self, generations):
+    def _get_plot_data(
+        self,
+        generations: Iterable[Generation],
+    ) -> pd.DataFrame:
         self._num_generations = 0
         data = []
         for id_, generation in enumerate(generations):
             self._num_generations += 1
 
             filtered = filter(
                 self._filter,
@@ -329,80 +328,76 @@
             # anything for the generation.
             if not properties:
                 continue
 
             data.append(
                 pd.DataFrame(
                     data={
-                        'Generation': [id_, id_, id_],
+                        "Generation": [id_, id_, id_],
                         self._y_label: [
                             max(properties),
                             np.mean(properties),
                             min(properties),
                         ],
-                        'Type': ['Max', 'Mean', 'Min'],
+                        "Type": ["Max", "Mean", "Min"],
                     },
-                    index=['Generation', 'Generation', 'Generation'],
+                    index=["Generation", "Generation", "Generation"],
                 ),
             )
         return pd.concat(data, ignore_index=True)
 
-    def get_plot_data(self):
+    def get_plot_data(self) -> pd.DataFrame:
         """
         Get the plot data.
 
-        Returns
-        -------
-        :class:`pandas.DataFrame`
+        Returns:
             A data frame holding the plot data.
 
         """
 
         return self._plot_data.copy()
 
-    def write(self, path, dpi=500):
+    def write(self, path: str, dpi: int = 500) -> typing.Self:
         """
         Write a progress plot to a file.
 
-        Parameters
-        ----------
-        path : :class:`str`
-            The path into which the plot is written.
-
-        dpi : :class:`int`, optional
-            The dpi of the image.
-
-        Returns
-        -------
-        :class:`.ProgressPlotter`
-            The plotter is returned.
+        Parameters:
+
+            path:
+                The path into which the plot is written.
+
+            dpi:
+                The dpi of the image.
+
+        Returns:
+            ProgressPlotter: The plotter is returned.
 
         """
 
-        sns.set(style='darkgrid')
+        sns.set(style="darkgrid")
         fig = plt.figure(figsize=[8, 4.5])
-        palette = sns.color_palette('deep')
+        palette = sns.color_palette("deep")
 
         # It's possible that all values were filtered out, and trying
         # to plot an empty dataframe would raise an exception.
         if len(self._plot_data) != 0:
             sns.scatterplot(
-                x='Generation',
+                x="Generation",
                 y=self._y_label,
-                hue='Type',
+                hue="Type",
                 palette={
-                    'Max': palette[3],
-                    'Min': palette[0],
-                    'Mean': palette[2]
+                    "Max": palette[3],
+                    "Min": palette[0],
+                    "Mean": palette[2],
                 },
                 data=self._plot_data,
             )
         # Set the length of the axes to account for all generations,
         # as its possible the first or last ones were not included
         # due to being filtered out.
         plt.xlim(0, self._num_generations)
 
-        plt.legend(bbox_to_anchor=(1.15, 1), prop={'size': 9})
+        plt.legend(bbox_to_anchor=(1.15, 1), prop={"size": 9})
         plt.tight_layout()
         fig.savefig(path, dpi=dpi)
-        plt.close('all')
+        plt.close("all")
         return self
```

### Comparing `stk-2022.6.17.0/src/stk/ea/plotters/selection.py` & `stk-2023.7.5.0/src/stk/_internal/ea/plotters/selection.py`

 * *Files 5% similar despite different names*

```diff
@@ -7,17 +7,17 @@
 from collections import Counter
 from functools import wraps
 
 import matplotlib.pyplot as plt
 import pandas as pd
 import seaborn as sns
 
-from stk.molecular import InchiKey
+from stk._internal.key_makers.inchi_key import InchiKey
 
-plt.switch_backend('agg')
+plt.switch_backend("agg")
 
 
 class SelectionPlotter:
     """
     Plots which molecule records a :class:`.Selector` selects.
 
     Examples
@@ -81,21 +81,21 @@
 
     """
 
     def __init__(
         self,
         filename,
         selector,
-        x_label='Molecule: InChIKey - Fitness Value',
+        x_label="Molecule: InChIKey - Fitness Value",
         record_label=lambda record: (
-            f'{InchiKey().get_key(record.get_molecule())} - '
-            f'{record.get_fitness_value()}'
+            f"{InchiKey().get_key(record.get_molecule())} - "
+            f"{record.get_fitness_value()}"
         ),
         heat_map_value=lambda record: record.get_fitness_value(),
-        heat_map_label='Fitness',
+        heat_map_label="Fitness",
         order_by=lambda record: record.get_fitness_value(),
     ):
         """
         Initialize a :class:`.SelectionPlotter` instance.
 
         Parameters
         ----------
@@ -161,15 +161,14 @@
         :class:`function`
             The decorated :meth:`.Selector.select` method.
 
         """
 
         @wraps(select)
         def inner(population, *args, **kwargs):
-
             counter = Counter({record: 0 for record in population})
             for selected in select(population, *args, **kwargs):
                 counter.update(selected)
                 yield selected
             self._plot(population, counter)
 
         return inner
@@ -190,53 +189,50 @@
         Returns
         -------
         None : :class:`NoneType`
 
         """
 
         self._plots += 1
-        sns.set(style='darkgrid')
+        sns.set(style="darkgrid")
         data = []
         for record, selection_count in counter.items():
             label = self._record_label(record)
             data.append(
                 pd.DataFrame(
                     data={
                         self._x_label: label,
-                        'Number of Times Selected': selection_count,
-                        'order': self._order_by(record),
-                        'heat_map': self._heat_map_value(record)
+                        "Number of Times Selected": selection_count,
+                        "order": self._order_by(record),
+                        "heat_map": self._heat_map_value(record),
                     },
                     index=[self._x_label],
                 )
             )
         df = pd.concat(data, ignore_index=True)
 
         df = df.sort_values(
-            ['Number of Times Selected', 'order'],
-            ascending=[False, False]
-        )
-        norm = plt.Normalize(
-            df['heat_map'].min(),
-            df['heat_map'].max()
+            ["Number of Times Selected", "order"],
+            ascending=[False, False],
         )
-        sm = plt.cm.ScalarMappable(cmap='magma_r', norm=norm)
+        norm = plt.Normalize(df["heat_map"].min(), df["heat_map"].max())
+        sm = plt.cm.ScalarMappable(cmap="magma_r", norm=norm)
         sm.set_array([])
 
-        df.to_csv(f'{self._filename}_{self._plots}.csv')
+        df.to_csv(f"{self._filename}_{self._plots}.csv")
         fig, ax = plt.subplots(figsize=(11.7, 8.28))
         sns.scatterplot(
-            x='Number of Times Selected',
+            x="Number of Times Selected",
             y=self._x_label,
-            hue='heat_map',
-            palette='magma_r',
+            hue="heat_map",
+            palette="magma_r",
             data=df,
             s=[200 for i in range(len(counter.keys()))],
             ax=ax,
         )
         ax.get_legend().remove()
         # https://tinyurl.com/2p9drmkh
-        plt.rcParams['axes.grid'] = False
-        ax.figure.colorbar(sm).set_label(self._heat_map_label)
+        plt.rcParams["axes.grid"] = False
+        ax.figure.colorbar(sm, ax=ax).set_label(self._heat_map_label)
         plt.tight_layout()
-        fig.savefig(f'{self._filename}_{self._plots}.png', dpi=fig.dpi)
-        plt.close('all')
+        fig.savefig(f"{self._filename}_{self._plots}.png", dpi=fig.dpi)
+        plt.close("all")
```

### Comparing `stk-2022.6.17.0/src/stk/ea/selection/batch.py` & `stk-2023.7.5.0/src/stk/_internal/ea/selection/batch.py`

 * *Files 0% similar despite different names*

```diff
@@ -180,15 +180,15 @@
         )
         for record in batch:
             # Do stuff with record.
             pass
 
     """
 
-    __slots__ = ('_records', '_fitness_value', '_identity_key')
+    __slots__ = ("_records", "_fitness_value", "_identity_key")
 
     def __init__(self, records, fitness_values, key_maker):
         """
         Initialize a :class:`.Batch`.
 
         Parameters
         ----------
@@ -275,11 +275,11 @@
     def __lt__(self, other):
         return self._fitness_value < other._fitness_value
 
     def __le__(self, other):
         return self._fitness_value <= other._fitness_value
 
     def __repr__(self):
-        return f'Batch({self._fitness_value})'
+        return f"Batch({self._fitness_value})"
 
     def __str__(self):
         return repr(self)
```

### Comparing `stk-2022.6.17.0/src/stk/ea/selection/selectors/above_average.py` & `stk-2023.7.5.0/src/stk/_internal/ea/selection/selectors/above_average.py`

 * *Files 5% similar despite different names*

```diff
@@ -1,190 +1,178 @@
-"""
-Above Average
-=============
-
-"""
-
-import itertools as it
+import itertools
+import typing
+from collections.abc import Callable, Sequence
 
 import numpy as np
 
-from stk.molecular import Inchi
+from stk._internal.key_makers.inchi import Inchi
+from stk._internal.key_makers.molecule import MoleculeKeyMaker
 
 from .selector import Selector
 
+T = typing.TypeVar("T")
+
 
 class AboveAverage(Selector):
     """
     Yields above average batches of molecules.
 
-    Examples
-    --------
-    *Yielding Single Molecule Batches*
-
-    Yielding molecules one at a time. For example, if molecules need
-    to be selected for mutation or the next generation
-
-    .. testcode:: yielding-single-molecule-batches
-
-        import stk
-
-        # Make the selector.
-        above_avg = stk.AboveAverage()
-
-        population = (
-            stk.MoleculeRecord(
-                topology_graph=stk.polymer.Linear(
-                    building_blocks=(
-                        stk.BuildingBlock(
-                            smiles='BrCCBr',
-                            functional_groups=[stk.BromoFactory()],
+    Examples:
+
+        *Yielding Single Molecule Batches*
+
+        Yielding molecules one at a time. For example, if molecules need
+        to be selected for mutation or the next generation
+
+        .. testcode:: yielding-single-molecule-batches
+
+            import stk
+
+            # Make the selector.
+            above_avg = stk.AboveAverage()
+
+            population = (
+                stk.MoleculeRecord(
+                    topology_graph=stk.polymer.Linear(
+                        building_blocks=(
+                            stk.BuildingBlock(
+                                smiles='BrCCBr',
+                                functional_groups=[stk.BromoFactory()],
+                            ),
                         ),
+                        repeating_unit='A',
+                        num_repeating_units=2,
                     ),
-                    repeating_unit='A',
-                    num_repeating_units=2,
-                ),
-            ).with_fitness_value(1),
-            stk.MoleculeRecord(
-                topology_graph=stk.polymer.Linear(
-                    building_blocks=(
-                        stk.BuildingBlock(
-                            smiles='BrCCBr',
-                            functional_groups=[stk.BromoFactory()],
+                ).with_fitness_value(1),
+                stk.MoleculeRecord(
+                    topology_graph=stk.polymer.Linear(
+                        building_blocks=(
+                            stk.BuildingBlock(
+                                smiles='BrCCBr',
+                                functional_groups=[stk.BromoFactory()],
+                            ),
                         ),
+                        repeating_unit='A',
+                        num_repeating_units=2,
                     ),
-                    repeating_unit='A',
-                    num_repeating_units=2,
-                ),
-            ).with_fitness_value(2)
-        )
+                ).with_fitness_value(2)
+            )
 
-        # Select the molecules.
-        for selected, in above_avg.select(population):
-            # Do stuff with each selected molecule.
-            pass
-
-    *Yielding Batches Holding Multiple Molecules*
-
-    Yielding multiple molecules at once. For example, if molecules need
-    to be selected for crossover.
-
-    .. testcode:: yielding-batches-holding-multiple-molecules
-
-        import stk
-
-        # Make the selector.
-        above_avg = stk.AboveAverage(batch_size=2)
-
-        population = (
-            stk.MoleculeRecord(
-                topology_graph=stk.polymer.Linear(
-                    building_blocks=(
-                        stk.BuildingBlock(
-                            smiles='BrCCBr',
-                            functional_groups=[stk.BromoFactory()],
+            # Select the molecules.
+            for selected, in above_avg.select(population):
+                # Do stuff with each selected molecule.
+                pass
+
+        *Yielding Batches Holding Multiple Molecules*
+
+        Yielding multiple molecules at once. For example, if molecules need
+        to be selected for crossover.
+
+        .. testcode:: yielding-batches-holding-multiple-molecules
+
+            import stk
+
+            # Make the selector.
+            above_avg = stk.AboveAverage(batch_size=2)
+
+            population = (
+                stk.MoleculeRecord(
+                    topology_graph=stk.polymer.Linear(
+                        building_blocks=(
+                            stk.BuildingBlock(
+                                smiles='BrCCBr',
+                                functional_groups=[stk.BromoFactory()],
+                            ),
                         ),
+                        repeating_unit='A',
+                        num_repeating_units=2,
                     ),
-                    repeating_unit='A',
-                    num_repeating_units=2,
-                ),
-            ).with_fitness_value(1),
-            stk.MoleculeRecord(
-                topology_graph=stk.polymer.Linear(
-                    building_blocks=(
-                        stk.BuildingBlock(
-                            smiles='BrCCBr',
-                            functional_groups=[stk.BromoFactory()],
+                ).with_fitness_value(1),
+                stk.MoleculeRecord(
+                    topology_graph=stk.polymer.Linear(
+                        building_blocks=(
+                            stk.BuildingBlock(
+                                smiles='BrCCBr',
+                                functional_groups=[stk.BromoFactory()],
+                            ),
                         ),
+                        repeating_unit='A',
+                        num_repeating_units=2,
                     ),
-                    repeating_unit='A',
-                    num_repeating_units=2,
-                ),
-            ).with_fitness_value(2)
-        )
-
-        # Select the molecules.
-        for selected1, selected2 in above_avg.select(population):
-            # Do stuff with the selected molecules.
-            pass
+                ).with_fitness_value(2)
+            )
 
+            # Select the molecules.
+            for selected1, selected2 in above_avg.select(population):
+                # Do stuff with the selected molecules.
+                pass
     """
 
     def __init__(
         self,
-        num_batches=None,
-        batch_size=1,
-        duplicate_molecules=True,
-        duplicate_batches=True,
-        key_maker=Inchi(),
-        fitness_modifier=None,
-    ):
+        num_batches: int | None = None,
+        batch_size: int = 1,
+        duplicate_molecules: bool = True,
+        duplicate_batches: bool = True,
+        key_maker: MoleculeKeyMaker = Inchi(),
+        fitness_modifier: Callable[[Sequence[T]], dict[T, float]]
+        | None = None,
+    ) -> None:
         """
-        Initialize an :class:`.AboveAverage` instance.
-
-        Parameters
-        ----------
-        num_batches : :class:`int`, optional
-            The number of batches to yield. If ``None`` then yielding
-            will continue forever or until the generator is exhausted,
-            whichever comes first.
-
-        batch_size : :class:`int`, optional
-            The number of molecule records in each yielded
-            :class:`.Batch`.
-
-        duplicate_molecules : :class:`bool`, optional
-            If ``True`` the same molecule can be yielded in more
-            than one batch.
-
-        duplicate_batches : :class:`bool`, optional
-            If ``True`` the same batch can be yielded more than once.
-
-        key_maker : :class:`.MoleculeKeyMaker`, optional
-            Used to get the keys of molecules. If two molecules have
-            the same key, they are considered duplicates.
-
-        fitness_modifier : :class:`callable`, optional
-            Takes the `population` on which :meth:`.select` is called
-            and returns a :class:`dict`, which maps records in the
-            `population` to the fitness values the :class:`.Selector`
-            should use. If ``None``, the regular fitness values of the
-            records are used.
-
+        Parameters:
+            num_batches:
+                The number of batches to yield. If ``None`` then yielding
+                will continue forever or until the generator is exhausted,
+                whichever comes first.
+
+            batch_size:
+                The number of molecule records in each yielded
+                :class:`.Batch`.
+
+            duplicate_molecules:
+                If ``True`` the same molecule can be yielded in more
+                than one batch.
+
+            duplicate_batches:
+                If ``True`` the same batch can be yielded more than once.
+
+            key_maker:
+                Used to get the keys of molecules. If two molecules have
+                the same key, they are considered duplicates.
+
+            fitness_modifier:
+                Takes the `population` on which :meth:`~Selector.select`
+                is called and returns a :class:`dict`, which maps records
+                in the `population` to the fitness values the
+                :class:`.Selector` should use. If ``None``, the regular
+                fitness values of the records are used.
         """
-
         if fitness_modifier is None:
             fitness_modifier = self._get_fitness_values
 
+        super().__init__(key_maker, fitness_modifier, batch_size)
+
         self._duplicate_molecules = duplicate_molecules
         self._duplicate_batches = duplicate_batches
         self._num_batches = num_batches
-        self._batch_size = batch_size
-        super().__init__(
-            key_maker=key_maker,
-            fitness_modifier=fitness_modifier,
-        )
 
     def _select_from_batches(self, batches, yielded_batches):
-        mean = np.mean([
-            batch.get_fitness_value() for batch in batches
-        ])
+        mean = np.mean([batch.get_fitness_value() for batch in batches])
         # Yield highest fitness batches first.
         batches = sorted(batches, reverse=True)
         # Yield only batches with a fitness larger than the mean.
-        batches = it.takewhile(
-            lambda batch: batch.get_fitness_value() > mean,
-            batches
+        batches = itertools.takewhile(
+            lambda batch: batch.get_fitness_value() > mean, batches
         )
         # Yield batches which are multiple times better than the mean
         # multiple times.
         batches = (
             batch
             for batch in batches
-            for i in range(self._get_num_duplicates(batch, mean))
+            for _ in range(self._get_num_duplicates(batch, mean))
         )
         # If duplicate molecules are not allowed, allow only
         # batches with no yielded molecules.
         if not self._duplicate_molecules:
             batches = filter(
                 yielded_batches.has_no_yielded_molecules,
                 batches,
@@ -193,13 +181,13 @@
         # unyielded batches.
         if not self._duplicate_batches:
             batches = filter(
                 yielded_batches.is_unyielded_batch,
                 batches,
             )
         # Limit the number of yielded batches to _num_batches.
-        yield from it.islice(batches, self._num_batches)
+        yield from itertools.islice(batches, self._num_batches)
 
     def _get_num_duplicates(self, batch, mean):
         if self._duplicate_batches and self._duplicate_molecules:
             return int(batch.get_fitness_value() // mean)
         return 1
```

### Comparing `stk-2022.6.17.0/src/stk/ea/selection/selectors/best.py` & `stk-2023.7.5.0/src/stk/_internal/ea/selection/selectors/best.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,171 +1,162 @@
-"""
-Best
-====
+import itertools
+import typing
+from collections.abc import Callable, Sequence
 
-"""
-
-import itertools as it
-
-from stk.molecular import Inchi
+from stk._internal.key_makers.inchi import Inchi
+from stk._internal.key_makers.molecule import MoleculeKeyMaker
 
 from .selector import Selector
 
+T = typing.TypeVar("T")
 
-class Best(Selector):
+
+class Best(Selector[T]):
     """
     Selects batches of molecules, highest fitness value first.
 
-    Examples
-    --------
-    *Yielding Single Molecule Batches*
-
-    Yielding molecules one at a time. For example, if molecules need
-    to be selected for mutation or the next generation.
-
-    .. testcode:: yielding-single-molecule-batches
-
-        import stk
-
-        # Make the selector.
-        best = stk.Best()
-
-        population = (
-            stk.MoleculeRecord(
-                topology_graph=stk.polymer.Linear(
-                    building_blocks=(
-                        stk.BuildingBlock(
-                            smiles='BrCCBr',
-                            functional_groups=[stk.BromoFactory()],
+    Examples:
+        *Yielding Single Molecule Batches*
+
+        Yielding molecules one at a time. For example, if molecules need
+        to be selected for mutation or the next generation.
+
+        .. testcode:: yielding-single-molecule-batches
+
+            import stk
+
+            # Make the selector.
+            best = stk.Best()
+
+            population = (
+                stk.MoleculeRecord(
+                    topology_graph=stk.polymer.Linear(
+                        building_blocks=(
+                            stk.BuildingBlock(
+                                smiles='BrCCBr',
+                                functional_groups=[stk.BromoFactory()],
+                            ),
                         ),
+                        repeating_unit='A',
+                        num_repeating_units=2,
                     ),
-                    repeating_unit='A',
-                    num_repeating_units=2,
-                ),
-            ).with_fitness_value(1),
-            stk.MoleculeRecord(
-                topology_graph=stk.polymer.Linear(
-                    building_blocks=(
-                        stk.BuildingBlock(
-                            smiles='BrCCBr',
-                            functional_groups=[stk.BromoFactory()],
+                ).with_fitness_value(1),
+                stk.MoleculeRecord(
+                    topology_graph=stk.polymer.Linear(
+                        building_blocks=(
+                            stk.BuildingBlock(
+                                smiles='BrCCBr',
+                                functional_groups=[stk.BromoFactory()],
+                            ),
                         ),
+                        repeating_unit='A',
+                        num_repeating_units=2,
                     ),
-                    repeating_unit='A',
-                    num_repeating_units=2,
-                ),
-            ).with_fitness_value(2)
-        )
-
-        # Select the molecules.
-        for selected, in best.select(population):
-            # Do stuff with each selected molecule.
-            pass
-
-    *Yielding Batches Holding Multiple Molecules*
-
-    Yielding multiple molecules at once. For example, if molecules need
-    to be selected for crossover.
-
-    .. testcode:: yielding-batches-holding-multiple-molecules
-
-        import stk
-
-        # Make the selector.
-        best = stk.Best(batch_size=2)
-
-        population = (
-            stk.MoleculeRecord(
-                topology_graph=stk.polymer.Linear(
-                    building_blocks=(
-                        stk.BuildingBlock(
-                            smiles='BrCCBr',
-                            functional_groups=[stk.BromoFactory()],
+                ).with_fitness_value(2)
+            )
+
+            # Select the molecules.
+            for selected, in best.select(population):
+                # Do stuff with each selected molecule.
+                pass
+
+        *Yielding Batches Holding Multiple Molecules*
+
+        Yielding multiple molecules at once. For example, if molecules need
+        to be selected for crossover.
+
+        .. testcode:: yielding-batches-holding-multiple-molecules
+
+            import stk
+
+            # Make the selector.
+            best = stk.Best(batch_size=2)
+
+            population = (
+                stk.MoleculeRecord(
+                    topology_graph=stk.polymer.Linear(
+                        building_blocks=(
+                            stk.BuildingBlock(
+                                smiles='BrCCBr',
+                                functional_groups=[stk.BromoFactory()],
+                            ),
                         ),
+                        repeating_unit='A',
+                        num_repeating_units=2,
                     ),
-                    repeating_unit='A',
-                    num_repeating_units=2,
-                ),
-            ).with_fitness_value(1),
-            stk.MoleculeRecord(
-                topology_graph=stk.polymer.Linear(
-                    building_blocks=(
-                        stk.BuildingBlock(
-                            smiles='BrCCBr',
-                            functional_groups=[stk.BromoFactory()],
+                ).with_fitness_value(1),
+                stk.MoleculeRecord(
+                    topology_graph=stk.polymer.Linear(
+                        building_blocks=(
+                            stk.BuildingBlock(
+                                smiles='BrCCBr',
+                                functional_groups=[stk.BromoFactory()],
+                            ),
                         ),
+                        repeating_unit='A',
+                        num_repeating_units=2,
                     ),
-                    repeating_unit='A',
-                    num_repeating_units=2,
-                ),
-            ).with_fitness_value(2)
-        )
-
-        # Select the molecules.
-        for selected1, selected2 in best.select(population):
-            # Do stuff with the selected molecules.
-            pass
+                ).with_fitness_value(2)
+            )
 
+            # Select the molecules.
+            for selected1, selected2 in best.select(population):
+                # Do stuff with the selected molecules.
+                pass
     """
 
     def __init__(
         self,
-        num_batches=None,
-        batch_size=1,
-        duplicate_molecules=True,
-        duplicate_batches=True,
-        key_maker=Inchi(),
-        fitness_modifier=None,
-    ):
+        num_batches: int | None = None,
+        batch_size: int = 1,
+        duplicate_molecules: bool = True,
+        duplicate_batches: bool = True,
+        key_maker: MoleculeKeyMaker = Inchi(),
+        fitness_modifier: Callable[[Sequence[T]], dict[T, float]]
+        | None = None,
+    ) -> None:
         """
-        Initialize a :class:`.Best` instance.
-
-        Parameters
-        ----------
-        num_batches : :class:`int`, optional
-            The number of batches to yield. If ``None`` then yielding
-            will continue forever or until the generator is exhausted,
-            whichever comes first.
-
-        batch_size : :class:`int`, optional
-            The number of molecule records yielded at once.
-
-        duplicate_molecules : :class:`bool`, optional
-            If ``True`` the same molecule can be yielded in more than
-            one batch.
-
-        duplicate_batches : :class:`bool`, optional
-            If ``True`` the same batch can be yielded more than once.
-            Duplicate batches can occur if the same molecule is found
-            multiple times in a population.
-
-        key_maker : :class:`.MoleculeKeyMaker`, optional
-            Used to get the keys of molecules. If two molecules have
-            the same key, they are considered duplicates.
-
-        fitness_modifier : :class:`callable`, optional
-            Takes the `population` on which :meth:`.select` is called
-            and returns a :class:`dict`, which maps records in the
-            `population` to the fitness values the :class:`.Selector`
-            should use. If ``None``, the regular fitness values of the
-            records are used.
-
+        Parameters:
+            num_batches:
+                The number of batches to yield. If ``None`` then yielding
+                will continue forever or until the generator is exhausted,
+                whichever comes first.
+
+            batch_size:
+                The number of molecule records yielded at once.
+
+            duplicate_molecules:
+                If ``True`` the same molecule can be yielded in more than
+                one batch.
+
+            duplicate_batches:
+                If ``True`` the same batch can be yielded more than once.
+                Duplicate batches can occur if the same molecule is found
+                multiple times in a population.
+
+            key_maker:
+                Used to get the keys of molecules. If two molecules have
+                the same key, they are considered duplicates.
+
+            fitness_modifier:
+                Takes the `population` on which :meth:`~.Selector.select`
+                is called and returns a :class:`dict`, which maps records
+                in the `population` to the fitness values the
+                :class:`.Selector` should use. If ``None``, the regular
+                fitness values of the records are used.
         """
-
         if fitness_modifier is None:
             fitness_modifier = self._get_fitness_values
 
+        super().__init__(key_maker, fitness_modifier, batch_size)
+
         self._duplicate_molecules = duplicate_molecules
         self._duplicate_batches = duplicate_batches
         self._num_batches = num_batches
         self._batch_size = batch_size
-        super().__init__(
-            key_maker=key_maker,
-            fitness_modifier=fitness_modifier,
-        )
 
     def _select_from_batches(self, batches, yielded_batches):
         batches = sorted(batches, reverse=True)
 
         if not self._duplicate_molecules:
             batches = filter(
                 yielded_batches.has_no_yielded_molecules,
@@ -174,8 +165,8 @@
 
         if not self._duplicate_batches:
             batches = filter(
                 yielded_batches.is_unyielded_batch,
                 batches,
             )
 
-        yield from it.islice(batches, self._num_batches)
+        yield from itertools.islice(batches, self._num_batches)
```

### Comparing `stk-2022.6.17.0/src/stk/ea/selection/selectors/filter_batches.py` & `stk-2023.7.5.0/src/stk/_internal/ea/selection/selectors/filter_batches.py`

 * *Files identical despite different names*

### Comparing `stk-2022.6.17.0/src/stk/ea/selection/selectors/filter_molecules.py` & `stk-2023.7.5.0/src/stk/_internal/ea/selection/selectors/filter_molecules.py`

 * *Files 4% similar despite different names*

```diff
@@ -76,16 +76,14 @@
     ):
         valid_batches = self._filter.select(
             population=population,
             included_batches=included_batches,
             excluded_batches=excluded_batches,
         )
         valid_population = tuple(
-            record
-            for batch in valid_batches
-            for record in batch
+            record for batch in valid_batches for record in batch
         )
         yield from self._selector.select(
             population=valid_population,
             included_batches=included_batches,
             excluded_batches=excluded_batches,
         )
```

### Comparing `stk-2022.6.17.0/src/stk/ea/selection/selectors/remove_batches.py` & `stk-2023.7.5.0/src/stk/_internal/ea/selection/selectors/remove_batches.py`

 * *Files identical despite different names*

### Comparing `stk-2022.6.17.0/src/stk/ea/selection/selectors/remove_molecules.py` & `stk-2023.7.5.0/src/stk/_internal/ea/selection/selectors/remove_molecules.py`

 * *Files 4% similar despite different names*

```diff
@@ -75,19 +75,15 @@
         excluded_batches=None,
     ):
         remover_batches = self._remover.select(
             population=population,
             included_batches=included_batches,
             excluded_batches=excluded_batches,
         )
-        removed = {
-            record
-            for batch in remover_batches
-            for record in batch
-        }
+        removed = {record for batch in remover_batches for record in batch}
         valid_population = tuple(
             record for record in population if record not in removed
         )
         yield from self._selector.select(
             population=valid_population,
             included_batches=included_batches,
             excluded_batches=excluded_batches,
```

### Comparing `stk-2022.6.17.0/src/stk/ea/selection/selectors/roulette.py` & `stk-2023.7.5.0/src/stk/_internal/ea/selection/selectors/roulette.py`

 * *Files 19% similar despite different names*

```diff
@@ -1,190 +1,178 @@
-"""
-Roulette
-========
-
-"""
+import typing
+from collections.abc import Callable, Sequence
 
 import numpy as np
 
-from stk.molecular import Inchi
+from stk._internal.key_makers.inchi import Inchi
+from stk._internal.key_makers.molecule import MoleculeKeyMaker
 
 from .selector import Selector
 
+T = typing.TypeVar("T")
+
 
-class Roulette(Selector):
+class Roulette(Selector[T]):
     """
     Uses roulette selection to select batches of molecules.
 
     In roulette selection the probability a batch is selected
     is given by its fitness. If the total fitness is the sum of all
     fitness values, the chance a batch is selected is given
     by::
 
         p = batch fitness / total fitness,
 
     where ``p`` is the probability of selection and the batch
     fitness is the sum of all fitness values of molecules in the
     batch [#]_.
 
-    References
-    ----------
-    .. [#] http://tinyurl.com/csc3djm
-
-    Examples
-    --------
-    *Yielding Single Molecule Batches*
-
-    Yielding molecules one at a time. For example, if molecules need
-    to be selected for mutation or the next generation
-
-    .. testcode:: yielding-single-molecule-batches
-
-        import stk
-
-        # Make the selector.
-        roulette = stk.Roulette(num_batches=5)
-
-        population = tuple(
-            stk.MoleculeRecord(
-                topology_graph=stk.polymer.Linear(
-                    building_blocks=(
-                        stk.BuildingBlock(
-                            smiles='BrCCBr',
-                            functional_groups=[stk.BromoFactory()],
+    References:
+
+        .. [#] http://tinyurl.com/csc3djm
+
+    Examples:
+
+        *Yielding Single Molecule Batches*
+
+        Yielding molecules one at a time. For example, if molecules need
+        to be selected for mutation or the next generation
+
+        .. testcode:: yielding-single-molecule-batches
+
+            import stk
+
+            # Make the selector.
+            roulette = stk.Roulette(num_batches=5)
+
+            population = tuple(
+                stk.MoleculeRecord(
+                    topology_graph=stk.polymer.Linear(
+                        building_blocks=(
+                            stk.BuildingBlock(
+                                smiles='BrCCBr',
+                                functional_groups=[stk.BromoFactory()],
+                            ),
                         ),
+                        repeating_unit='A',
+                        num_repeating_units=2,
                     ),
-                    repeating_unit='A',
-                    num_repeating_units=2,
-                ),
-            ).with_fitness_value(i)
-            for i in range(100)
-        )
+                ).with_fitness_value(i)
+                for i in range(100)
+            )
 
-        # Select the molecules.
-        for selected, in roulette.select(population):
-            # Do stuff with each selected molecule.
-            pass
+            # Select the molecules.
+            for selected, in roulette.select(population):
+                # Do stuff with each selected molecule.
+                pass
 
 
-    *Yielding Batches Holding Multiple Molecules*
+        *Yielding Batches Holding Multiple Molecules*
 
-    Yielding multiple molecules at once. For example, if molecules need
-    to be selected for crossover
+        Yielding multiple molecules at once. For example, if molecules need
+        to be selected for crossover
 
-    .. testcode:: yielding-batches-holding-multiple-molecules
+        .. testcode:: yielding-batches-holding-multiple-molecules
 
-        import stk
+            import stk
 
-        # Make the selector.
-        roulette = stk.Roulette(num_batches=5, batch_size=2)
+            # Make the selector.
+            roulette = stk.Roulette(num_batches=5, batch_size=2)
 
-        population = tuple(
-            stk.MoleculeRecord(
-                topology_graph=stk.polymer.Linear(
-                    building_blocks=(
-                        stk.BuildingBlock(
-                            smiles='BrCCBr',
-                            functional_groups=[stk.BromoFactory()],
+            population = tuple(
+                stk.MoleculeRecord(
+                    topology_graph=stk.polymer.Linear(
+                        building_blocks=(
+                            stk.BuildingBlock(
+                                smiles='BrCCBr',
+                                functional_groups=[stk.BromoFactory()],
+                            ),
                         ),
+                        repeating_unit='A',
+                        num_repeating_units=2,
                     ),
-                    repeating_unit='A',
-                    num_repeating_units=2,
-                ),
-            ).with_fitness_value(i)
-            for i in range(100)
-        )
-
-        # Select the molecules.
-        for selected1, selected2 in roulette.select(population):
-            # Do stuff to the molecules.
-            pass
+                ).with_fitness_value(i)
+                for i in range(100)
+            )
+
+            # Select the molecules.
+            for selected1, selected2 in roulette.select(population):
+                # Do stuff to the molecules.
+                pass
 
     """
 
     def __init__(
         self,
-        num_batches=None,
-        batch_size=1,
-        duplicate_molecules=True,
-        duplicate_batches=True,
-        key_maker=Inchi(),
-        fitness_modifier=None,
-        random_seed=None
-    ):
+        num_batches: int | None = None,
+        batch_size: int = 1,
+        duplicate_molecules: bool = True,
+        duplicate_batches: bool = True,
+        key_maker: MoleculeKeyMaker = Inchi(),
+        fitness_modifier: Callable[[Sequence[T]], dict[T, float]]
+        | None = None,
+        random_seed: int | np.random.Generator | None = None,
+    ) -> None:
         """
-        Initialize a :class:`Roulette` instance.
-
-        Parameters
-        ----------
-        num_batches : :class:`int`, optional
-            The number of batches to yield. If ``None`` then yielding
-            will continue forever or until the generator is exhausted,
-            whichever comes first.
-
-        batch_size : :class:`int`, optional
-            The number of molecules yielded at once.
-
-        duplicate_molecules : :class:`bool`, optional
-            If ``True`` the same molecule can be yielded in more than
-            one batch.
-
-        duplicate_batches : :class:`bool`, optional
-            If ``True`` the same batch can be yielded more than once.
-
-        key_maker : :class:`.MoleculeKeyMaker`, optional
-            Used to get the keys of molecules. If two molecules have
-            the same key, they are considered duplicates.
-
-        fitness_modifier : :class:`callable`, optional
-            Takes the `population` on which :meth:`.select` is called
-            and returns a :class:`dict`, which maps records in the
-            `population` to the fitness values the :class:`.Selector`
-            should use. If ``None``, the regular fitness values of the
-            records are used.
-
-        random_seed : :class:`int`, optional
-            The random seed to use.
+        Parameters:
+            num_batches:
+                The number of batches to yield. If ``None`` then yielding
+                will continue forever or until the generator is exhausted,
+                whichever comes first.
+
+            batch_size:
+                The number of molecules yielded at once.
+
+            duplicate_molecules:
+                If ``True`` the same molecule can be yielded in more than
+                one batch.
+
+            duplicate_batches:
+                If ``True`` the same batch can be yielded more than once.
+
+            key_maker:
+                Used to get the keys of molecules. If two molecules have
+                the same key, they are considered duplicates.
+
+            fitness_modifier:
+                Takes the `population` on which :meth:`~.Selector.select`
+                is called and returns a :class:`dict`, which maps records
+                in the `population` to the fitness values the
+                :class:`.Selector` should use. If ``None``, the regular
+                fitness values of the records are used.
 
+            random_seed:
+                The random seed to use.
         """
-
-        if num_batches is None:
-            num_batches = float('inf')
-
         if fitness_modifier is None:
             fitness_modifier = self._get_fitness_values
 
-        self._generator = np.random.RandomState(random_seed)
+        super().__init__(key_maker, fitness_modifier, batch_size)
+
+        if random_seed is None or isinstance(random_seed, int):
+            random_seed = np.random.default_rng(random_seed)
+
+        self._generator = random_seed
         self._duplicate_molecules = duplicate_molecules
         self._duplicate_batches = duplicate_batches
-        self._num_batches = num_batches
-        self._batch_size = batch_size
-        super().__init__(
-            key_maker=key_maker,
-            fitness_modifier=fitness_modifier,
+        self._num_batches = (
+            float("inf") if num_batches is None else num_batches
         )
 
     def _select_from_batches(self, batches, yielded_batches):
-        while (
-            batches and yielded_batches.get_num() < self._num_batches
-        ):
+        while batches and yielded_batches.get_num() < self._num_batches:
             total = sum(batch.get_fitness_value() for batch in batches)
-            weights = [
-                batch.get_fitness_value() / total for batch in batches
-            ]
+            weights = [batch.get_fitness_value() / total for batch in batches]
             yield self._generator.choice(batches, p=weights)
 
             if not self._duplicate_molecules:
                 batches = filter(
                     yielded_batches.has_no_yielded_molecules,
                     batches,
                 )
             if not self._duplicate_batches:
                 batches = filter(
                     yielded_batches.is_unyielded_batch,
                     batches,
                 )
-            if (
-                not self._duplicate_molecules
-                or not self._duplicate_batches
-            ):
+            if not self._duplicate_molecules or not self._duplicate_batches:
                 batches = tuple(batches)
```

### Comparing `stk-2022.6.17.0/src/stk/ea/selection/selectors/selector.py` & `stk-2023.7.5.0/src/stk/_internal/ea/selection/selectors/selector.py`

 * *Files 12% similar despite different names*

```diff
@@ -1,238 +1,223 @@
-"""
-Selector
-========
-
-.. toctree::
-    :maxdepth: 2
-
-    Above Average <stk.ea.selection.selectors.above_average>
-    Best <stk.ea.selection.selectors.best>
-    Filter Batches <stk.ea.selection.selectors.filter_batches>
-    Filter Molecules <stk.ea.selection.selectors.filter_molecules>
-    Remove Batches <stk.ea.selection.selectors.remove_batches>
-    Remove Molecules <stk.ea.selection.selectors.remove_molecules>
-    Roulette <stk.ea.selection.selectors.roulette>
-    Stochastic Universal Sampling <\
-stk.ea.selection.selectors.stochastic_universal_sampling\
->
-    Tournament <stk.ea.selection.selectors.tournament>
-    Worst <stk.ea.selection.selectors.worst>
-
-"""
-
-import itertools as it
+import itertools
 import logging
+import typing
+from collections.abc import Callable, Iterator, Sequence
+
+from stk._internal.key_makers.molecule import MoleculeKeyMaker
 
 from ..batch import Batch
-from .utilities import YieldedBatches
+from .utilities.yielded_batches import YieldedBatches
 
+T = typing.TypeVar("T")
 logger = logging.getLogger(__name__)
 
 
-class Selector:
+class Selector(typing.Generic[T]):
     """
     An abstract base class for selectors.
 
     Selectors select batches of molecules from a population.
     Each batch is selected based on its fitness. The fitness of a
     batch is the sum of all fitness values of the molecules in the
     batch. Batches may be of size 1.
 
-    Notes
-    -----
-    You might notice that some of the public methods of this abstract
-    base class are implemented. This is purely for convenience when
-    implementing subclasses. The implemented public methods are simply
-    default implementations, which can be safely ignored or overridden,
-    when implementing subclasses. Any private methods are
-    implementation details of these default implementations.
-
-    *The Default Implementation*
-
-    This section is only of use to people who want to add a new
-    :class:`.Selector` subclass, and want to make use of the default
-    implementation to make this job easier.
-
-    When using the default implementation you do not need to
-    implement :meth:`.select`, which is already provided, but instead
-    :meth:`._select_from_batches` needs to be implemented. What the
-    default implementation provides, is code, which does the batching
-    of a `population` for you, which means you only have to worry
-    about implementing the selection algorithm, which works on batches
-    directly.
-
-    The default implementation also automatically updates a
-    :class:`.YieldedBatches` object for you, so that you can keep track
-    of which batches have already been yielded, in case you want to
-    prevent duplicate selection of batches or molecule records. Though
-    whether you want to make use of this will depend on the nature of
-    your selection algorithm.
-
-    See Also
-    --------
-    :class:`.Batch`
-
-    Examples
-    --------
-    *Subclass Implementation*
+    Notes:
 
-    The source code of the classes listed in :mod:`.selector` can serve
-    as good examples.
+        You might notice that some of the public methods of this abstract
+        base class are implemented. This is purely for convenience when
+        implementing subclasses. The implemented public methods are simply
+        default implementations, which can be safely ignored or overridden,
+        when implementing subclasses. Any private methods are
+        implementation details of these default implementations.
+
+        *The Default Implementation*
+
+        This section is only of use to people who want to add a new
+        :class:`.Selector` subclass, and want to make use of the default
+        implementation to make this job easier.
+
+        When using the default implementation you do not need to
+        implement :meth:`.select`, which is already provided, but instead
+        :meth:`._select_from_batches` needs to be implemented. What the
+        default implementation provides, is code, which does the batching
+        of a `population` for you, which means you only have to worry
+        about implementing the selection algorithm, which works on batches
+        directly.
+
+        The default implementation also automatically updates a
+        :class:`.YieldedBatches` object for you, so that you can keep track
+        of which batches have already been yielded, in case you want to
+        prevent duplicate selection of batches or molecule records. Though
+        whether you want to make use of this will depend on the nature of
+        your selection algorithm.
 
-    """
+    See Also:
 
-    def __init__(self, key_maker, fitness_modifier):
-        """
-        Initialize a :class:`.Selector` instance.
+        :class:`.Batch`
 
-        Parameters
-        ----------
-        key_maker : :class:`.MoleculeKeyMaker`
-            Used to get the keys of molecules, which are used to
-            determine if two molecule records are duplicates of each
-            other.
-
-        fitness_modifier : :class:`callable`, optional
-            Takes the `population` on which :meth:`.select` is called
-            and returns a :class:`dict`, which maps records in the
-            `population` to the fitness values the :class:`.Selector`
-            should use. If ``None``, the regular fitness values of the
-            records are used.
+    Examples:
 
-        """
+        *Subclass Implementation*
+
+        The source code of the classes listed in :mod:`.selector` can serve
+        as good examples.
+
+    """
+
+    def __init__(
+        self,
+        key_maker: MoleculeKeyMaker,
+        fitness_modifier: Callable[[Sequence[T]], dict[T, float]],
+        batch_size: int,
+    ) -> None:
+        """
+        Parameters:
+
+            key_maker:
+                Used to get the keys of molecules, which are used to
+                determine if two molecule records are duplicates of each
+                other.
+
+            fitness_modifier:
+                Takes the `population` on which :meth:`.select` is called
+                and returns a :class:`dict`, which maps records in the
+                `population` to the fitness values the :class:`.Selector`
+                should use.
 
+            batch_size:
+                The number of molecules yielded at once.
+        """
         self._key_maker = key_maker
         self._fitness_modifier = fitness_modifier
+        self._batch_size = batch_size
 
     def select(
         self,
         population,
         included_batches=None,
         excluded_batches=None,
-    ):
+    ) -> Iterator[Batch]:
         """
         Yield batches of molecule records from `population`.
 
-        Parameters
-        ----------
-        population : :class:`tuple` of :class:`.MoleculeRecord`
-            A collection of molecules from which batches are selected.
-
-        included_batches : :class:`set`, optional
-            The identity keys of batches which are allowed to be
-            yielded, if ``None`` all batches can be yielded. If not
-            ``None`` only batches `included_batches` will be yielded.
-
-        excluded_batches : class:`set`, optional
-            The identity keys of batches which are not allowed to be
-            yielded. If ``None``, no batch is forbidden from being
-            yielded.
-
-        Yields
-        ------
-        :class:`Batch` of :class:`.MoleculeRecord`
+        Parameters:
+
+            population : :class:`tuple` of :class:`.MoleculeRecord`
+                A collection of molecules from which batches are selected.
+
+            included_batches : :class:`set`, optional
+                The identity keys of batches which are allowed to be
+                yielded, if ``None`` all batches can be yielded. If not
+                ``None`` only batches `included_batches` will be yielded.
+
+            excluded_batches : class:`set`, optional
+                The identity keys of batches which are not allowed to be
+                yielded. If ``None``, no batch is forbidden from being
+                yielded.
+
+        Yields:
+
             A batch of selected molecule records.
 
         """
 
-        batches = tuple(self._get_batches(
-            population=population,
-            fitness_values=self._fitness_modifier(population),
-            included_batches=included_batches,
-            excluded_batches=excluded_batches,
-        ))
+        batches = tuple(
+            self._get_batches(
+                population=population,
+                fitness_values=self._fitness_modifier(population),
+                included_batches=included_batches,
+                excluded_batches=excluded_batches,
+            )
+        )
 
         yielded_batches = YieldedBatches(self._key_maker)
         for batch in self._select_from_batches(
             batches=batches,
             yielded_batches=yielded_batches,
         ):
             yielded_batches.update(batch)
             yield batch
 
         cls_name = self.__class__.__name__
         logger.debug(
-            f'{cls_name} yielded {yielded_batches.get_num()} batches.'
+            f"{cls_name} yielded {yielded_batches.get_num()} batches."
         )
 
     def _get_batches(
         self,
         population,
         fitness_values,
         included_batches,
         excluded_batches,
-    ):
+    ) -> Iterator[Batch]:
         """
         Get batches molecules from `population`.
 
-        Parameters
-        ----------
-        population : :class:`tuple` of :class:`.MoleculeRecord`
-            The molecule records which are to be batched.
-
-        fitness_values : :class:`dict`
-            Maps each :class:`.MoleculeRecord` in `population` to the
-            fitness value which should be used for it.
-
-        included_batches : :class:`set`, optional
-            The identity keys of batches which are allowed to be
-            yielded, if ``None`` all batches can be yielded. If not
-            ``None`` only batches `included_batches` will be yielded.
-
-        excluded_batches : class:`set`, optional
-            The identity keys of batches which are not allowed to be
-            yielded. If ``None``, no batch is forbidden from being
-            yielded.
+        Parameters:
 
-        Yields
-        ------
-        :class:`.Batch`
-            A batch of molecules from `population`.
+            population : :class:`tuple` of :class:`.MoleculeRecord`
+                The molecule records which are to be batched.
+
+            fitness_values : :class:`dict`
+                Maps each :class:`.MoleculeRecord` in `population` to the
+                fitness value which should be used for it.
+
+            included_batches : :class:`set`, optional
+                The identity keys of batches which are allowed to be
+                yielded, if ``None`` all batches can be yielded. If not
+                ``None`` only batches `included_batches` will be yielded.
+
+            excluded_batches : class:`set`, optional
+                The identity keys of batches which are not allowed to be
+                yielded. If ``None``, no batch is forbidden from being
+                yielded.
+
+            Yields:
+                A batch of molecules from `population`.
 
         """
 
         def is_included(batch):
             if included_batches is None:
                 return True
             return batch.get_identity_key() in included_batches
 
         def is_excluded(batch):
             if excluded_batches is None:
                 return False
             return batch.get_identity_key() in excluded_batches
 
-        for records in it.combinations(population, self._batch_size):
+        for records in itertools.combinations(population, self._batch_size):
             batch = Batch(
                 records=records,
                 fitness_values=fitness_values,
                 key_maker=self._key_maker,
             )
             if is_included(batch) and not is_excluded(batch):
                 yield batch
 
-    def _select_from_batches(self, batches, yielded_batches):
+    def _select_from_batches(
+        self,
+        batches,
+        yielded_batches,
+    ) -> Iterator[Batch]:
         """
         Yield batches from `batches`.
 
-        Parameters
-        ----------
-        batches : :class:`tuple` of :class:`.Batches`
-            Batches from which some are selected.
-
-        yielded_batches : :class:`.YieldedBatches`
-            Keeps track of which batches have been yielded. This
-            object automatically updates each time ``yield`` is called.
+        Parameters:
+            batches : :class:`tuple` of :class:`.Batches`
+                Batches from which some are selected.
+
+            yielded_batches : :class:`.YieldedBatches`
+                Keeps track of which batches have been yielded. This
+                object automatically updates each time ``yield`` is called.
 
-        Yields
-        ------
-        :class:`.Batch`
+        Yields:
             A selected batch.
 
         """
 
         raise NotImplementedError()
 
     def _get_fitness_values(self, population):
-        return {
-            record: record.get_fitness_value() for record in population
-        }
+        return {record: record.get_fitness_value() for record in population}
```

### Comparing `stk-2022.6.17.0/src/stk/ea/selection/selectors/stochastic_universal_sampling.py` & `stk-2023.7.5.0/src/stk/_internal/ea/selection/selectors/stochastic_universal_sampling.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,135 +1,131 @@
-"""
-Stochastic Universal Sampling
-=============================
-
-"""
+import typing
+from collections.abc import Callable, Sequence
 
 import numpy as np
 
-from stk.molecular import Inchi
+from stk._internal.key_makers.inchi import Inchi
+from stk._internal.key_makers.molecule import MoleculeKeyMaker
 
 from .selector import Selector
 
+T = typing.TypeVar("T")
+
 
-class StochasticUniversalSampling(Selector):
+class StochasticUniversalSampling(Selector[T]):
     """
     Yields batches of molecules through stochastic universal sampling.
 
     Stochastic universal sampling lays out batches along a line, with
     each batch taking up length proportional to its fitness. It
     then creates a set of evenly spaced pointers to different points
     on the line, each of which is occupied by a batch. Batches which
     are pointed to are yielded.
 
     This approach means weaker members of the population
     are given a greater chance to be chosen than in
     :class:`.Roulette` selection [#]_.
 
-    References
-    ----------
+    References:
+
     .. [#] https://en.wikipedia.org/wiki/Stochastic_universal_sampling
 
-    Examples
-    --------
-    *Yielding Single Molecule Batches*
-
-    Yielding molecules one at a time. For example, if molecules need
-    to be selected for mutation or the next generation.
-
-    .. testcode:: yielding-single-molecule-batches
-
-        import stk
-
-        # Make the selector.
-        stochastic_sampling = stk.StochasticUniversalSampling(5)
-
-        population = tuple(
-            stk.MoleculeRecord(
-                topology_graph=stk.polymer.Linear(
-                    building_blocks=(
-                        stk.BuildingBlock(
-                            smiles='BrCCBr',
-                            functional_groups=[stk.BromoFactory()],
+    Examples:
+
+        *Yielding Single Molecule Batches*
+
+        Yielding molecules one at a time. For example, if molecules need
+        to be selected for mutation or the next generation.
+
+        .. testcode:: yielding-single-molecule-batches
+
+            import stk
+
+            # Make the selector.
+            stochastic_sampling = stk.StochasticUniversalSampling(5)
+
+            population = tuple(
+                stk.MoleculeRecord(
+                    topology_graph=stk.polymer.Linear(
+                        building_blocks=(
+                            stk.BuildingBlock(
+                                smiles='BrCCBr',
+                                functional_groups=[stk.BromoFactory()],
+                            ),
                         ),
+                        repeating_unit='A',
+                        num_repeating_units=2,
                     ),
-                    repeating_unit='A',
-                    num_repeating_units=2,
-                ),
-            ).with_fitness_value(i)
-            for i in range(100)
-        )
+                ).with_fitness_value(i)
+                for i in range(100)
+            )
 
-        # Select the molecules.
-        for selected, in stochastic_sampling.select(population):
-            # Do stuff with each selected molecule.
-            pass
+            # Select the molecules.
+            for selected, in stochastic_sampling.select(population):
+                # Do stuff with each selected molecule.
+                pass
 
     """
 
     def __init__(
         self,
-        num_batches=None,
-        batch_size=1,
-        duplicate_molecules=True,
-        duplicate_batches=True,
-        key_maker=Inchi(),
-        fitness_modifier=None,
-        random_seed=None,
+        num_batches: int | None = None,
+        batch_size: int = 1,
+        duplicate_molecules: bool = True,
+        duplicate_batches: bool = True,
+        key_maker: MoleculeKeyMaker = Inchi(),
+        fitness_modifier: Callable[[Sequence[T]], dict[T, float]]
+        | None = None,
+        random_seed: int | np.random.Generator | None = None,
     ):
         """
-        Initialize a :class:`.StochasticUniversalSampling` instance.
-
-        Parameters
-        ----------
-        num_batches : :class:`int`, optional
-            The number of batches to yield. If ``None`` then yielding
-            will continue forever or until the generator is exhausted,
-            whichever comes first.
-
-        batch_size : :class:`int`, optional
-            The number of molecules yielded at once.
-
-        duplicate_molecules : :class:`bool`, optional
-            If ``True`` the same molecule can be yielded in more than
-            one batch.
-
-        duplicate_batches : :class:`bool`, optional
-            If ``True`` the same batch can be yielded more than once.
-
-        key_maker : :class:`.MoleculeKeyMaker`, optional
-            Used to get the keys of molecules. If two molecules have
-            the same key, they are considered duplicates.
-
-        fitness_modifier : :class:`callable`, optional
-            Takes the `population` on which :meth:`.select` is called
-            and returns a :class:`dict`, which maps records in the
-            `population` to the fitness values the :class:`.Selector`
-            should use. If ``None``, the regular fitness values of the
-            records are used.
+        Parameters:
 
-        random_seed : :class:`int`, optional
-            The random seed to use.
+            num_batches:
+                The number of batches to yield. If ``None`` then yielding
+                will continue forever or until the generator is exhausted,
+                whichever comes first.
+
+            batch_size:
+                The number of molecules yielded at once.
+
+            duplicate_molecules:
+                If ``True`` the same molecule can be yielded in more than
+                one batch.
+
+            duplicate_batches:
+                If ``True`` the same batch can be yielded more than once.
+
+            key_maker:
+                Used to get the keys of molecules. If two molecules have
+                the same key, they are considered duplicates.
+
+            fitness_modifier:
+                Takes the `population` on which :meth:`~.Selector.select`
+                is called and returns a :class:`dict`, which maps records
+                in the `population` to the fitness values the
+                :class:`.Selector` should use. If ``None``, the regular
+                fitness values of the records are used.
 
+            random_seed:
+                The random seed to use.
         """
-
         if fitness_modifier is None:
             fitness_modifier = self._get_fitness_values
 
-        if num_batches is None:
-            num_batches = float('inf')
+        super().__init__(key_maker, fitness_modifier, batch_size)
+
+        if random_seed is None or isinstance(random_seed, int):
+            random_seed = np.random.default_rng(random_seed)
 
-        self._generator = np.random.RandomState(random_seed)
+        self._generator = random_seed
         self._duplicate_molecules = duplicate_molecules
         self._duplicate_batches = duplicate_batches
-        self._num_batches = num_batches
-        self._batch_size = batch_size
-        super().__init__(
-            key_maker=key_maker,
-            fitness_modifier=fitness_modifier,
+        self._num_batches = (
+            float("inf") if num_batches is None else num_batches
         )
 
     def _select_from_batches(self, batches, yielded_batches):
         batches = sorted(batches, reverse=True)
 
         # SUS may need to run multiple rounds if duplicate_molecules or
         # duplicate_batches is False. This is because in each round
@@ -137,18 +133,15 @@
         # batches sharing molecules. If this happens the lower fitness
         # batch will not be yielded. Instead a second round of SUS will
         # occur with any ineligible batches removed and a reduced
         # number of pointers, to account for batches yielded in the
         # previous rounds. This will repeat until the desired number
         # of batches has been yielded, or there are no more valid
         # batches.
-        while (
-            batches
-            and yielded_batches.get_num() < self._num_batches
-        ):
+        while batches and yielded_batches.get_num() < self._num_batches:
             yield from self._select_with_stochastic_universal_sampling(
                 batches=batches,
                 yielded_batches=yielded_batches,
             )
 
             if yielded_batches.get_num() < self._num_batches:
                 if not self._duplicate_molecules:
@@ -168,27 +161,25 @@
                     batches = tuple(batches)
 
     def _select_with_stochastic_universal_sampling(
         self,
         batches,
         yielded_batches,
     ):
-
         total = sum(batch.get_fitness_value() for batch in batches)
         batch_positions = []
         batch_position = 0
         for batch in batches:
-            batch_position += batch.get_fitness_value()/total
+            batch_position += batch.get_fitness_value() / total
             batch_positions.append(batch_position)
 
         num_batches = min(
-            self._num_batches - yielded_batches.get_num(),
-            len(batches)
+            self._num_batches - yielded_batches.get_num(), len(batches)
         )
-        pointer_distance = 1/num_batches
+        pointer_distance = 1 / num_batches
         pointers = []
         pointer = self._generator.uniform(0, pointer_distance)
         for i in range(num_batches):
             pointers.append(pointer)
             pointer += pointer_distance
 
         batch_index = 0
```

### Comparing `stk-2022.6.17.0/src/stk/ea/selection/selectors/tournament.py` & `stk-2023.7.5.0/src/stk/_internal/ea/selection/selectors/tournament.py`

 * *Files 10% similar despite different names*

```diff
@@ -1,157 +1,145 @@
-"""
-Tournament
-==========
-
-"""
+import typing
+from collections.abc import Callable, Sequence
 
 import numpy as np
 
-from stk.molecular import Inchi
+from stk._internal.key_makers.inchi import Inchi
+from stk._internal.key_makers.molecule import MoleculeKeyMaker
 
 from .selector import Selector
 
+T = typing.TypeVar("T")
+
 
-class Tournament(Selector):
+class Tournament(Selector[T]):
     """
     Yields batches of molecules through tournament selection.
 
     In tournament selection, a random number of batches is chosen from
     the population to undergo a competition. In each competition, the
     batch with the highest fitness value is yielded. This is repeated
     until `num_batches` are yielded.
 
-    Examples
-    --------
-    *Yielding Single Molecule Batches*
+    Examples:
 
-    Yielding molecules one at a time. For example, if molecules need
-    to be selected for mutation or the next generation.
+        *Yielding Single Molecule Batches*
 
-    .. testcode:: yielding-single-molecule-batches
+        Yielding molecules one at a time. For example, if molecules need
+        to be selected for mutation or the next generation.
 
-        import stk
+        .. testcode:: yielding-single-molecule-batches
 
-        # Make the selector.
-        tournament = stk.Tournament(
-            num_batches=5,
-            batch_size=1
-        )
+            import stk
 
-        population = tuple(
-            stk.MoleculeRecord(
-                topology_graph=stk.polymer.Linear(
-                    building_blocks=(
-                        stk.BuildingBlock(
-                            smiles='BrCCBr',
-                            functional_groups=[stk.BromoFactory()],
+            # Make the selector.
+            tournament = stk.Tournament(
+                num_batches=5,
+                batch_size=1
+            )
+
+            population = tuple(
+                stk.MoleculeRecord(
+                    topology_graph=stk.polymer.Linear(
+                        building_blocks=(
+                            stk.BuildingBlock(
+                                smiles='BrCCBr',
+                                functional_groups=[stk.BromoFactory()],
+                            ),
                         ),
+                        repeating_unit='A',
+                        num_repeating_units=2,
                     ),
-                    repeating_unit='A',
-                    num_repeating_units=2,
-                ),
-            ).with_fitness_value(i)
-            for i in range(100)
-        )
+                ).with_fitness_value(i)
+                for i in range(100)
+            )
 
-        # Select the molecules.
-        for selected, in tournament.select(population):
-            # Do stuff with each selected molecule.
-            pass
+            # Select the molecules.
+            for selected, in tournament.select(population):
+                # Do stuff with each selected molecule.
+                pass
 
     """
 
     def __init__(
         self,
-        num_batches=None,
-        batch_size=1,
-        duplicate_molecules=True,
-        duplicate_batches=True,
-        key_maker=Inchi(),
-        fitness_modifier=None,
-        random_seed=None,
-    ):
+        num_batches: int | None = None,
+        batch_size: int = 1,
+        duplicate_molecules: bool = True,
+        duplicate_batches: bool = True,
+        key_maker: MoleculeKeyMaker = Inchi(),
+        fitness_modifier: Callable[[Sequence[T]], dict[T, float]]
+        | None = None,
+        random_seed: int | np.random.Generator | None = None,
+    ) -> None:
         """
-        Initialize a :class:`.Tournament` instance.
-
-        Parameters
-        ----------
-        num_batches : :class:`int`, optional
-            The number of batches to yield. If ``None`` then yielding
-            will continue forever or until the generator is exhausted,
-            whichever comes first.
-
-        batch_size : :class:`int`, optional
-            The number of molecules yielded at once.
-
-        duplicate_molecules : :class:`bool`, optional
-            If ``True`` the same molecule can be yielded in more than
-            one batch.
-
-        duplicate_batches : :class:`bool`, optional
-            If ``True`` the same batch can be yielded more than once.
-
-        key_maker : :class:`.MoleculeKeyMaker`, optional
-            Used to get the keys of molecules. If two molecules have
-            the same key, they are considered duplicates.
-
-        fitness_modifier : :class:`callable`, optional
-            Takes the `population` on which :meth:`.select` is called
-            and returns a :class:`dict`, which maps records in the
-            `population` to the fitness values the :class:`.Selector`
-            should use. If ``None``, the regular fitness values of the
-            records are used.
-
-        random_seed : :class:`int`, optional
-            The random seed to use.
+        Parameters:
+            num_batches:
+                The number of batches to yield. If ``None`` then yielding
+                will continue forever or until the generator is exhausted,
+                whichever comes first.
+
+            batch_size:
+                The number of molecules yielded at once.
+
+            duplicate_molecules:
+                If ``True`` the same molecule can be yielded in more than
+                one batch.
+
+            duplicate_batches:
+                If ``True`` the same batch can be yielded more than once.
+
+            key_maker:
+                Used to get the keys of molecules. If two molecules have
+                the same key, they are considered duplicates.
+
+            fitness_modifier:
+                Takes the `population` on which :meth:`~.Selector.select`
+                is called and returns a :class:`dict`, which maps records
+                in the `population` to the fitness values the
+                :class:`.Selector` should use. If ``None``, the regular
+                fitness values of the records are used.
 
+            random_seed:
+                The random seed to use.
         """
-
         if fitness_modifier is None:
             fitness_modifier = self._get_fitness_values
 
-        self._generator = np.random.RandomState(random_seed)
-        if num_batches is None:
-            num_batches = float('inf')
+        super().__init__(key_maker, fitness_modifier, batch_size)
+
+        if random_seed is None or isinstance(random_seed, int):
+            random_seed = np.random.default_rng(random_seed)
 
+        self._generator = random_seed
         self._duplicate_molecules = duplicate_molecules
         self._duplicate_batches = duplicate_batches
-        self._batch_size = batch_size
-        self._num_batches = num_batches
-        super().__init__(
-            key_maker=key_maker,
-            fitness_modifier=fitness_modifier,
+        self._num_batches = (
+            float("inf") if num_batches is None else num_batches
         )
 
     def _select_from_batches(self, batches, yielded_batches):
         # The tournament can only take place if there is more than 1
         # batch.
         while (
-            len(batches) > 1
-            and yielded_batches.get_num() < self._num_batches
+            len(batches) > 1 and yielded_batches.get_num() < self._num_batches
         ):
-            tournament_size = self._generator.randint(
-                low=2,
-                high=len(batches)+1
+            tournament_size = self._generator.integers(
+                low=2, high=len(batches) + 1
             )
             competitors = self._generator.choice(
-                a=batches,
-                size=tournament_size,
-                replace=False
+                a=batches, size=tournament_size, replace=False
             )
             yield max(competitors)
 
             if not self._duplicate_molecules:
                 batches = filter(
                     yielded_batches.has_no_yielded_molecules,
                     batches,
                 )
             if not self._duplicate_batches:
                 batches = filter(
                     yielded_batches.is_unyielded_batch,
                     batches,
                 )
-            if (
-                not self._duplicate_molecules
-                or not self._duplicate_batches
-            ):
+            if not self._duplicate_molecules or not self._duplicate_batches:
                 batches = tuple(batches)
```

### Comparing `stk-2022.6.17.0/src/stk/ea/selection/selectors/utilities/yielded_batches.py` & `stk-2023.7.5.0/src/stk/_internal/ea/selection/selectors/utilities/yielded_batches.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,21 +1,14 @@
-"""
-Yielded Batches
-===============
-
-"""
-
-
 class YieldedBatches:
     """
     Keeps track of batches yielded by :meth:`.Selector.select`.
 
     """
 
-    __slots__ = ('_molecules', '_batches', '_num', '_key_maker')
+    __slots__ = ("_molecules", "_batches", "_num", "_key_maker")
 
     def __init__(self, key_maker):
         self._key_maker = key_maker
 
         # Has all molecules yielded by select().
         self._molecules = set()
         # Has the identity_key() of all batches yielded by select().
```

### Comparing `stk-2022.6.17.0/src/stk/ea/selection/selectors/worst.py` & `stk-2023.7.5.0/src/stk/_internal/ea/selection/selectors/worst.py`

 * *Files 12% similar despite different names*

```diff
@@ -1,112 +1,104 @@
-"""
-Worst
-=====
+import itertools
+import typing
+from collections.abc import Callable, Sequence
 
-"""
-
-import itertools as it
-
-from stk.molecular import Inchi
+from stk._internal.key_makers.inchi import Inchi
+from stk._internal.key_makers.molecule import MoleculeKeyMaker
 
 from .selector import Selector
 
+T = typing.TypeVar("T")
 
-class Worst(Selector):
+
+class Worst(Selector[T]):
     """
     Selects batches of molecules, lowest fitness value first.
 
-    Examples
-    --------
-    *Yielding Batches Holding Multiple Molecules*
-
-    Select the worst 5 batches of size 3
-
-    .. testcode:: yielding-batches-holding-multiple-molecules
-
-        import stk
-
-        worst = stk.Worst(num_batches=5, batch_size=3)
-        population = tuple(
-            stk.MoleculeRecord(
-                topology_graph=stk.polymer.Linear(
-                    building_blocks=(
-                        stk.BuildingBlock(
-                            smiles='BrCCBr',
-                            functional_groups=[stk.BromoFactory()],
+    Examples:
+
+        *Yielding Batches Holding Multiple Molecules*
+
+        Select the worst 5 batches of size 3
+
+        .. testcode:: yielding-batches-holding-multiple-molecules
+
+            import stk
+
+            worst = stk.Worst(num_batches=5, batch_size=3)
+            population = tuple(
+                stk.MoleculeRecord(
+                    topology_graph=stk.polymer.Linear(
+                        building_blocks=(
+                            stk.BuildingBlock(
+                                smiles='BrCCBr',
+                                functional_groups=[stk.BromoFactory()],
+                            ),
                         ),
+                        repeating_unit='A',
+                        num_repeating_units=2,
                     ),
-                    repeating_unit='A',
-                    num_repeating_units=2,
-                ),
-            ).with_fitness_value(i)
-            for i in range(10)
-        )
-        for batch in worst.select(population):
-            # Do stuff with batch.
-            pass
+                ).with_fitness_value(i)
+                for i in range(10)
+            )
+            for batch in worst.select(population):
+                # Do stuff with batch.
+                pass
 
     """
 
     def __init__(
         self,
-        num_batches=None,
-        batch_size=1,
-        duplicate_molecules=True,
-        duplicate_batches=True,
-        key_maker=Inchi(),
-        fitness_modifier=None,
-    ):
+        num_batches: int | None = None,
+        batch_size: int = 1,
+        duplicate_molecules: bool = True,
+        duplicate_batches: bool = True,
+        key_maker: MoleculeKeyMaker = Inchi(),
+        fitness_modifier: Callable[[Sequence[T]], dict[T, float]]
+        | None = None,
+    ) -> None:
         """
-        Initialize a :class:`.Worst` instance.
-
-        Parameters
-        ----------
-        num_batches : :class:`int`, optional
-            The number of batches to yield. If ``None`` then yielding
-            will continue forever or until the generator is exhausted,
-            whichever comes first.
-
-        batch_size : :class:`int`, optional
-            The number of molecules yielded at once.
-
-        duplicate_molecules : :class:`bool`, optional
-            If ``True`` the same molecule can be yielded in more than
-            one batch.
-
-        duplicate_batches : :class:`bool`, optional
-            If ``True`` the same batch can be yielded more than once.
-            Duplicate batches can occur if the same molecule is found
-            multiple times in a population.
-
-        key_maker : :class:`.MoleculeKeyMaker`, optional
-            Used to get the keys of molecules, which are used to
-            determine if two molecules are duplicates of each
-            other.
-
-        fitness_modifier : :class:`callable`, optional
-            Takes the `population` on which :meth:`.select` is called
-            and returns a :class:`dict`, which maps records in the
-            `population` to the fitness values the :class:`.Selector`
-            should use. If ``None``, the regular fitness values of the
-            records are used.
-
+        Parameters:
+            num_batches:
+                The number of batches to yield. If ``None`` then yielding
+                will continue forever or until the generator is exhausted,
+                whichever comes first.
+
+            batch_size:
+                The number of molecules yielded at once.
+
+            duplicate_molecules:
+                If ``True`` the same molecule can be yielded in more than
+                one batch.
+
+            duplicate_batches:
+                If ``True`` the same batch can be yielded more than once.
+                Duplicate batches can occur if the same molecule is found
+                multiple times in a population.
+
+            key_maker:
+                Used to get the keys of molecules, which are used to
+                determine if two molecules are duplicates of each
+                other.
+
+            fitness_modifier:
+                Takes the `population` on which :meth:`~.Selector.select`
+                is called and returns a :class:`dict`, which maps records
+                in the `population` to the fitness values the
+                :class:`.Selector` should use. If ``None``, the regular
+                fitness values of the records are used.
         """
-
         if fitness_modifier is None:
             fitness_modifier = self._get_fitness_values
 
+        super().__init__(key_maker, fitness_modifier, batch_size)
+
         self._duplicate_molecules = duplicate_molecules
         self._duplicate_batches = duplicate_batches
         self._num_batches = num_batches
-        self._batch_size = batch_size
-        super().__init__(
-            key_maker=key_maker,
-            fitness_modifier=fitness_modifier,
-        )
 
     def _select_from_batches(self, batches, yielded_batches):
         batches = sorted(batches)
 
         if not self._duplicate_molecules:
             batches = filter(
                 yielded_batches.has_no_yielded_molecules,
@@ -115,8 +107,8 @@
 
         if not self._duplicate_batches:
             batches = filter(
                 yielded_batches.is_unyielded_batch,
                 batches,
             )
 
-        yield from it.islice(batches, self._num_batches)
+        yield from itertools.islice(batches, self._num_batches)
```

### Comparing `stk-2022.6.17.0/src/stk/molecular/atoms/atom.py` & `stk-2023.7.5.0/src/stk/_internal/atom.py`

 * *Files identical despite different names*

### Comparing `stk-2022.6.17.0/src/stk/molecular/atoms/atom_info.py` & `stk-2023.7.5.0/src/stk/_internal/bond_info.py`

 * *Files 12% similar despite different names*

```diff
@@ -1,123 +1,93 @@
 """
-Atom Info
+Bond Info
 =========
 
 """
 
 
-class AtomInfo:
+class BondInfo:
     """
-    Holds additional info about :class:`.ConstructedMolecule` atoms.
+    Holds additional info about :class:`.ConstructedMolecule` bonds.
 
     """
 
-    def __init__(
-        self,
-        atom,
-        building_block_atom,
-        building_block,
-        building_block_id,
-    ):
+    def __init__(self, bond, building_block, building_block_id):
         """
-        Initialize an :class:`.AtomInfo` instance.
+        Initialize an :class:`.BondInfo` instance.
 
         Parameters
         ----------
-        atom : :class:`.Atom`
-            The atom about which information is held.
-
-        building_block_atom : :class:`.Atom`
-            The building block atom from which this atom originates.
-            Can be ``None``, if the atom was not part of the building
-            block, but was added by the construction process instead.
+        bond : :class:`.Bond`
+            The bond about which information is held.
 
         building_block : :class:`.Molecule` or :class:`NoneType`
-            The building block from which the atom originates.
-            Can be ``None``, if the atom was not part of a building
+            The building block from which the bond originates.
+            Can be ``None``, if the bond was not part of a building
             block, but was added by the construction process instead.
 
         building_block_id : :class:`int` or :class:`NoneType`
             A unique id for each :class:`.Molecule` placed during
             the construction of the :class:`.ConstructedMolecule`. As a
             single :class:`.Molecule` can be placed multiple times
             during construction, the `building_block_id` allows
             the user to distinguish between each placement. Can be
-            ``None``, if the atom was not part of a building block, but
+            ``None``, if the bond was not part of a building block, but
             was added by the construction process instead.
 
         """
-
-        self._atom = atom
-        self._building_block_atom = building_block_atom
+        self._bond = bond
         self._building_block = building_block
         self._building_block_id = building_block_id
 
-    def get_atom(self):
-        """
-        Get the atom about which information is held.
-
-        Returns
-        -------
-        :class:`.Atom`
-            The atom.
-
-        """
-
-        return self._atom
-
-    def get_building_block_atom(self):
+    def get_bond(self):
         """
-        Get the original atom held by the building block.
+        Get the bond about which information is held.
 
         Returns
         -------
-        :class:`.Atom`
-            The building block atom.
-
-        None : :class:`NoneType`
-            If the atom was not originally found in a building block,
-            but was added by the construction process instead.
+        :class:`.Bond`
+            The bond.
 
         """
 
-        return self._building_block_atom
+        return self._bond
 
     def get_building_block(self):
         """
-        Get the building block from which the atom originates.
+        Get the building block from which the bond originates.
 
         Returns
         -------
         :class:`.Molecule`
             The building block.
 
         None : :class:`NoneType`
-            If the atom was not originally found in a building block,
+            If the bond was not originally found in a building block,
             but was added by the construction process instead.
 
         """
 
         return self._building_block
 
     def get_building_block_id(self):
         """
-        Get the id of the atom's building block.
+        Get the id of the bond's building block.
 
         A unique id for each :class:`.Molecule` placed during
         the construction of the :class:`.ConstructedMolecule`. As a
         single :class:`.Molecule` can be placed multiple times
-        during construction, the building block id allows
+        during construction, the building block id  allows
         the user to distinguish between each placement.
 
         Returns
         -------
         :class:`int`
             The id.
 
         None : :class:`NoneType`
-            If the atom was not originally found in a building block,
+            If the bond was not originally found in a building block,
             but was added by the construction process instead.
 
         """
 
         return self._building_block_id
```

### Comparing `stk-2022.6.17.0/src/stk/molecular/atoms/elements.py` & `stk-2023.7.5.0/src/stk/_internal/elements.py`

 * *Files 0% similar despite different names*

```diff
@@ -6,17 +6,17 @@
 
 """
 
 from __future__ import annotations
 
 from typing import ClassVar, TypeVar
 
-from .atom import Atom
+from stk._internal.atom import Atom
 
-_T = TypeVar('_T', bound='AtomImpl')
+_T = TypeVar("_T", bound="AtomImpl")
 
 
 class AtomImpl(Atom):
     """
     An implementation of the :class:`.Atom` interface.
 
     """
@@ -27,15 +27,14 @@
         cls._elements[cls._atomic_number] = cls
 
     def __init__(
         self,
         id: int,
         charge: int = 0,
     ) -> None:
-
         self._id = id
         self._charge = charge
 
     def get_id(self) -> int:
         return self._id
 
     def _with_id(self: _T, id: int) -> _T:
@@ -56,18 +55,16 @@
     def get_charge(self) -> int:
         return self._charge
 
     def clone(self) -> AtomImpl:
         return type(self)(self._id, self._charge)
 
     def __repr__(self) -> str:
-        charge = (
-            f', charge={self._charge}' if self._charge != 0 else ''
-        )
-        return f'{self.__class__.__name__}({self._id}{charge})'
+        charge = f", charge={self._charge}" if self._charge != 0 else ""
+        return f"{self.__class__.__name__}({self._id}{charge})"
 
     def __str__(self) -> str:
         return repr(self)
 
 
 class H(AtomImpl):
     _atomic_number = 1
```

### Comparing `stk-2022.6.17.0/src/stk/molecular/bonds/bond.py` & `stk-2023.7.5.0/src/stk/_internal/bond.py`

 * *Files 2% similar despite different names*

```diff
@@ -4,17 +4,17 @@
 
 """
 
 from __future__ import annotations
 
 from typing import TypeVar
 
-from ..atoms import Atom
+from stk._internal.atom import Atom
 
-_T = TypeVar('_T', bound='Bond')
+_T = TypeVar("_T", bound="Bond")
 
 
 class Bond:
     """
     Represents an atomic bond.
 
     Examples:
@@ -198,15 +198,14 @@
             The clone.
 
         """
 
         return self.clone()._with_ids(id_map)
 
     def _with_ids(self, id_map: dict[int, int]) -> Bond:
-
         id1 = self._atom1.get_id()
         if id1 in id_map:
             self._atom1 = self._atom1.with_id(id_map[id1])
 
         id2 = self._atom2.get_id()
         if id2 in id_map:
             self._atom2 = self._atom2.with_id(id_map[id2])
@@ -223,20 +222,18 @@
 
         """
 
         return any(direction != 0 for direction in self._periodicity)
 
     def __repr__(self) -> str:
         periodicity = (
-            f', periodicity={self._periodicity}'
-            if self.is_periodic()
-            else ''
+            f", periodicity={self._periodicity}" if self.is_periodic() else ""
         )
 
         cls_name = self.__class__.__name__
         return (
-            f'{cls_name}({self._atom1!r}, {self._atom2!r}, '
-            f'{self._order}{periodicity})'
+            f"{cls_name}({self._atom1!r}, {self._atom2!r}, "
+            f"{self._order}{periodicity})"
         )
 
     def __str__(self) -> str:
         return repr(self)
```

### Comparing `stk-2022.6.17.0/src/stk/molecular/bonds/bond_info.py` & `stk-2023.7.5.0/src/stk/_internal/atom_info.py`

 * *Files 21% similar despite different names*

```diff
@@ -1,93 +1,122 @@
 """
-Bond Info
+Atom Info
 =========
 
 """
 
 
-class BondInfo:
-    """
-    Holds additional info about :class:`.ConstructedMolecule` bonds.
+import typing
+
+from stk._internal.atom import Atom
+from stk._internal.molecule import Molecule
 
+
+class AtomInfo:
     """
+    Holds additional info about :class:`.ConstructedMolecule` atoms.
 
-    def __init__(self, bond, building_block, building_block_id):
-        """
-        Initialize an :class:`.BondInfo` instance.
+    """
 
-        Parameters
-        ----------
-        bond : :class:`.Bond`
-            The bond about which information is held.
-
-        building_block : :class:`.Molecule` or :class:`NoneType`
-            The building block from which the bond originates.
-            Can be ``None``, if the bond was not part of a building
-            block, but was added by the construction process instead.
-
-        building_block_id : :class:`int` or :class:`NoneType`
-            A unique id for each :class:`.Molecule` placed during
-            the construction of the :class:`.ConstructedMolecule`. As a
-            single :class:`.Molecule` can be placed multiple times
-            during construction, the `building_block_id` allows
-            the user to distinguish between each placement. Can be
-            ``None``, if the bond was not part of a building block, but
-            was added by the construction process instead.
+    def __init__(
+        self,
+        atom: Atom,
+        building_block_atom: typing.Optional[Atom],
+        building_block: typing.Optional[Molecule],
+        building_block_id: typing.Optional[int],
+    ) -> None:
+        """
+        Initialize an :class:`.AtomInfo` instance.
+
+        Parameters:
+
+            atom:
+                The atom about which information is held.
+
+            building_block_atom:
+                The building block atom from which this atom
+                originates. Can be ``None``, if the atom was not part
+                of the building block, but was added by the
+                construction process instead.
+
+            building_block:
+                The building block from which the atom originates.
+                Can be ``None``, if the atom was not part of a building
+                block, but was added by the construction process
+                instead.
+
+            building_block_id:
+                A unique id for each :class:`.Molecule` placed during
+                the construction of the :class:`.ConstructedMolecule`.
+                As a single :class:`.Molecule` can be placed multiple
+                times during construction, the `building_block_id`
+                allows the user to distinguish between each placement.
+                Can be ``None``, if the atom was not part of a
+                building block, but was added by the construction
+                process instead.
 
         """
-        self._bond = bond
+
+        self._atom = atom
+        self._building_block_atom = building_block_atom
         self._building_block = building_block
         self._building_block_id = building_block_id
 
-    def get_bond(self):
+    def get_atom(self) -> Atom:
         """
-        Get the bond about which information is held.
+        Get the atom about which information is held.
 
-        Returns
-        -------
-        :class:`.Bond`
-            The bond.
+        Returns:
+
+            The atom.
 
         """
 
-        return self._bond
+        return self._atom
 
-    def get_building_block(self):
+    def get_building_block_atom(self) -> typing.Optional[Atom]:
         """
-        Get the building block from which the bond originates.
+        Get the original atom held by the building block.
 
-        Returns
-        -------
-        :class:`.Molecule`
-            The building block.
+        Returns:
 
-        None : :class:`NoneType`
-            If the bond was not originally found in a building block,
-            but was added by the construction process instead.
+            The building block atom or ``None`` if the atom was not
+            originally found in a building block, but was added by the
+            construction process instead.
+
+        """
+
+        return self._building_block_atom
+
+    def get_building_block(self) -> typing.Optional[Molecule]:
+        """
+        Get the building block from which the atom originates.
+
+        Returns:
+
+            The building block or ``None`` if the atom was not
+            originally found in a building block, but was added by the
+            construction process instead.
 
         """
 
         return self._building_block
 
-    def get_building_block_id(self):
+    def get_building_block_id(self) -> typing.Optional[int]:
         """
-        Get the id of the bond's building block.
+        Get the id of the atom's building block.
 
         A unique id for each :class:`.Molecule` placed during
         the construction of the :class:`.ConstructedMolecule`. As a
         single :class:`.Molecule` can be placed multiple times
-        during construction, the building block id  allows
+        during construction, the building block id allows
         the user to distinguish between each placement.
 
-        Returns
-        -------
-        :class:`int`
-            The id.
-
-        None : :class:`NoneType`
-            If the bond was not originally found in a building block,
-            but was added by the construction process instead.
+        Returns:
+
+            The unique building block id or ``None`` if the atom was
+            not originally found in a building block, but was added by
+            the construction process instead.
 
         """
 
         return self._building_block_id
```

### Comparing `stk-2022.6.17.0/src/stk/molecular/functional_groups/factories/alcohol_factory.py` & `stk-2023.7.5.0/src/stk/_internal/functional_group_factories/diol_factory.py`

 * *Files 10% similar despite different names*

```diff
@@ -1,113 +1,116 @@
 """
-Alcohol Factory
-===============
+Diol Factory
+============
 
 """
 
-from ..functional_groups import Alcohol
-from .functional_group_factory import FunctionalGroupFactory
-from .utilities import _get_atom_ids
 
+from stk._internal.functional_group_factories.functional_group_factory import (
+    FunctionalGroupFactory,
+)
+from stk._internal.functional_group_factories.utilities import get_atom_ids
+from stk._internal.functional_groups.diol import Diol
 
-class AlcoholFactory(FunctionalGroupFactory):
+
+class DiolFactory(FunctionalGroupFactory):
     """
-    Creates :class:`.Alcohol` instances.
+    Creates :class:`.Diol` instances.
 
     Creates functional groups from substructures, which match the
-    ``[*][O][H]`` functional group string.
+    ``[H][O][#6]~[#6][O][H]`` functional group string.
 
     Examples
     --------
     *Creating Functional Groups with the Factory*
 
-    You want to create a building block which has :class:`.Alcohol`
-    functional groups. You want the oxygen atom in those functional
-    groups to be the bonder atom, and the hydrogen atom to be the
-    deleter atom.
+    You want to create a building block which has :class:`.Diol`
+    functional groups. You want the carbon atoms in those functional
+    groups to be the *bonder* atoms, and the OH groups to be a leaving
+    groups.
 
     .. testcode:: creating-functional-groups-with-the-factory
 
         import stk
 
         building_block = stk.BuildingBlock(
-            smiles='OCCCO',
-            functional_groups=(stk.AlcoholFactory(), ),
+            smiles='CCCC(O)C(O)CCCC',
+            functional_groups=(stk.DiolFactory(), ),
         )
 
     .. testcode:: creating-functional-groups-with-the-factory
         :hide:
 
         assert all(
-            isinstance(functional_group, stk.Alcohol)
+            isinstance(functional_group, stk.Diol)
             for functional_group
             in building_block.get_functional_groups()
         )
-        assert building_block.get_num_functional_groups() == 2
+        assert building_block.get_num_functional_groups() == 1
 
     *Changing the Bonder and Deleter Atoms*
 
-    You want to create a building block which has :class:`.Alcohol`
-    functional groups. You want the OH group to be
-    treated as a leaving group. This means the non-hydrogen atom bonded
-    to oxygen is the *bonder* atom and both the oxygen and hydrogen
-    atoms are *deleter* atoms.
+    You want to create a building block which has :class:`.Diol`
+    functional groups. You want the oxygen atoms to be the *bonder*
+    atoms and the hydrogen atoms to be the *deleter* atoms.
 
     .. testcode:: changing-the-bonder-and-deleter-atoms
 
         import stk
 
-        alcohol_factory = stk.AlcoholFactory(
-            # The index of the non-hydrogen atom connected to oxygen
-            # is 0 in the functional group string (see docstring).
-            bonders=(0, ),
-            # The indices of the oxygen and hydrogen atoms in the
-            # functional group string (see docstring) are
-            # 1 and 2, respectively.
-            deleters=(1, 2),
+        diol_factory = stk.DiolFactory(
+            # The indices of the oxygen atoms in the functional
+            # group string (see docstring) are 1 and 4.
+            bonders=(1, 4),
+            # The indices of the hydrogen atoms in the functional
+            # group string (see docstring) are 0 and 5.
+            deleters=(0, 5),
         )
         building_block = stk.BuildingBlock(
-            smiles='OCCCO',
-            functional_groups=(alcohol_factory, ),
+            smiles='CCCC(O)C(O)CCCC',
+            functional_groups=(diol_factory, ),
         )
 
     .. testcode:: changing-the-bonder-and-deleter-atoms
         :hide:
 
-        fg1, fg2 = building_block.get_functional_groups()
-        assert fg1.get_num_bonders() == 1
-        assert sum(1 for _ in fg1.get_deleters()) == 2
-        assert fg2.get_num_bonders() == 1
-        assert sum(1 for _ in fg2.get_deleters()) == 2
+        fg, = building_block.get_functional_groups()
+        assert fg.get_num_bonders() == 2
+        assert sum(1 for _ in fg.get_deleters()) == 2
 
         assert all(
-            isinstance(atom, stk.C)
+            isinstance(atom, stk.O)
             for functional_group
             in building_block.get_functional_groups()
             for atom
             in functional_group.get_bonders()
         )
         assert all(
-            isinstance(atom, (stk.O, stk.H))
+            isinstance(atom, stk.H)
             for functional_group
             in building_block.get_functional_groups()
             for atom
             in functional_group.get_deleters()
         )
 
     See Also
     --------
     :class:`.GenericFunctionalGroup`
         Defines *bonders* and  *deleters*.
 
     """
 
-    def __init__(self, bonders=(1, ), deleters=(2, ), placers=None):
+    def __init__(
+        self,
+        bonders=(2, 3),
+        deleters=(0, 1, 4, 5),
+        placers=None,
+    ):
         """
-        Initialize an :class:`.AlcoholFactory` instance.
+        Initialize a :class:`.DiolFactory` instance.
 
         Parameters
         ----------
         bonders : :class:`tuple` of :class:`int`
             The indices of atoms in the functional group string, which
             are *bonder* atoms.
 
@@ -122,17 +125,21 @@
         """
 
         self._bonders = bonders
         self._deleters = deleters
         self._placers = bonders if placers is None else placers
 
     def get_functional_groups(self, molecule):
-        for atom_ids in _get_atom_ids('[*][O][H]', molecule):
+        ids = get_atom_ids("[H][O][#6]~[#6][O][H]", molecule)
+        for atom_ids in ids:
             atoms = tuple(molecule.get_atoms(atom_ids))
-            yield Alcohol(
-                oxygen=atoms[1],
-                hydrogen=atoms[2],
-                atom=atoms[0],
+            yield Diol(
+                hydrogen1=atoms[0],
+                oxygen1=atoms[1],
+                atom1=atoms[2],
+                atom2=atoms[3],
+                oxygen2=atoms[4],
+                hydrogen2=atoms[5],
                 bonders=tuple(atoms[i] for i in self._bonders),
                 deleters=tuple(atoms[i] for i in self._deleters),
                 placers=tuple(atoms[i] for i in self._placers),
             )
```

### Comparing `stk-2022.6.17.0/src/stk/molecular/functional_groups/factories/aldehyde_factory.py` & `stk-2023.7.5.0/src/stk/_internal/functional_group_factories/aldehyde_factory.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,16 +1,18 @@
 """
 Aldehyde Factory
 ================
 
 """
 
-from ..functional_groups import Aldehyde
-from .functional_group_factory import FunctionalGroupFactory
-from .utilities import _get_atom_ids
+from stk._internal.functional_group_factories.functional_group_factory import (
+    FunctionalGroupFactory,
+)
+from stk._internal.functional_group_factories.utilities import get_atom_ids
+from stk._internal.functional_groups.aldehyde import Aldehyde
 
 
 class AldehydeFactory(FunctionalGroupFactory):
     """
     Creates :class:`.Aldehyde` instances.
 
     Creates functional groups from substructures, which match the
@@ -94,15 +96,15 @@
     See Also
     --------
     :class:`.GenericFunctionalGroup`
         Defines *bonders* and  *deleters*.
 
     """
 
-    def __init__(self, bonders=(1, ), deleters=(2, ), placers=None):
+    def __init__(self, bonders=(1,), deleters=(2,), placers=None):
         """
         Initialize a :class:`.AldehydeFactory` instance.
 
         Parameters
         ----------
         bonders : :class:`tuple` of :class:`int`
             The indices of atoms in the functional group string, which
@@ -119,15 +121,15 @@
         """
 
         self._bonders = bonders
         self._deleters = deleters
         self._placers = bonders if placers is None else placers
 
     def get_functional_groups(self, molecule):
-        for atom_ids in _get_atom_ids('[*][C](=[O])[H]', molecule):
+        for atom_ids in get_atom_ids("[*][C](=[O])[H]", molecule):
             atoms = tuple(molecule.get_atoms(atom_ids))
             yield Aldehyde(
                 carbon=atoms[1],
                 oxygen=atoms[2],
                 hydrogen=atoms[3],
                 atom=atoms[0],
                 bonders=tuple(atoms[i] for i in self._bonders),
```

### Comparing `stk-2022.6.17.0/src/stk/molecular/functional_groups/factories/amide_factory.py` & `stk-2023.7.5.0/src/stk/_internal/functional_group_factories/amide_factory.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,16 +1,19 @@
 """
 Amide Factory
 =============
 
 """
 
-from ..functional_groups import Amide
-from .functional_group_factory import FunctionalGroupFactory
-from .utilities import _get_atom_ids
+
+from stk._internal.functional_group_factories.functional_group_factory import (
+    FunctionalGroupFactory,
+)
+from stk._internal.functional_group_factories.utilities import get_atom_ids
+from stk._internal.functional_groups.amide import Amide
 
 
 class AmideFactory(FunctionalGroupFactory):
     """
     Creates :class:`.Amide` instances.
 
     Creates functional groups from substructures, which match the
@@ -96,15 +99,15 @@
     :class:`.GenericFunctionalGroup`
         Defines *bonders* and  *deleters*.
 
     """
 
     def __init__(
         self,
-        bonders=(1, ),
+        bonders=(1,),
         deleters=(3, 4, 5),
         placers=None,
     ):
         """
         Initialize a :class:`.AmideFactory` instance.
 
         Parameters
@@ -124,15 +127,15 @@
         """
 
         self._bonders = bonders
         self._deleters = deleters
         self._placers = bonders if placers is None else placers
 
     def get_functional_groups(self, molecule):
-        ids = _get_atom_ids('[*][C](=[O])[N]([H])[H]', molecule)
+        ids = get_atom_ids("[*][C](=[O])[N]([H])[H]", molecule)
         for atom_ids in ids:
             atoms = tuple(molecule.get_atoms(atom_ids))
             yield Amide(
                 carbon=atoms[1],
                 oxygen=atoms[2],
                 nitrogen=atoms[3],
                 hydrogen1=atoms[4],
```

### Comparing `stk-2022.6.17.0/src/stk/molecular/functional_groups/factories/boronic_acid_factory.py` & `stk-2023.7.5.0/src/stk/_internal/functional_group_factories/boronic_acid_factory.py`

 * *Files 3% similar despite different names*

```diff
@@ -1,16 +1,18 @@
 """
 Boronic Acid Factory
 ====================
 
 """
 
-from ..functional_groups import BoronicAcid
-from .functional_group_factory import FunctionalGroupFactory
-from .utilities import _get_atom_ids
+from stk._internal.functional_group_factories.functional_group_factory import (
+    FunctionalGroupFactory,
+)
+from stk._internal.functional_group_factories.utilities import get_atom_ids
+from stk._internal.functional_groups.boronic_acid import BoronicAcid
 
 
 class BoronicAcidFactory(FunctionalGroupFactory):
     """
     Creates :class:`.BoronicAcid` instances.
 
     Creates functional groups from substructures, which match the
@@ -98,15 +100,15 @@
     :class:`.GenericFunctionalGroup`
         Defines *bonders* and  *deleters*.
 
     """
 
     def __init__(
         self,
-        bonders=(1, ),
+        bonders=(1,),
         deleters=(2, 3, 4, 5),
         placers=None,
     ):
         """
         Initialize a :class:`.BoronicAcidFactory` instance.
 
         Parameters
@@ -126,15 +128,15 @@
         """
 
         self._bonders = bonders
         self._deleters = deleters
         self._placers = bonders if placers is None else placers
 
     def get_functional_groups(self, molecule):
-        ids = _get_atom_ids('[*][B]([O][H])[O][H]', molecule)
+        ids = get_atom_ids("[*][B]([O][H])[O][H]", molecule)
         for atom_ids in ids:
             atoms = tuple(molecule.get_atoms(atom_ids))
             yield BoronicAcid(
                 boron=atoms[1],
                 oxygen1=atoms[2],
                 hydrogen1=atoms[3],
                 oxygen2=atoms[4],
```

### Comparing `stk-2022.6.17.0/src/stk/molecular/functional_groups/factories/bromo_factory.py` & `stk-2023.7.5.0/src/stk/_internal/functional_group_factories/iodo_factory.py`

 * *Files 10% similar despite different names*

```diff
@@ -1,62 +1,66 @@
 """
-Bromo Factory
-=============
+Iodo Factory
+============
 
 """
 
-from ..functional_groups import Bromo
-from .functional_group_factory import FunctionalGroupFactory
-from .utilities import _get_atom_ids
 
+from stk._internal.functional_group_factories.functional_group_factory import (
+    FunctionalGroupFactory,
+)
+from stk._internal.functional_group_factories.utilities import get_atom_ids
+from stk._internal.functional_groups.iodo import Iodo
 
-class BromoFactory(FunctionalGroupFactory):
+
+class IodoFactory(FunctionalGroupFactory):
     """
-    Creates :class:`.Bromo` instances.
+    Creates :class:`.Iodo` instances.
 
     Creates functional groups from substructures, which match the
-    ``[*][Br]`` functional group string.
+    ``[*][I]`` functional group string.
 
     Examples
     --------
     *Creating Functional Groups with the Factory*
 
-    You want to create a building block which has :class:`.Bromo`
-    functional groups. You want the atom bonded to the bromine to be
-    the *bonder* atom, and the bromine atom to be the *deleter* atom.
+    You want to create a building block which has :class:`.Iodo`
+    functional groups. You want the non-iodine atom in those
+    functional groups to be the *bonder* atom, and the iodine atom
+    to be the *deleter* atom.
 
     .. testcode:: creating-functional-groups-with-the-factory
 
         import stk
 
         building_block = stk.BuildingBlock(
-            smiles='BrCCCBr',
-            functional_groups=(stk.BromoFactory(), ),
+            smiles='ICCCI',
+            functional_groups=(stk.IodoFactory(), ),
         )
 
     .. testcode:: creating-functional-groups-with-the-factory
         :hide:
 
         assert all(
-            isinstance(functional_group, stk.Bromo)
+            isinstance(functional_group, stk.Iodo)
             for functional_group
             in building_block.get_functional_groups()
         )
         assert building_block.get_num_functional_groups() == 2
 
     See Also
     --------
     :class:`.GenericFunctionalGroup`
         Defines *bonders* and  *deleters*.
 
     """
 
-    def __init__(self, bonders=(0, ), deleters=(1, ), placers=None):
+    def __init__(self, bonders=(0,), deleters=(1,), placers=None):
         """
-        Initialize a :class:`.BromoFactory` instance.
+        Initialize a :class:`.IodoFactory` instance.
 
         Parameters
         ----------
         bonders : :class:`tuple` of :class:`int`
             The indices of atoms in the functional group string, which
             are *bonder* atoms.
 
@@ -71,16 +75,16 @@
         """
 
         self._bonders = bonders
         self._deleters = deleters
         self._placers = bonders if placers is None else placers
 
     def get_functional_groups(self, molecule):
-        for atom_ids in _get_atom_ids('[*][Br]', molecule):
+        for atom_ids in get_atom_ids("[*][I]", molecule):
             atoms = tuple(molecule.get_atoms(atom_ids))
-            yield Bromo(
-                bromine=atoms[1],
+            yield Iodo(
+                iodine=atoms[1],
                 atom=atoms[0],
                 bonders=tuple(atoms[i] for i in self._bonders),
                 deleters=tuple(atoms[i] for i in self._deleters),
                 placers=tuple(atoms[i] for i in self._placers),
             )
```

### Comparing `stk-2022.6.17.0/src/stk/molecular/functional_groups/factories/carboxylic_acid_factory.py` & `stk-2023.7.5.0/src/stk/_internal/functional_group_factories/carboxylic_acid_factory.py`

 * *Files 5% similar despite different names*

```diff
@@ -1,16 +1,19 @@
 """
 Carboxylic Acid Factory
 =======================
 
 """
 
-from ..functional_groups import CarboxylicAcid
-from .functional_group_factory import FunctionalGroupFactory
-from .utilities import _get_atom_ids
+
+from stk._internal.functional_group_factories.functional_group_factory import (
+    FunctionalGroupFactory,
+)
+from stk._internal.functional_group_factories.utilities import get_atom_ids
+from stk._internal.functional_groups.carboxylic_acid import CarboxylicAcid
 
 
 class CarboxylicAcidFactory(FunctionalGroupFactory):
     """
     Creates :class:`.CarboxylicAcid` instances.
 
     Creates functional groups from substructures, which match the
@@ -97,15 +100,15 @@
     See Also
     --------
     :class:`.GenericFunctionalGroup`
         Defines *bonders* and  *deleters*.
 
     """
 
-    def __init__(self, bonders=(1, ), deleters=(3, 4), placers=None):
+    def __init__(self, bonders=(1,), deleters=(3, 4), placers=None):
         """
         Initialize a :class:`.CarboxylicAcidFactory` instance.
 
         Parameters
         ----------
         bonders : :class:`tuple` of :class:`int`
             The indices of atoms in the functional group string, which
@@ -122,15 +125,15 @@
         """
 
         self._bonders = bonders
         self._deleters = deleters
         self._placers = bonders if placers is None else placers
 
     def get_functional_groups(self, molecule):
-        for atom_ids in _get_atom_ids('[*][C](=[O])[O][H]', molecule):
+        for atom_ids in get_atom_ids("[*][C](=[O])[O][H]", molecule):
             atoms = tuple(molecule.get_atoms(atom_ids))
             yield CarboxylicAcid(
                 carbon=atoms[1],
                 oxygen1=atoms[2],
                 oxygen2=atoms[3],
                 hydrogen=atoms[4],
                 atom=atoms[0],
```

### Comparing `stk-2022.6.17.0/src/stk/molecular/functional_groups/factories/dibromo_factory.py` & `stk-2023.7.5.0/src/stk/_internal/functional_group_factories/dibromo_factory.py`

 * *Files 10% similar despite different names*

```diff
@@ -1,16 +1,19 @@
 """
 Dibromo Factory
 ===============
 
 """
 
-from ..functional_groups import Dibromo
-from .functional_group_factory import FunctionalGroupFactory
-from .utilities import _get_atom_ids
+
+from stk._internal.functional_group_factories.functional_group_factory import (
+    FunctionalGroupFactory,
+)
+from stk._internal.functional_group_factories.utilities import get_atom_ids
+from stk._internal.functional_groups.dibromo import Dibromo
 
 
 class DibromoFactory(FunctionalGroupFactory):
     """
     Creates :class:`.Dibromo` instances.
 
     Creates functional groups from substructures, which match the
@@ -117,15 +120,15 @@
         """
 
         self._bonders = bonders
         self._deleters = deleters
         self._placers = bonders if placers is None else placers
 
     def get_functional_groups(self, molecule):
-        for atom_ids in _get_atom_ids('[Br][#6]~[#6][Br]', molecule):
+        for atom_ids in get_atom_ids("[Br][#6]~[#6][Br]", molecule):
             atoms = tuple(molecule.get_atoms(atom_ids))
             yield Dibromo(
                 atom1=atoms[1],
                 bromine1=atoms[0],
                 atom2=atoms[2],
                 bromine2=atoms[3],
                 bonders=tuple(atoms[i] for i in self._bonders),
```

### Comparing `stk-2022.6.17.0/src/stk/molecular/functional_groups/factories/difluoro_factory.py` & `stk-2023.7.5.0/src/stk/_internal/functional_group_factories/difluoro_factory.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,16 +1,19 @@
 """
 Difluoro Factory
 ================
 
 """
 
-from ..functional_groups import Difluoro
-from .functional_group_factory import FunctionalGroupFactory
-from .utilities import _get_atom_ids
+
+from stk._internal.functional_group_factories.functional_group_factory import (
+    FunctionalGroupFactory,
+)
+from stk._internal.functional_group_factories.utilities import get_atom_ids
+from stk._internal.functional_groups.difluoro import Difluoro
 
 
 class DifluoroFactory(FunctionalGroupFactory):
     """
     Creates :class:`.Difluoro` instances.
 
     Creates functional groups from substructures, which match the
@@ -117,15 +120,15 @@
         """
 
         self._bonders = bonders
         self._deleters = deleters
         self._placers = bonders if placers is None else placers
 
     def get_functional_groups(self, molecule):
-        for atom_ids in _get_atom_ids('[F][#6]~[#6][F]', molecule):
+        for atom_ids in get_atom_ids("[F][#6]~[#6][F]", molecule):
             atoms = tuple(molecule.get_atoms(atom_ids))
             yield Difluoro(
                 atom1=atoms[1],
                 fluorine1=atoms[0],
                 atom2=atoms[2],
                 fluorine2=atoms[3],
                 bonders=tuple(atoms[i] for i in self._bonders),
```

### Comparing `stk-2022.6.17.0/src/stk/molecular/functional_groups/factories/diol_factory.py` & `stk-2023.7.5.0/src/stk/_internal/functional_group_factories/primary_amino_factory.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,113 +1,114 @@
 """
-Diol Factory
-============
+Primary Amino Factory
+=====================
 
 """
 
-from ..functional_groups import Diol
-from .functional_group_factory import FunctionalGroupFactory
-from .utilities import _get_atom_ids
 
+from stk._internal.functional_group_factories.functional_group_factory import (
+    FunctionalGroupFactory,
+)
+from stk._internal.functional_group_factories.utilities import get_atom_ids
+from stk._internal.functional_groups.primary_amino import PrimaryAmino
 
-class DiolFactory(FunctionalGroupFactory):
+
+class PrimaryAminoFactory(FunctionalGroupFactory):
     """
-    Creates :class:`.Diol` instances.
+    Creates :class:`.PrimaryAmino` instances.
 
     Creates functional groups from substructures, which match the
-    ``[H][O][#6]~[#6][O][H]`` functional group string.
+    ``[*][N]([H])[H]`` functional group string.
 
     Examples
     --------
     *Creating Functional Groups with the Factory*
 
-    You want to create a building block which has :class:`.Diol`
-    functional groups. You want the carbon atoms in those functional
-    groups to be the *bonder* atoms, and the OH groups to be a leaving
-    groups.
+    You want to create a building block which has
+    :class:`.PrimaryAmino` functional groups. You want the nitrogen
+    atom to be the *bonder* atom, and the hydrogen atoms to be the
+    *deleter* atoms.
 
     .. testcode:: creating-functional-groups-with-the-factory
 
         import stk
 
         building_block = stk.BuildingBlock(
-            smiles='CCCC(O)C(O)CCCC',
-            functional_groups=(stk.DiolFactory(), ),
+            smiles='NCCCCN',
+            functional_groups=(stk.PrimaryAminoFactory(), ),
         )
 
     .. testcode:: creating-functional-groups-with-the-factory
         :hide:
 
         assert all(
-            isinstance(functional_group, stk.Diol)
+            isinstance(functional_group, stk.PrimaryAmino)
             for functional_group
             in building_block.get_functional_groups()
         )
-        assert building_block.get_num_functional_groups() == 1
+        assert building_block.get_num_functional_groups() == 2
 
     *Changing the Bonder and Deleter Atoms*
 
-    You want to create a building block which has :class:`.Diol`
-    functional groups. You want the oxygen atoms to be the *bonder*
-    atoms and the hydrogen atoms to be the *deleter* atoms.
+    You want to create a building block which has
+    :class:`.PrimaryAmino` functional groups. You want the non-hydrogen
+    atom bonded to nitrogen to be the *bonder* atom and the
+    nitrogen and hydrogen atoms to be *deleter* atoms.
 
     .. testcode:: changing-the-bonder-and-deleter-atoms
 
         import stk
 
-        diol_factory = stk.DiolFactory(
-            # The indices of the oxygen atoms in the functional
-            # group string (see docstring) are 1 and 4.
-            bonders=(1, 4),
-            # The indices of the hydrogen atoms in the functional
-            # group string (see docstring) are 0 and 5.
-            deleters=(0, 5),
+        primary_amino_factory = stk.PrimaryAminoFactory(
+            # The index of the atom attached to the nitrogen is 0 in
+            # the functional group string (see docstring).
+            bonders=(0, ),
+            # The indices of the nitrogen and hydrogen atoms in the
+            # functional group string (see docstring) are 1, 2 and 3.
+            deleters=(1, 2, 3),
         )
         building_block = stk.BuildingBlock(
-            smiles='CCCC(O)C(O)CCCC',
-            functional_groups=(diol_factory, ),
+            smiles='NCCCCN',
+            functional_groups=(primary_amino_factory, ),
         )
 
     .. testcode:: changing-the-bonder-and-deleter-atoms
         :hide:
 
-        fg, = building_block.get_functional_groups()
-        assert fg.get_num_bonders() == 2
-        assert sum(1 for _ in fg.get_deleters()) == 2
+        fg1, fg2 = building_block.get_functional_groups()
+        assert fg1.get_num_bonders() == 1
+        assert sum(1 for _ in fg1.get_deleters()) == 3
+        assert fg2.get_num_bonders() == 1
+        assert sum(1 for _ in fg2.get_deleters()) == 3
 
         assert all(
-            isinstance(atom, stk.O)
+            isinstance(atom, stk.C)
             for functional_group
             in building_block.get_functional_groups()
             for atom
             in functional_group.get_bonders()
         )
         assert all(
-            isinstance(atom, stk.H)
+            isinstance(atom, (stk.H, stk.N))
             for functional_group
             in building_block.get_functional_groups()
             for atom
             in functional_group.get_deleters()
         )
 
     See Also
     --------
     :class:`.GenericFunctionalGroup`
         Defines *bonders* and  *deleters*.
 
     """
 
-    def __init__(
-        self,
-        bonders=(2, 3),
-        deleters=(0, 1, 4, 5),
-        placers=None,
-    ):
+    def __init__(self, bonders=(1,), deleters=(2, 3), placers=None):
         """
-        Initialize a :class:`.DiolFactory` instance.
+        Initialize a :class:`.PrimaryAminoFactory` instance.
 
         Parameters
         ----------
         bonders : :class:`tuple` of :class:`int`
             The indices of atoms in the functional group string, which
             are *bonder* atoms.
 
@@ -117,26 +118,28 @@
 
         placers : :class:`tuple` of :class:`int`, optional
             The indices of atoms in the functional group string, which
             are *placer* atoms. If ``None``, `bonders` will be used.
 
         """
 
+        """
+        Initialize an :class:`.AmineFactory`.
+
+        """
+
         self._bonders = bonders
         self._deleters = deleters
         self._placers = bonders if placers is None else placers
 
     def get_functional_groups(self, molecule):
-        ids = _get_atom_ids('[H][O][#6]~[#6][O][H]', molecule)
-        for atom_ids in ids:
+        for atom_ids in get_atom_ids("[*][N]([H])[H]", molecule):
             atoms = tuple(molecule.get_atoms(atom_ids))
-            yield Diol(
-                hydrogen1=atoms[0],
-                oxygen1=atoms[1],
-                atom1=atoms[2],
-                atom2=atoms[3],
-                oxygen2=atoms[4],
-                hydrogen2=atoms[5],
+            yield PrimaryAmino(
+                nitrogen=atoms[1],
+                hydrogen1=atoms[2],
+                hydrogen2=atoms[3],
+                atom=atoms[0],
                 bonders=tuple(atoms[i] for i in self._bonders),
                 deleters=tuple(atoms[i] for i in self._deleters),
                 placers=tuple(atoms[i] for i in self._placers),
             )
```

### Comparing `stk-2022.6.17.0/src/stk/molecular/functional_groups/factories/fluoro_factory.py` & `stk-2023.7.5.0/src/stk/_internal/functional_group_factories/fluoro_factory.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,16 +1,19 @@
 """
 Fluoro Factory
 ==============
 
 """
 
-from ..functional_groups import Fluoro
-from .functional_group_factory import FunctionalGroupFactory
-from .utilities import _get_atom_ids
+
+from stk._internal.functional_group_factories.functional_group_factory import (
+    FunctionalGroupFactory,
+)
+from stk._internal.functional_group_factories.utilities import get_atom_ids
+from stk._internal.functional_groups.fluoro import Fluoro
 
 
 class FluoroFactory(FunctionalGroupFactory):
     """
     Creates :class:`.Fluoro` instances.
 
     Creates functional groups from substructures, which match the
@@ -47,15 +50,15 @@
     See Also
     --------
     :class:`.GenericFunctionalGroup`
         Defines *bonders* and  *deleters*.
 
     """
 
-    def __init__(self, bonders=(0, ), deleters=(1, ), placers=None):
+    def __init__(self, bonders=(0,), deleters=(1,), placers=None):
         """
         Initialize a :class:`.FluoroFactory` instance.
 
         Parameters
         ----------
         bonders : :class:`tuple` of :class:`int`
             The indices of atoms in the functional group string, which
@@ -72,15 +75,15 @@
         """
 
         self._bonders = bonders
         self._deleters = deleters
         self._placers = bonders if placers is None else placers
 
     def get_functional_groups(self, molecule):
-        for atom_ids in _get_atom_ids('[*][F]', molecule):
+        for atom_ids in get_atom_ids("[*][F]", molecule):
             atoms = tuple(molecule.get_atoms(atom_ids))
             yield Fluoro(
                 fluorine=atoms[1],
                 atom=atoms[0],
                 bonders=tuple(atoms[i] for i in self._bonders),
                 deleters=tuple(atoms[i] for i in self._deleters),
                 placers=tuple(atoms[i] for i in self._placers),
```

### Comparing `stk-2022.6.17.0/src/stk/molecular/functional_groups/factories/primary_amino_factory.py` & `stk-2023.7.5.0/src/stk/_internal/functional_group_factories/secondary_amino_factory.py`

 * *Files 12% similar despite different names*

```diff
@@ -1,142 +1,138 @@
 """
-Primary Amino Factory
-=====================
+Secondary Amino Factory
+=======================
 
 """
 
-from ..functional_groups import PrimaryAmino
-from .functional_group_factory import FunctionalGroupFactory
-from .utilities import _get_atom_ids
 
+from stk._internal.functional_group_factories.functional_group_factory import (
+    FunctionalGroupFactory,
+)
+from stk._internal.functional_group_factories.utilities import get_atom_ids
+from stk._internal.functional_groups.secondary_amino import SecondaryAmino
 
-class PrimaryAminoFactory(FunctionalGroupFactory):
+
+class SecondaryAminoFactory(FunctionalGroupFactory):
     """
-    Creates :class:`.PrimaryAmino` instances.
+    Creates :class:`.SecondaryAmino` instances.
 
     Creates functional groups from substructures, which match the
-    ``[*][N]([H])[H]`` functional group string.
+    ``[H][N]([#6])[#6]`` functional group string.
 
     Examples
     --------
     *Creating Functional Groups with the Factory*
 
     You want to create a building block which has
-    :class:`.PrimaryAmino` functional groups. You want the nitrogen
-    atom to be the *bonder* atom, and the hydrogen atoms to be the
-    *deleter* atoms.
+    :class:`.SecondaryAmino` functional groups. You want the nitrogen
+    atom in those functional groups to be the *bonder* atom, and the
+    hydrogen atom to be the *deleter* atom.
 
     .. testcode:: creating-functional-groups-with-the-factory
 
         import stk
 
         building_block = stk.BuildingBlock(
-            smiles='NCCCCN',
-            functional_groups=(stk.PrimaryAminoFactory(), ),
+            smiles='N(CCCC)CCCC',
+            functional_groups=(stk.SecondaryAminoFactory(), ),
         )
 
     .. testcode:: creating-functional-groups-with-the-factory
         :hide:
 
         assert all(
-            isinstance(functional_group, stk.PrimaryAmino)
+            isinstance(functional_group, stk.SecondaryAmino)
             for functional_group
             in building_block.get_functional_groups()
         )
-        assert building_block.get_num_functional_groups() == 2
+        assert building_block.get_num_functional_groups() == 1
 
     *Changing the Bonder and Deleter Atoms*
 
     You want to create a building block which has
-    :class:`.PrimaryAmino` functional groups. You want the non-hydrogen
-    atom bonded to nitrogen to be the *bonder* atom and the
-    nitrogen and hydrogen atoms to be *deleter* atoms.
+    :class:`.SecondaryAmino` functional groups. You want the nitrogen
+    atom to be the *bonder* atom and one of the carbon atoms to be the
+    *deleter* atom.
 
     .. testcode:: changing-the-bonder-and-deleter-atoms
 
         import stk
 
-        primary_amino_factory = stk.PrimaryAminoFactory(
-            # The index of the atom attached to the nitrogen is 0 in
-            # the functional group string (see docstring).
-            bonders=(0, ),
-            # The indices of the nitrogen and hydrogen atoms in the
-            # functional group string (see docstring) are 1, 2 and 3.
-            deleters=(1, 2, 3),
+        secondary_amino_factory = stk.SecondaryAminoFactory(
+            # The index of the nitrogen atom in the functional
+            # group string (see docstring) is 1.
+            bonders=(1, ),
+            # The index of one of the carbon atoms in the functional
+            # group string (see docstring) is 2.
+            deleters=(2, ),
         )
         building_block = stk.BuildingBlock(
-            smiles='NCCCCN',
-            functional_groups=(primary_amino_factory, ),
+            smiles='N(CCCC)CCCC',
+            functional_groups=(secondary_amino_factory, ),
         )
 
     .. testcode:: changing-the-bonder-and-deleter-atoms
         :hide:
 
-        fg1, fg2 = building_block.get_functional_groups()
+        fg1, = building_block.get_functional_groups()
         assert fg1.get_num_bonders() == 1
-        assert sum(1 for _ in fg1.get_deleters()) == 3
-        assert fg2.get_num_bonders() == 1
-        assert sum(1 for _ in fg2.get_deleters()) == 3
+        assert sum(1 for _ in fg1.get_deleters()) == 1
 
         assert all(
-            isinstance(atom, stk.C)
+            isinstance(atom, stk.N)
             for functional_group
             in building_block.get_functional_groups()
             for atom
             in functional_group.get_bonders()
         )
         assert all(
-            isinstance(atom, (stk.H, stk.N))
+            isinstance(atom, stk.C)
             for functional_group
             in building_block.get_functional_groups()
             for atom
             in functional_group.get_deleters()
         )
 
     See Also
     --------
     :class:`.GenericFunctionalGroup`
         Defines *bonders* and  *deleters*.
 
     """
 
-    def __init__(self, bonders=(1, ), deleters=(2, 3), placers=None):
+    def __init__(self, bonders=(1,), deleters=(0,), placers=None):
         """
-        Initialize a :class:`.PrimaryAminoFactory` instance.
+        Initialize a :class:`.SecondaryAminoFactory` instance.
 
         Parameters
         ----------
         bonders : :class:`tuple` of :class:`int`
             The indices of atoms in the functional group string, which
-            are *bonder* atoms.
+            are bonder atoms.
 
         deleters : :class:`tuple` of :class:`int`
             The indices of atoms in the functional group string, which
-            are *deleter* atoms.
+            are deleter atoms.
 
         placers : :class:`tuple` of :class:`int`, optional
             The indices of atoms in the functional group string, which
             are *placer* atoms. If ``None``, `bonders` will be used.
 
         """
 
-        """
-        Initialize an :class:`.AmineFactory`.
-
-        """
-
         self._bonders = bonders
         self._deleters = deleters
         self._placers = bonders if placers is None else placers
 
     def get_functional_groups(self, molecule):
-        for atom_ids in _get_atom_ids('[*][N]([H])[H]', molecule):
+        for atom_ids in get_atom_ids("[H][N]([#6])[#6]", molecule):
             atoms = tuple(molecule.get_atoms(atom_ids))
-            yield PrimaryAmino(
+            yield SecondaryAmino(
                 nitrogen=atoms[1],
-                hydrogen1=atoms[2],
-                hydrogen2=atoms[3],
-                atom=atoms[0],
+                hydrogen=atoms[0],
+                atom1=atoms[2],
+                atom2=atoms[3],
                 bonders=tuple(atoms[i] for i in self._bonders),
                 deleters=tuple(atoms[i] for i in self._deleters),
                 placers=tuple(atoms[i] for i in self._placers),
             )
```

### Comparing `stk-2022.6.17.0/src/stk/molecular/functional_groups/factories/secondary_amino_factory.py` & `stk-2023.7.5.0/src/stk/_internal/functional_group_factories/alcohol_factory.py`

 * *Files 11% similar despite different names*

```diff
@@ -1,135 +1,140 @@
 """
-Secondary Amino Factory
-=======================
+Alcohol Factory
+===============
 
 """
 
-from ..functional_groups import SecondaryAmino
-from .functional_group_factory import FunctionalGroupFactory
-from .utilities import _get_atom_ids
+from stk._internal.functional_group_factories.functional_group_factory import (
+    FunctionalGroupFactory,
+)
+from stk._internal.functional_group_factories.utilities import get_atom_ids
+from stk._internal.functional_groups.alcohol import Alcohol
 
 
-class SecondaryAminoFactory(FunctionalGroupFactory):
+class AlcoholFactory(FunctionalGroupFactory):
     """
-    Creates :class:`.SecondaryAmino` instances.
+    Creates :class:`.Alcohol` instances.
 
     Creates functional groups from substructures, which match the
-    ``[H][N]([#6])[#6]`` functional group string.
+    ``[*][O][H]`` functional group string.
 
     Examples
     --------
     *Creating Functional Groups with the Factory*
 
-    You want to create a building block which has
-    :class:`.SecondaryAmino` functional groups. You want the nitrogen
-    atom in those functional groups to be the *bonder* atom, and the
-    hydrogen atom to be the *deleter* atom.
+    You want to create a building block which has :class:`.Alcohol`
+    functional groups. You want the oxygen atom in those functional
+    groups to be the bonder atom, and the hydrogen atom to be the
+    deleter atom.
 
     .. testcode:: creating-functional-groups-with-the-factory
 
         import stk
 
         building_block = stk.BuildingBlock(
-            smiles='N(CCCC)CCCC',
-            functional_groups=(stk.SecondaryAminoFactory(), ),
+            smiles='OCCCO',
+            functional_groups=(stk.AlcoholFactory(), ),
         )
 
     .. testcode:: creating-functional-groups-with-the-factory
         :hide:
 
         assert all(
-            isinstance(functional_group, stk.SecondaryAmino)
+            isinstance(functional_group, stk.Alcohol)
             for functional_group
             in building_block.get_functional_groups()
         )
-        assert building_block.get_num_functional_groups() == 1
+        assert building_block.get_num_functional_groups() == 2
 
     *Changing the Bonder and Deleter Atoms*
 
-    You want to create a building block which has
-    :class:`.SecondaryAmino` functional groups. You want the nitrogen
-    atom to be the *bonder* atom and one of the carbon atoms to be the
-    *deleter* atom.
+    You want to create a building block which has :class:`.Alcohol`
+    functional groups. You want the OH group to be
+    treated as a leaving group. This means the non-hydrogen atom bonded
+    to oxygen is the *bonder* atom and both the oxygen and hydrogen
+    atoms are *deleter* atoms.
 
     .. testcode:: changing-the-bonder-and-deleter-atoms
 
         import stk
 
-        secondary_amino_factory = stk.SecondaryAminoFactory(
-            # The index of the nitrogen atom in the functional
-            # group string (see docstring) is 1.
-            bonders=(1, ),
-            # The index of one of the carbon atoms in the functional
-            # group string (see docstring) is 2.
-            deleters=(2, ),
+        alcohol_factory = stk.AlcoholFactory(
+            # The index of the non-hydrogen atom connected to oxygen
+            # is 0 in the functional group string (see docstring).
+            bonders=(0, ),
+            # The indices of the oxygen and hydrogen atoms in the
+            # functional group string (see docstring) are
+            # 1 and 2, respectively.
+            deleters=(1, 2),
         )
         building_block = stk.BuildingBlock(
-            smiles='N(CCCC)CCCC',
-            functional_groups=(secondary_amino_factory, ),
+            smiles='OCCCO',
+            functional_groups=(alcohol_factory, ),
         )
 
     .. testcode:: changing-the-bonder-and-deleter-atoms
         :hide:
 
-        fg1, = building_block.get_functional_groups()
+        fg1, fg2 = building_block.get_functional_groups()
         assert fg1.get_num_bonders() == 1
-        assert sum(1 for _ in fg1.get_deleters()) == 1
+        assert sum(1 for _ in fg1.get_deleters()) == 2
+        assert fg2.get_num_bonders() == 1
+        assert sum(1 for _ in fg2.get_deleters()) == 2
 
         assert all(
-            isinstance(atom, stk.N)
+            isinstance(atom, stk.C)
             for functional_group
             in building_block.get_functional_groups()
             for atom
             in functional_group.get_bonders()
         )
         assert all(
-            isinstance(atom, stk.C)
+            isinstance(atom, (stk.O, stk.H))
             for functional_group
             in building_block.get_functional_groups()
             for atom
             in functional_group.get_deleters()
         )
 
     See Also
     --------
     :class:`.GenericFunctionalGroup`
         Defines *bonders* and  *deleters*.
 
     """
 
-    def __init__(self, bonders=(1, ), deleters=(0, ), placers=None):
+    def __init__(self, bonders=(1,), deleters=(2,), placers=None):
         """
-        Initialize a :class:`.SecondaryAminoFactory` instance.
+        Initialize an :class:`.AlcoholFactory` instance.
 
         Parameters
         ----------
         bonders : :class:`tuple` of :class:`int`
             The indices of atoms in the functional group string, which
-            are bonder atoms.
+            are *bonder* atoms.
 
         deleters : :class:`tuple` of :class:`int`
             The indices of atoms in the functional group string, which
-            are deleter atoms.
+            are *deleter* atoms.
 
         placers : :class:`tuple` of :class:`int`, optional
             The indices of atoms in the functional group string, which
             are *placer* atoms. If ``None``, `bonders` will be used.
 
         """
 
         self._bonders = bonders
         self._deleters = deleters
         self._placers = bonders if placers is None else placers
 
     def get_functional_groups(self, molecule):
-        for atom_ids in _get_atom_ids('[H][N]([#6])[#6]', molecule):
+        for atom_ids in get_atom_ids("[*][O][H]", molecule):
             atoms = tuple(molecule.get_atoms(atom_ids))
-            yield SecondaryAmino(
-                nitrogen=atoms[1],
-                hydrogen=atoms[0],
-                atom1=atoms[2],
-                atom2=atoms[3],
+            yield Alcohol(
+                oxygen=atoms[1],
+                hydrogen=atoms[2],
+                atom=atoms[0],
                 bonders=tuple(atoms[i] for i in self._bonders),
                 deleters=tuple(atoms[i] for i in self._deleters),
                 placers=tuple(atoms[i] for i in self._placers),
             )
```

### Comparing `stk-2022.6.17.0/src/stk/molecular/functional_groups/factories/smarts_functional_group_factory.py` & `stk-2023.7.5.0/src/stk/_internal/functional_group_factories/bromo_factory.py`

 * *Files 14% similar despite different names*

```diff
@@ -1,107 +1,89 @@
 """
-SMARTS Functional Group Factory
-===============================
+Bromo Factory
+=============
 
 """
 
-from ..functional_groups import GenericFunctionalGroup
-from .functional_group_factory import FunctionalGroupFactory
-from .utilities import _get_atom_ids
 
+from stk._internal.functional_group_factories.functional_group_factory import (
+    FunctionalGroupFactory,
+)
+from stk._internal.functional_group_factories.utilities import get_atom_ids
+from stk._internal.functional_groups.bromo import Bromo
 
-class SmartsFunctionalGroupFactory(FunctionalGroupFactory):
+
+class BromoFactory(FunctionalGroupFactory):
     """
-    Creates :class:`.GenericFunctionalGroup` instances.
+    Creates :class:`.Bromo` instances.
+
+    Creates functional groups from substructures, which match the
+    ``[*][Br]`` functional group string.
 
     Examples
     --------
-    *Using SMARTS to Define Functional Groups*
+    *Creating Functional Groups with the Factory*
 
-    You want to create a building block which has
-    :class:`.GenericFunctionalGroup` functional groups based on the
-    SMARTS string: ``[Br][C]``.
-    You want the ``C`` atom to be the *bonder* atom, and the
-    ``Br`` atom to be the *deleter* atom.
+    You want to create a building block which has :class:`.Bromo`
+    functional groups. You want the atom bonded to the bromine to be
+    the *bonder* atom, and the bromine atom to be the *deleter* atom.
 
-    .. testcode:: using-smarts-to-define-functional-groups
+    .. testcode:: creating-functional-groups-with-the-factory
 
         import stk
 
         building_block = stk.BuildingBlock(
             smiles='BrCCCBr',
-            functional_groups=(
-                stk.SmartsFunctionalGroupFactory(
-                    smarts='[Br][C]',
-                    bonders=(1, ),
-                    deleters=(0, ),
-                ),
-            ),
+            functional_groups=(stk.BromoFactory(), ),
         )
 
-    .. testcode:: using-smarts-to-define-functional-groups
+    .. testcode:: creating-functional-groups-with-the-factory
         :hide:
 
-        fg1, fg2 = building_block.get_functional_groups()
-        assert fg1.get_num_bonders() == 1
-        assert sum(1 for _ in fg1.get_deleters()) == 1
-        assert fg2.get_num_bonders() == 1
-        assert sum(1 for _ in fg2.get_deleters()) == 1
-
-        assert all(
-            isinstance(atom, stk.C)
-            for functional_group
-            in building_block.get_functional_groups()
-            for atom
-            in functional_group.get_bonders()
-        )
         assert all(
-            isinstance(atom, stk.Br)
+            isinstance(functional_group, stk.Bromo)
             for functional_group
             in building_block.get_functional_groups()
-            for atom
-            in functional_group.get_deleters()
         )
+        assert building_block.get_num_functional_groups() == 2
 
     See Also
     --------
     :class:`.GenericFunctionalGroup`
         Defines *bonders* and  *deleters*.
 
     """
 
-    def __init__(self, smarts, bonders, deleters, placers=None):
+    def __init__(self, bonders=(0,), deleters=(1,), placers=None):
         """
-        Initialize a :class:`.SmartsFunctionalGroupFactory` instance.
+        Initialize a :class:`.BromoFactory` instance.
 
         Parameters
         ----------
-        smarts : :class:`str`
-            The SMARTS defining the functional group.
-
         bonders : :class:`tuple` of :class:`int`
-            The indices of atoms in `smarts`, which are *bonder* atoms.
+            The indices of atoms in the functional group string, which
+            are *bonder* atoms.
 
         deleters : :class:`tuple` of :class:`int`
-            The indices of atoms in `smarts`, which are *deleter*
-            atoms.
+            The indices of atoms in the functional group string, which
+            are *deleter* atoms.
 
         placers : :class:`tuple` of :class:`int`, optional
-            The indices of atoms in `smarts`, which are *placer* atoms.
-            If ``None``, the *bonder* atoms will be used.
+            The indices of atoms in the functional group string, which
+            are *placer* atoms. If ``None``, `bonders` will be used.
 
         """
 
-        self._smarts = smarts
         self._bonders = bonders
         self._deleters = deleters
         self._placers = bonders if placers is None else placers
 
     def get_functional_groups(self, molecule):
-        for atom_ids in _get_atom_ids(self._smarts, molecule):
+        for atom_ids in get_atom_ids("[*][Br]", molecule):
             atoms = tuple(molecule.get_atoms(atom_ids))
-            yield GenericFunctionalGroup(
-                atoms=atoms,
+            yield Bromo(
+                bromine=atoms[1],
+                atom=atoms[0],
                 bonders=tuple(atoms[i] for i in self._bonders),
                 deleters=tuple(atoms[i] for i in self._deleters),
                 placers=tuple(atoms[i] for i in self._placers),
             )
```

### Comparing `stk-2022.6.17.0/src/stk/molecular/functional_groups/factories/terminal_alkene_factory.py` & `stk-2023.7.5.0/src/stk/_internal/functional_group_factories/terminal_alkene_factory.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,16 +1,19 @@
 """
 Terminal Alkene Factory
 =======================
 
 """
 
-from ..functional_groups import Alkene
-from .functional_group_factory import FunctionalGroupFactory
-from .utilities import _get_atom_ids
+
+from stk._internal.functional_group_factories.functional_group_factory import (
+    FunctionalGroupFactory,
+)
+from stk._internal.functional_group_factories.utilities import get_atom_ids
+from stk._internal.functional_groups.alkene import Alkene
 
 
 class TerminalAlkeneFactory(FunctionalGroupFactory):
     # This docstring is a literal string, to silence a flake8 warning
     # about CH\ :sub:`2`. It's taking the backslash out of context.
     r"""
     Creates :class:`.Alkene` instances.
@@ -91,15 +94,15 @@
     :class:`.GenericFunctionalGroup`
         Defines *bonders* and  *deleters*.
 
     """
 
     def __init__(
         self,
-        bonders=(1, ),
+        bonders=(1,),
         deleters=(3, 4, 5),
         placers=None,
     ):
         """
         Initialize a :class:`.TerminalAlkeneFactory` instance.
 
         Parameters
@@ -119,15 +122,15 @@
         """
 
         self._bonders = bonders
         self._deleters = deleters
         self._placers = bonders if placers is None else placers
 
     def get_functional_groups(self, molecule):
-        ids = _get_atom_ids('[*][C]([*])=[C]([H])[H]', molecule)
+        ids = get_atom_ids("[*][C]([*])=[C]([H])[H]", molecule)
         for atom_ids in ids:
             atoms = tuple(molecule.get_atoms(atom_ids))
             yield Alkene(
                 carbon1=atoms[1],
                 atom1=atoms[0],
                 atom2=atoms[2],
                 carbon2=atoms[3],
```

### Comparing `stk-2022.6.17.0/src/stk/molecular/functional_groups/factories/terminal_alkyne_factory.py` & `stk-2023.7.5.0/src/stk/_internal/functional_group_factories/thioacid_factory.py`

 * *Files 9% similar despite different names*

```diff
@@ -1,128 +1,136 @@
 """
-Terminal Alkyne Factory
-=======================
+Thioacid Factory
+================
 
 """
-from ..functional_groups import Alkyne
-from .functional_group_factory import FunctionalGroupFactory
-from .utilities import _get_atom_ids
 
 
-class TerminalAlkyneFactory(FunctionalGroupFactory):
+from stk._internal.functional_group_factories.functional_group_factory import (
+    FunctionalGroupFactory,
+)
+from stk._internal.functional_group_factories.utilities import get_atom_ids
+from stk._internal.functional_groups.thioacid import Thioacid
+
+
+class ThioacidFactory(FunctionalGroupFactory):
     """
-    Creates :class:`.Alkyne` instances.
+    Creates :class:`.Thioacid` instances.
 
     Creates functional groups from substructures, which match the
-    ``[*][C]#[C][H]`` functional group string.
+    ``[*][C](=[O])[S][H]`` functional group string.
 
     Examples
     --------
     *Creating Functional Groups with the Factory*
 
-    You want to create a building block which has
-    :class:`.Alkyne` functional groups, but only if they are terminal.
-    You want the non-terminal carbon atom in those functional
-    groups to be the *bonder* atom, and the terminal CH
-    group to be the *deleter* atoms.
+    You want to create a building block which has :class:`.Thioacid`
+    functional groups. You want the carbon atom in those functional
+    groups to be the *bonder* atom, and SH group to be the *deleter*
+    atoms.
 
     .. testcode:: creating-functional-groups-with-the-factory
 
         import stk
 
         building_block = stk.BuildingBlock(
-            smiles='C#CCCCCC#C',
-            functional_groups=(stk.TerminalAlkyneFactory(), ),
+            smiles='SC(=O)CC(=O)S',
+            functional_groups=(stk.ThioacidFactory(), ),
         )
 
     .. testcode:: creating-functional-groups-with-the-factory
         :hide:
 
         assert all(
-            isinstance(functional_group, stk.Alkyne)
+            isinstance(functional_group, stk.Thioacid)
             for functional_group
             in building_block.get_functional_groups()
         )
         assert building_block.get_num_functional_groups() == 2
 
     *Changing the Bonder and Deleter Atoms*
 
-    You want to create a building block which has
-    :class:`.Alkyne` functional groups. You want the carbon
-    atoms to be the *bonder* atoms and you don't want any *deleter*
-    atoms.
+    You want to create a building block which has :class:`.Thioacid`
+    functional groups. You want the carbon atom to be the *bonder*
+    atom and the oxygen atom to be the *deleter* atom.
 
     .. testcode:: changing-the-bonder-and-deleter-atoms
 
         import stk
 
-        terminal_alkyne_factory = stk.TerminalAlkyneFactory(
-            # The indices of the carbon atoms in the functional
-            # group string (see docstring) are 1 and 2.
-            bonders=(1, 2),
-            deleters=(),
+        thioacid_factory = stk.ThioacidFactory(
+            # The index of the carbon atom in the functional
+            # group string (see docstring) is 1.
+            bonders=(1, ),
+            # The index of the oxygen atom in the functional
+            # group string (see docstring) is 2.
+            deleters=(2, ),
         )
         building_block = stk.BuildingBlock(
-            smiles='C#CCCCCC#C',
-            functional_groups=(terminal_alkyne_factory, ),
+            smiles='SC(=O)CC(=O)S',
+            functional_groups=(thioacid_factory, ),
         )
 
     .. testcode:: changing-the-bonder-and-deleter-atoms
         :hide:
 
         fg1, fg2 = building_block.get_functional_groups()
-        assert fg1.get_num_bonders() == 2
-        assert sum(1 for _ in fg1.get_deleters()) == 0
-        assert fg2.get_num_bonders() == 2
-        assert sum(1 for _ in fg2.get_deleters()) == 0
+        assert fg1.get_num_bonders() == 1
+        assert sum(1 for _ in fg1.get_deleters()) == 1
+        assert fg2.get_num_bonders() == 1
+        assert sum(1 for _ in fg2.get_deleters()) == 1
 
         assert all(
             isinstance(atom, stk.C)
             for functional_group
             in building_block.get_functional_groups()
             for atom
             in functional_group.get_bonders()
         )
+        assert all(
+            isinstance(atom, stk.O)
+            for functional_group
+            in building_block.get_functional_groups()
+            for atom
+            in functional_group.get_deleters()
+        )
 
     See Also
     --------
     :class:`.GenericFunctionalGroup`
         Defines *bonders* and  *deleters*.
 
     """
 
-    def __init__(self, bonders=(1, ), deleters=(2, 3), placers=None):
+    def __init__(self, bonders=(1,), deleters=(3, 4), placers=None):
         """
-        Initialize a :class:`.TerminalAlkyneFactory` instance.
+        Initialize a :class:`.ThioacidFactory` instance.
 
         Parameters
         ----------
         bonders : :class:`tuple` of :class:`int`
             The indices of atoms in the functional group string, which
             are *bonder* atoms.
 
         deleters : :class:`tuple` of :class:`int`
             The indices of atoms in the functional group string, which
             are *deleter* atoms.
 
-        placers : :class:`tuple` of :class:`int`, optional
-            The indices of atoms in the functional group string, which
-            are *placer* atoms. If ``None``, `bonders` will be used.
-
         """
 
         self._bonders = bonders
         self._deleters = deleters
         self._placers = bonders if placers is None else placers
 
     def get_functional_groups(self, molecule):
-        for atom_ids in _get_atom_ids('[*][C]#[C][H]', molecule):
+        for atom_ids in get_atom_ids("[*][C](=[O])[S][H]", molecule):
             atoms = tuple(molecule.get_atoms(atom_ids))
-            yield Alkyne(
-                atom1=atoms[0],
-                carbon1=atoms[1],
-                carbon2=atoms[2],
-                atom2=atoms[3],
+            yield Thioacid(
+                carbon=atoms[1],
+                oxygen=atoms[2],
+                sulfur=atoms[3],
+                hydrogen=atoms[4],
+                atom=atoms[0],
                 bonders=tuple(atoms[i] for i in self._bonders),
                 deleters=tuple(atoms[i] for i in self._deleters),
                 placers=tuple(atoms[i] for i in self._placers),
             )
```

### Comparing `stk-2022.6.17.0/src/stk/molecular/functional_groups/factories/thioacid_factory.py` & `stk-2023.7.5.0/src/stk/_internal/functional_group_factories/thiol_factory.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,133 +1,140 @@
 """
-Thioacid Factory
-================
+Thiol Factory
+=============
 
 """
 
-from ..functional_groups import Thioacid
-from .functional_group_factory import FunctionalGroupFactory
-from .utilities import _get_atom_ids
 
+from stk._internal.functional_group_factories.functional_group_factory import (
+    FunctionalGroupFactory,
+)
+from stk._internal.functional_group_factories.utilities import get_atom_ids
+from stk._internal.functional_groups.thiol import Thiol
 
-class ThioacidFactory(FunctionalGroupFactory):
+
+class ThiolFactory(FunctionalGroupFactory):
     """
-    Creates :class:`.Thioacid` instances.
+    Creates :class:`.Thiol` instances.
 
     Creates functional groups from substructures, which match the
-    ``[*][C](=[O])[S][H]`` functional group string.
+    ``[*][S][H]`` functional group string.
 
     Examples
     --------
     *Creating Functional Groups with the Factory*
 
-    You want to create a building block which has :class:`.Thioacid`
-    functional groups. You want the carbon atom in those functional
-    groups to be the *bonder* atom, and SH group to be the *deleter*
-    atoms.
+    You want to create a building block which has :class:`.Thiol`
+    functional groups. You want the sulfur atom in those functional
+    groups to be the *bonder* atom, and the hydrogen atom to be the
+    *deleter* atom.
 
     .. testcode:: creating-functional-groups-with-the-factory
 
         import stk
 
         building_block = stk.BuildingBlock(
-            smiles='SC(=O)CC(=O)S',
-            functional_groups=(stk.ThioacidFactory(), ),
+            smiles='SCCCCS',
+            functional_groups=(stk.ThiolFactory(), ),
         )
 
     .. testcode:: creating-functional-groups-with-the-factory
         :hide:
 
         assert all(
-            isinstance(functional_group, stk.Thioacid)
+            isinstance(functional_group, stk.Thiol)
             for functional_group
             in building_block.get_functional_groups()
         )
         assert building_block.get_num_functional_groups() == 2
 
     *Changing the Bonder and Deleter Atoms*
 
-    You want to create a building block which has :class:`.Thioacid`
-    functional groups. You want the carbon atom to be the *bonder*
-    atom and the oxygen atom to be the *deleter* atom.
+    You want to create a building block which has :class:`.Thiol`
+    functional groups. You want the non-hydrogen atom bonded to the
+    sulfur to be the *bonder* atom and the SH group to be *deleter*
+    atoms.
 
     .. testcode:: changing-the-bonder-and-deleter-atoms
 
         import stk
 
-        thioacid_factory = stk.ThioacidFactory(
-            # The index of the carbon atom in the functional
-            # group string (see docstring) is 1.
-            bonders=(1, ),
-            # The index of the oxygen atom in the functional
-            # group string (see docstring) is 2.
-            deleters=(2, ),
+        thiol_factory = stk.ThiolFactory(
+            # The index of the atom bonded to sulfur is 0 in the
+            # functional group string (see docstring).
+            bonders=(0, ),
+            # The indices of the sulfur and hydrogen atoms in the
+            # functional group string (see docstring) is 1 and 2,
+            # respectively.
+            deleters=(1, 2),
         )
         building_block = stk.BuildingBlock(
-            smiles='SC(=O)CC(=O)S',
-            functional_groups=(thioacid_factory, ),
+            smiles='SCCCCS',
+            functional_groups=(thiol_factory, ),
         )
 
     .. testcode:: changing-the-bonder-and-deleter-atoms
         :hide:
 
         fg1, fg2 = building_block.get_functional_groups()
         assert fg1.get_num_bonders() == 1
-        assert sum(1 for _ in fg1.get_deleters()) == 1
+        assert sum(1 for _ in fg1.get_deleters()) == 2
         assert fg2.get_num_bonders() == 1
-        assert sum(1 for _ in fg2.get_deleters()) == 1
+        assert sum(1 for _ in fg2.get_deleters()) == 2
 
         assert all(
             isinstance(atom, stk.C)
             for functional_group
             in building_block.get_functional_groups()
             for atom
             in functional_group.get_bonders()
         )
         assert all(
-            isinstance(atom, stk.O)
+            isinstance(atom, (stk.S, stk.H))
             for functional_group
             in building_block.get_functional_groups()
             for atom
             in functional_group.get_deleters()
         )
 
     See Also
     --------
     :class:`.GenericFunctionalGroup`
         Defines *bonders* and  *deleters*.
 
     """
 
-    def __init__(self, bonders=(1, ), deleters=(3, 4), placers=None):
+    def __init__(self, bonders=(1,), deleters=(2,), placers=None):
         """
-        Initialize a :class:`.ThioacidFactory` instance.
+        Initialize a :class:`.ThiolFactory` instance.
 
         Parameters
         ----------
         bonders : :class:`tuple` of :class:`int`
             The indices of atoms in the functional group string, which
             are *bonder* atoms.
 
         deleters : :class:`tuple` of :class:`int`
             The indices of atoms in the functional group string, which
             are *deleter* atoms.
 
+        placers : :class:`tuple` of :class:`int`, optional
+            The indices of atoms in the functional group string, which
+            are *placer* atoms. If ``None``, `bonders` will be used.
+
         """
 
         self._bonders = bonders
         self._deleters = deleters
         self._placers = bonders if placers is None else placers
 
     def get_functional_groups(self, molecule):
-        for atom_ids in _get_atom_ids('[*][C](=[O])[S][H]', molecule):
+        for atom_ids in get_atom_ids("[*][S][H]", molecule):
             atoms = tuple(molecule.get_atoms(atom_ids))
-            yield Thioacid(
-                carbon=atoms[1],
-                oxygen=atoms[2],
-                sulfur=atoms[3],
-                hydrogen=atoms[4],
+            yield Thiol(
+                sulfur=atoms[1],
+                hydrogen=atoms[2],
                 atom=atoms[0],
                 bonders=tuple(atoms[i] for i in self._bonders),
                 deleters=tuple(atoms[i] for i in self._deleters),
                 placers=tuple(atoms[i] for i in self._placers),
             )
```

### Comparing `stk-2022.6.17.0/src/stk/molecular/functional_groups/factories/thiol_factory.py` & `stk-2023.7.5.0/src/stk/_internal/functional_group_factories/terminal_alkyne_factory.py`

 * *Files 12% similar despite different names*

```diff
@@ -1,112 +1,105 @@
 """
-Thiol Factory
-=============
+Terminal Alkyne Factory
+=======================
 
 """
 
-from ..functional_groups import Thiol
-from .functional_group_factory import FunctionalGroupFactory
-from .utilities import _get_atom_ids
+from stk._internal.functional_group_factories.functional_group_factory import (
+    FunctionalGroupFactory,
+)
+from stk._internal.functional_group_factories.utilities import get_atom_ids
+from stk._internal.functional_groups.alkyne import Alkyne
 
 
-class ThiolFactory(FunctionalGroupFactory):
+class TerminalAlkyneFactory(FunctionalGroupFactory):
     """
-    Creates :class:`.Thiol` instances.
+    Creates :class:`.Alkyne` instances.
 
     Creates functional groups from substructures, which match the
-    ``[*][S][H]`` functional group string.
+    ``[*][C]#[C][H]`` functional group string.
 
     Examples
     --------
     *Creating Functional Groups with the Factory*
 
-    You want to create a building block which has :class:`.Thiol`
-    functional groups. You want the sulfur atom in those functional
-    groups to be the *bonder* atom, and the hydrogen atom to be the
-    *deleter* atom.
+    You want to create a building block which has
+    :class:`.Alkyne` functional groups, but only if they are terminal.
+    You want the non-terminal carbon atom in those functional
+    groups to be the *bonder* atom, and the terminal CH
+    group to be the *deleter* atoms.
 
     .. testcode:: creating-functional-groups-with-the-factory
 
         import stk
 
         building_block = stk.BuildingBlock(
-            smiles='SCCCCS',
-            functional_groups=(stk.ThiolFactory(), ),
+            smiles='C#CCCCCC#C',
+            functional_groups=(stk.TerminalAlkyneFactory(), ),
         )
 
     .. testcode:: creating-functional-groups-with-the-factory
         :hide:
 
         assert all(
-            isinstance(functional_group, stk.Thiol)
+            isinstance(functional_group, stk.Alkyne)
             for functional_group
             in building_block.get_functional_groups()
         )
         assert building_block.get_num_functional_groups() == 2
 
     *Changing the Bonder and Deleter Atoms*
 
-    You want to create a building block which has :class:`.Thiol`
-    functional groups. You want the non-hydrogen atom bonded to the
-    sulfur to be the *bonder* atom and the SH group to be *deleter*
+    You want to create a building block which has
+    :class:`.Alkyne` functional groups. You want the carbon
+    atoms to be the *bonder* atoms and you don't want any *deleter*
     atoms.
 
     .. testcode:: changing-the-bonder-and-deleter-atoms
 
         import stk
 
-        thiol_factory = stk.ThiolFactory(
-            # The index of the atom bonded to sulfur is 0 in the
-            # functional group string (see docstring).
-            bonders=(0, ),
-            # The indices of the sulfur and hydrogen atoms in the
-            # functional group string (see docstring) is 1 and 2,
-            # respectively.
-            deleters=(1, 2),
+        terminal_alkyne_factory = stk.TerminalAlkyneFactory(
+            # The indices of the carbon atoms in the functional
+            # group string (see docstring) are 1 and 2.
+            bonders=(1, 2),
+            deleters=(),
         )
         building_block = stk.BuildingBlock(
-            smiles='SCCCCS',
-            functional_groups=(thiol_factory, ),
+            smiles='C#CCCCCC#C',
+            functional_groups=(terminal_alkyne_factory, ),
         )
 
     .. testcode:: changing-the-bonder-and-deleter-atoms
         :hide:
 
         fg1, fg2 = building_block.get_functional_groups()
-        assert fg1.get_num_bonders() == 1
-        assert sum(1 for _ in fg1.get_deleters()) == 2
-        assert fg2.get_num_bonders() == 1
-        assert sum(1 for _ in fg2.get_deleters()) == 2
+        assert fg1.get_num_bonders() == 2
+        assert sum(1 for _ in fg1.get_deleters()) == 0
+        assert fg2.get_num_bonders() == 2
+        assert sum(1 for _ in fg2.get_deleters()) == 0
 
         assert all(
             isinstance(atom, stk.C)
             for functional_group
             in building_block.get_functional_groups()
             for atom
             in functional_group.get_bonders()
         )
-        assert all(
-            isinstance(atom, (stk.S, stk.H))
-            for functional_group
-            in building_block.get_functional_groups()
-            for atom
-            in functional_group.get_deleters()
-        )
 
     See Also
     --------
     :class:`.GenericFunctionalGroup`
         Defines *bonders* and  *deleters*.
 
     """
 
-    def __init__(self, bonders=(1, ), deleters=(2, ), placers=None):
+    def __init__(self, bonders=(1,), deleters=(2, 3), placers=None):
         """
-        Initialize a :class:`.ThiolFactory` instance.
+        Initialize a :class:`.TerminalAlkyneFactory` instance.
 
         Parameters
         ----------
         bonders : :class:`tuple` of :class:`int`
             The indices of atoms in the functional group string, which
             are *bonder* atoms.
 
@@ -121,17 +114,18 @@
         """
 
         self._bonders = bonders
         self._deleters = deleters
         self._placers = bonders if placers is None else placers
 
     def get_functional_groups(self, molecule):
-        for atom_ids in _get_atom_ids('[*][S][H]', molecule):
+        for atom_ids in get_atom_ids("[*][C]#[C][H]", molecule):
             atoms = tuple(molecule.get_atoms(atom_ids))
-            yield Thiol(
-                sulfur=atoms[1],
-                hydrogen=atoms[2],
-                atom=atoms[0],
+            yield Alkyne(
+                atom1=atoms[0],
+                carbon1=atoms[1],
+                carbon2=atoms[2],
+                atom2=atoms[3],
                 bonders=tuple(atoms[i] for i in self._bonders),
                 deleters=tuple(atoms[i] for i in self._deleters),
                 placers=tuple(atoms[i] for i in self._placers),
             )
```

### Comparing `stk-2022.6.17.0/src/stk/molecular/functional_groups/factories/utilities.py` & `stk-2023.7.5.0/src/stk/_internal/functional_group_factories/utilities.py`

 * *Files 1% similar despite different names*

```diff
@@ -3,15 +3,15 @@
 ==================================
 
 """
 
 import rdkit.Chem.AllChem as rdkit
 
 
-def _get_atom_ids(query, molecule):
+def get_atom_ids(query, molecule):
     """
     Yield the ids of atoms in `molecule` which match `query`.
 
     Multiple substructures in `molecule` can match `query` and
     therefore each set is yielded as a group.
 
     Parameters
```

### Comparing `stk-2022.6.17.0/src/stk/molecular/functional_groups/functional_groups/alcohol.py` & `stk-2023.7.5.0/src/stk/_internal/functional_groups/alcohol.py`

 * *Files 3% similar despite different names*

```diff
@@ -4,15 +4,17 @@
 
 """
 
 from __future__ import annotations
 
 import typing
 
-from ...atoms import Atom, H, O
+from stk._internal.atom import Atom
+from stk._internal.elements import H, O
+
 from .generic_functional_group import GenericFunctionalGroup
 
 
 class Alcohol(GenericFunctionalGroup):
     """
     Represents an alcohol functional group.
 
@@ -107,15 +109,14 @@
         clone._atom = self._atom
         return clone
 
     def _with_ids(
         self,
         id_map: dict[int, int],
     ) -> Alcohol:
-
         super()._with_ids(id_map)
 
         if (oxygen_id := self._oxygen.get_id()) in id_map:
             self._oxygen = self._oxygen.with_id(id_map[oxygen_id])
 
         if (hydrogen_id := self._hydrogen.get_id()) in id_map:
             self._hydrogen = self._hydrogen.with_id(
@@ -127,16 +128,15 @@
 
         return self
 
     def with_ids(
         self,
         id_map: dict[int, int],
     ) -> Alcohol:
-
         return self.clone()._with_ids(id_map)
 
     def __repr__(self) -> str:
         return (
-            f'{self.__class__.__name__}('
-            f'{self._oxygen}, {self._hydrogen}, {self._atom}, '
-            f'bonders={self._bonders}, deleters={self._deleters})'
+            f"{self.__class__.__name__}("
+            f"{self._oxygen}, {self._hydrogen}, {self._atom}, "
+            f"bonders={self._bonders}, deleters={self._deleters})"
         )
```

### Comparing `stk-2022.6.17.0/src/stk/molecular/functional_groups/functional_groups/aldehyde.py` & `stk-2023.7.5.0/src/stk/_internal/functional_groups/aldehyde.py`

 * *Files 3% similar despite different names*

```diff
@@ -4,15 +4,17 @@
 
 """
 
 from __future__ import annotations
 
 import typing
 
-from ...atoms import Atom, C, H, O
+from stk._internal.atom import Atom
+from stk._internal.elements import C, H, O
+
 from .generic_functional_group import GenericFunctionalGroup
 
 
 class Aldehyde(GenericFunctionalGroup):
     """
     Represents an aldehyde functional group.
 
@@ -119,15 +121,14 @@
 
         return self._atom
 
     def _with_ids(
         self,
         id_map: dict[int, int],
     ) -> Aldehyde:
-
         super()._with_ids(id_map)
 
         if (carbon_id := self._carbon.get_id()) in id_map:
             self._carbon = self._carbon.with_id(id_map[carbon_id])
 
         if (oxygen_id := self._oxygen.get_id()) in id_map:
             self._oxygen = self._oxygen.with_id(id_map[oxygen_id])
@@ -142,25 +143,24 @@
 
         return self
 
     def with_ids(
         self,
         id_map: dict[int, int],
     ) -> Aldehyde:
-
         return self.clone()._with_ids(id_map)
 
     def clone(self) -> Aldehyde:
         clone = super()._clone()
         clone._carbon = self._carbon
         clone._oxygen = self._oxygen
         clone._hydrogen = self._hydrogen
         clone._atom = self._atom
         return clone
 
     def __repr__(self) -> str:
         return (
-            f'{self.__class__.__name__}('
-            f'{self._carbon}, {self._oxygen}, {self._hydrogen}, '
-            f'{self._atom}, bonders={self._bonders}, '
-            f'deleters={self._deleters})'
+            f"{self.__class__.__name__}("
+            f"{self._carbon}, {self._oxygen}, {self._hydrogen}, "
+            f"{self._atom}, bonders={self._bonders}, "
+            f"deleters={self._deleters})"
         )
```

### Comparing `stk-2022.6.17.0/src/stk/molecular/functional_groups/functional_groups/alkene.py` & `stk-2023.7.5.0/src/stk/_internal/functional_groups/alkene.py`

 * *Files 3% similar despite different names*

```diff
@@ -4,15 +4,17 @@
 
 """
 
 from __future__ import annotations
 
 import typing
 
-from ...atoms import Atom, C
+from stk._internal.atom import Atom
+from stk._internal.elements import C
+
 from .generic_functional_group import GenericFunctionalGroup
 
 
 class Alkene(GenericFunctionalGroup):
     """
     Represents an alkene functional group.
 
@@ -189,12 +191,12 @@
         return self
 
     def with_ids(self, id_map: dict[int, int]) -> Alkene:
         return self.clone()._with_ids(id_map)
 
     def __repr__(self) -> str:
         return (
-            f'{self.__class__.__name__}('
-            f'{self._carbon1}, {self._atom1}, {self._atom2}, '
-            f'{self._carbon2}, {self._atom3}, {self._atom4}, '
-            f'bonders={self._bonders}, deleters={self._deleters})'
+            f"{self.__class__.__name__}("
+            f"{self._carbon1}, {self._atom1}, {self._atom2}, "
+            f"{self._carbon2}, {self._atom3}, {self._atom4}, "
+            f"bonders={self._bonders}, deleters={self._deleters})"
         )
```

### Comparing `stk-2022.6.17.0/src/stk/molecular/functional_groups/functional_groups/alkyne.py` & `stk-2023.7.5.0/src/stk/_internal/functional_groups/alkyne.py`

 * *Files 5% similar despite different names*

```diff
@@ -4,15 +4,17 @@
 
 """
 
 from __future__ import annotations
 
 import typing
 
-from ...atoms import Atom, C
+from stk._internal.atom import Atom
+from stk._internal.elements import C
+
 from .generic_functional_group import GenericFunctionalGroup
 
 
 class Alkyne(GenericFunctionalGroup):
     """
     Represents an alkyne functional group.
 
@@ -128,15 +130,14 @@
         clone._atom2 = self._atom2
         return clone
 
     def _with_ids(
         self,
         id_map: dict[int, int],
     ) -> Alkyne:
-
         super()._with_ids(id_map)
         if (carbon1_id := self._carbon1.get_id()) in id_map:
             self._carbon1 = self._carbon1.with_id(id_map[carbon1_id])
 
         if (atom1_id := self._atom1.get_id()) in id_map:
             self._atom1 = self._atom1.with_id(id_map[atom1_id])
 
@@ -148,17 +149,16 @@
 
         return self
 
     def with_ids(
         self,
         id_map: dict[int, int],
     ) -> Alkyne:
-
         return self.clone()._with_ids(id_map)
 
     def __repr__(self) -> str:
         return (
-            f'{self.__class__.__name__}('
-            f'{self._carbon1}, {self._atom1}, {self._carbon2}, '
-            f'{self._atom2}, '
-            f'bonders={self._bonders}, deleters={self._deleters})'
+            f"{self.__class__.__name__}("
+            f"{self._carbon1}, {self._atom1}, {self._carbon2}, "
+            f"{self._atom2}, "
+            f"bonders={self._bonders}, deleters={self._deleters})"
         )
```

### Comparing `stk-2022.6.17.0/src/stk/molecular/functional_groups/functional_groups/amide.py` & `stk-2023.7.5.0/src/stk/_internal/functional_groups/boronic_acid.py`

 * *Files 13% similar despite different names*

```diff
@@ -1,58 +1,60 @@
 """
-Amide
-=====
+Boronic Acid
+============
 
 """
 
 from __future__ import annotations
 
 import typing
 
-from ...atoms import Atom, C, H, N, O
+from stk._internal.atom import Atom
+from stk._internal.elements import B, H, O
+
 from .generic_functional_group import GenericFunctionalGroup
 
 
-class Amide(GenericFunctionalGroup):
+class BoronicAcid(GenericFunctionalGroup):
     """
-    Represents an amide functional group.
+    Represents a boronic acid functional group.
 
     The structure of the functional group is given by the pseudo-SMILES
-    ``[atom][carbon](=[oxygen])[nitrogen]([hydrogen1])[hydrogen2]``.
+    ``[atom][boron]([oxygen1][hydrogen1])[oxygen2][hydrogen2]``.
 
     """
 
     def __init__(
         self,
-        carbon: C,
-        oxygen: O,  # noqa: Not an ambiguous name.
-        nitrogen: N,
+        boron: B,
+        oxygen1: O,  # noqa: Not an ambiguous name.
         hydrogen1: H,
+        oxygen2: O,  # noqa: Not an ambiguous name.
         hydrogen2: H,
         atom: Atom,
         bonders: tuple[Atom, ...],
         deleters: tuple[Atom, ...],
         placers: typing.Optional[tuple[Atom, ...]] = None,
     ) -> None:
         """
-        Initialize a :class:`.Amide` instance.
+        Initialize a :class:`.BoronicAcid` instance.
 
         Parameters:
 
-            carbon:
-                The ``[carbon]`` atom.
-
-            oxygen:
-                The ``[oxygen]`` atom.
+            boron:
+                The ``[boron]`` atom.
 
-            nitrogen:
-                The ``[nitrogen]`` atom.
+            oxygen1:
+                The ``[oxygen1]`` atom.
 
             hydrogen1:
-                The ``[hydrogen1]`` atom.
+                The ``[hydrogen]`` atom.
+
+            oxygen2:
+                The ``[oyxgen2]`` atom.
 
             hydrogen2:
                 The ``[hydrogen2]`` atom.
 
             atom:
                 The ``[atom]`` atom.
 
@@ -64,75 +66,75 @@
 
             placers:
                 The placer atoms. If ``None`` the `bonders` will be
                 used.
 
         """
 
-        self._carbon = carbon
-        self._oxygen = oxygen
-        self._nitrogen = nitrogen
+        self._boron = boron
+        self._oxygen1 = oxygen1
         self._hydrogen1 = hydrogen1
+        self._oxygen2 = oxygen2
         self._hydrogen2 = hydrogen2
         self._atom = atom
-        atoms = (carbon, oxygen, nitrogen, hydrogen1, hydrogen2, atom)
+        atoms = (boron, oxygen1, hydrogen1, oxygen2, hydrogen2, atom)
         super().__init__(
             atoms=atoms,
             bonders=bonders,
             deleters=deleters,
             placers=bonders if placers is None else placers,
         )
 
-    def get_carbon(self) -> C:
+    def get_boron(self) -> B:
         """
-        Get the ``[carbon]`` atom.
+        Get the ``[boron]`` atom.
 
         Returns:
 
-            The ``[carbon]`` atom.
+            The ``[boron]`` atom.
 
         """
 
-        return self._carbon
+        return self._boron
 
-    def get_oxygen(self) -> O:  # noqa: Not an ambiguous name.
+    def get_oxygen1(self) -> O:  # noqa: Not an ambiguous name.
         """
-        Get the ``[oxygen]`` atom.
+        Get the ``[oxygen1]`` atom.
 
         Returns:
 
-            The ``[oxygen]`` atom.
+            The ``[oxygen1]`` atom.
 
         """
 
-        return self._oxygen
+        return self._oxygen1
 
-    def get_nitrogen(self) -> N:
+    def get_hydrogen1(self) -> H:
         """
-        Get the ``[nitrogen]`` atom.
+        Get the ``[hydrogen1]`` atom.
 
         Returns:
 
-            The ``[nitrogen]`` atom.
+            The ``[hydrogen1]`` atom.
 
         """
 
-        return self._nitrogen
+        return self._hydrogen1
 
-    def get_hydrogen1(self) -> H:
+    def get_oxygen2(self) -> O:  # noqa: Not an ambiguous name.
         """
-        Get the ``[hydrogen1]`` atom.
+        Get the ``[oxygen2]`` atom.
 
         Returns:
 
-            The ``[hydrogen1]`` atom.
+            The ``[oxygen2]`` atom.
 
         """
 
-        return self._hydrogen1
+        return self._oxygen2
 
     def get_hydrogen2(self) -> H:
         """
         Get the ``[hydrogen2]`` atom.
 
         Returns:
 
@@ -150,63 +152,60 @@
 
             The ``[atom]`` atom.
 
         """
 
         return self._atom
 
-    def clone(self) -> Amide:
+    def clone(self) -> BoronicAcid:
         clone = super()._clone()
-        clone._carbon = self._carbon
-        clone._oxygen = self._oxygen
-        clone._nitrogen = self._nitrogen
+        clone._boron = self._boron
+        clone._oxygen1 = self._oxygen1
         clone._hydrogen1 = self._hydrogen1
+        clone._oxygen2 = self._oxygen2
         clone._hydrogen2 = self._hydrogen2
         clone._atom = self._atom
         return clone
 
     def _with_ids(
         self,
         id_map: dict[int, int],
-    ) -> Amide:
-
+    ) -> BoronicAcid:
         super()._with_ids(id_map)
 
-        if (carbon_id := self._carbon.get_id()) in id_map:
-            self._carbon = self._carbon.with_id(id_map[carbon_id])
+        if (boron_id := self._boron.get_id()) in id_map:
+            self._boron = self._boron.with_id(id_map[boron_id])
 
-        if (oxygen_id := self._oxygen.get_id()) in id_map:
-            self._oxygen = self._oxygen.with_id(id_map[oxygen_id])
-
-        if (nitrogen_id := self._nitrogen.get_id()) in id_map:
-            self._nitrogen = self._nitrogen.with_id(
-                id=id_map[nitrogen_id],
-            )
+        if (oxygen1_id := self._oxygen1.get_id()) in id_map:
+            self._oxygen1 = self._oxygen1.with_id(id_map[oxygen1_id])
 
         if (hydrogen1_id := self._hydrogen1.get_id()) in id_map:
             self._hydrogen1 = self._hydrogen1.with_id(
                 id=id_map[hydrogen1_id],
             )
 
+        if (oxygen2_id := self._oxygen2.get_id()) in id_map:
+            self._oxygen2 = self._oxygen2.with_id(id_map[oxygen2_id])
+
         if (hydrogen2_id := self._hydrogen2.get_id()) in id_map:
             self._hydrogen2 = self._hydrogen2.with_id(
                 id=id_map[hydrogen2_id],
             )
 
         if (atom_id := self._atom.get_id()) in id_map:
             self._atom = self._atom.with_id(id_map[atom_id])
 
         return self
 
     def with_ids(
         self,
         id_map: dict[int, int],
-    ) -> Amide:
+    ) -> BoronicAcid:
         return self.clone()._with_ids(id_map)
 
     def __repr__(self) -> str:
         return (
-            f'{self.__class__.__name__}('
-            f'{self._carbon}, {self._oxygen}, {self._nitrogen}, '
-            f'{self._hydrogen1}, {self._hydrogen2}, {self._atom}, '
-            f'bonders={self._bonders}, deleters={self._deleters})'
+            f"{self.__class__.__name__}("
+            f"{self._boron}, {self._oxygen1}, {self._hydrogen1}, "
+            f"{self._oxygen2}, {self._hydrogen2}, {self._atom}, "
+            f"bonders={self._bonders}, deleters={self._deleters})"
         )
```

### Comparing `stk-2022.6.17.0/src/stk/molecular/functional_groups/functional_groups/boronic_acid.py` & `stk-2023.7.5.0/src/stk/_internal/functional_groups/amide.py`

 * *Files 20% similar despite different names*

```diff
@@ -1,58 +1,60 @@
 """
-Boronic Acid
-============
+Amide
+=====
 
 """
 
 from __future__ import annotations
 
 import typing
 
-from ...atoms import Atom, B, H, O
+from stk._internal.atom import Atom
+from stk._internal.elements import C, H, N, O
+
 from .generic_functional_group import GenericFunctionalGroup
 
 
-class BoronicAcid(GenericFunctionalGroup):
+class Amide(GenericFunctionalGroup):
     """
-    Represents a boronic acid functional group.
+    Represents an amide functional group.
 
     The structure of the functional group is given by the pseudo-SMILES
-    ``[atom][boron]([oxygen1][hydrogen1])[oxygen2][hydrogen2]``.
+    ``[atom][carbon](=[oxygen])[nitrogen]([hydrogen1])[hydrogen2]``.
 
     """
 
     def __init__(
         self,
-        boron: B,
-        oxygen1: O,  # noqa: Not an ambiguous name.
+        carbon: C,
+        oxygen: O,  # noqa: Not an ambiguous name.
+        nitrogen: N,
         hydrogen1: H,
-        oxygen2: O,  # noqa: Not an ambiguous name.
         hydrogen2: H,
         atom: Atom,
         bonders: tuple[Atom, ...],
         deleters: tuple[Atom, ...],
         placers: typing.Optional[tuple[Atom, ...]] = None,
     ) -> None:
         """
-        Initialize a :class:`.BoronicAcid` instance.
+        Initialize a :class:`.Amide` instance.
 
         Parameters:
 
-            boron:
-                The ``[boron]`` atom.
+            carbon:
+                The ``[carbon]`` atom.
 
-            oxygen1:
-                The ``[oxygen1]`` atom.
+            oxygen:
+                The ``[oxygen]`` atom.
 
-            hydrogen1:
-                The ``[hydrogen]`` atom.
+            nitrogen:
+                The ``[nitrogen]`` atom.
 
-            oxygen2:
-                The ``[oyxgen2]`` atom.
+            hydrogen1:
+                The ``[hydrogen1]`` atom.
 
             hydrogen2:
                 The ``[hydrogen2]`` atom.
 
             atom:
                 The ``[atom]`` atom.
 
@@ -64,75 +66,75 @@
 
             placers:
                 The placer atoms. If ``None`` the `bonders` will be
                 used.
 
         """
 
-        self._boron = boron
-        self._oxygen1 = oxygen1
+        self._carbon = carbon
+        self._oxygen = oxygen
+        self._nitrogen = nitrogen
         self._hydrogen1 = hydrogen1
-        self._oxygen2 = oxygen2
         self._hydrogen2 = hydrogen2
         self._atom = atom
-        atoms = (boron, oxygen1, hydrogen1, oxygen2, hydrogen2, atom)
+        atoms = (carbon, oxygen, nitrogen, hydrogen1, hydrogen2, atom)
         super().__init__(
             atoms=atoms,
             bonders=bonders,
             deleters=deleters,
             placers=bonders if placers is None else placers,
         )
 
-    def get_boron(self) -> B:
+    def get_carbon(self) -> C:
         """
-        Get the ``[boron]`` atom.
+        Get the ``[carbon]`` atom.
 
         Returns:
 
-            The ``[boron]`` atom.
+            The ``[carbon]`` atom.
 
         """
 
-        return self._boron
+        return self._carbon
 
-    def get_oxygen1(self) -> O:  # noqa: Not an ambiguous name.
+    def get_oxygen(self) -> O:  # noqa: Not an ambiguous name.
         """
-        Get the ``[oxygen1]`` atom.
+        Get the ``[oxygen]`` atom.
 
         Returns:
 
-            The ``[oxygen1]`` atom.
+            The ``[oxygen]`` atom.
 
         """
 
-        return self._oxygen1
+        return self._oxygen
 
-    def get_hydrogen1(self) -> H:
+    def get_nitrogen(self) -> N:
         """
-        Get the ``[hydrogen1]`` atom.
+        Get the ``[nitrogen]`` atom.
 
         Returns:
 
-            The ``[hydrogen1]`` atom.
+            The ``[nitrogen]`` atom.
 
         """
 
-        return self._hydrogen1
+        return self._nitrogen
 
-    def get_oxygen2(self) -> O:  # noqa: Not an ambiguous name.
+    def get_hydrogen1(self) -> H:
         """
-        Get the ``[oxygen2]`` atom.
+        Get the ``[hydrogen1]`` atom.
 
         Returns:
 
-            The ``[oxygen2]`` atom.
+            The ``[hydrogen1]`` atom.
 
         """
 
-        return self._oxygen2
+        return self._hydrogen1
 
     def get_hydrogen2(self) -> H:
         """
         Get the ``[hydrogen2]`` atom.
 
         Returns:
 
@@ -150,61 +152,62 @@
 
             The ``[atom]`` atom.
 
         """
 
         return self._atom
 
-    def clone(self) -> BoronicAcid:
+    def clone(self) -> Amide:
         clone = super()._clone()
-        clone._boron = self._boron
-        clone._oxygen1 = self._oxygen1
+        clone._carbon = self._carbon
+        clone._oxygen = self._oxygen
+        clone._nitrogen = self._nitrogen
         clone._hydrogen1 = self._hydrogen1
-        clone._oxygen2 = self._oxygen2
         clone._hydrogen2 = self._hydrogen2
         clone._atom = self._atom
         return clone
 
     def _with_ids(
         self,
         id_map: dict[int, int],
-    ) -> BoronicAcid:
-
+    ) -> Amide:
         super()._with_ids(id_map)
 
-        if (boron_id := self._boron.get_id()) in id_map:
-            self._boron = self._boron.with_id(id_map[boron_id])
+        if (carbon_id := self._carbon.get_id()) in id_map:
+            self._carbon = self._carbon.with_id(id_map[carbon_id])
 
-        if (oxygen1_id := self._oxygen1.get_id()) in id_map:
-            self._oxygen1 = self._oxygen1.with_id(id_map[oxygen1_id])
+        if (oxygen_id := self._oxygen.get_id()) in id_map:
+            self._oxygen = self._oxygen.with_id(id_map[oxygen_id])
+
+        if (nitrogen_id := self._nitrogen.get_id()) in id_map:
+            self._nitrogen = self._nitrogen.with_id(
+                id=id_map[nitrogen_id],
+            )
 
         if (hydrogen1_id := self._hydrogen1.get_id()) in id_map:
             self._hydrogen1 = self._hydrogen1.with_id(
                 id=id_map[hydrogen1_id],
             )
 
-        if (oxygen2_id := self._oxygen2.get_id()) in id_map:
-            self._oxygen2 = self._oxygen2.with_id(id_map[oxygen2_id])
-
         if (hydrogen2_id := self._hydrogen2.get_id()) in id_map:
             self._hydrogen2 = self._hydrogen2.with_id(
                 id=id_map[hydrogen2_id],
             )
 
         if (atom_id := self._atom.get_id()) in id_map:
             self._atom = self._atom.with_id(id_map[atom_id])
 
         return self
 
     def with_ids(
         self,
         id_map: dict[int, int],
-    ) -> BoronicAcid:
+    ) -> Amide:
         return self.clone()._with_ids(id_map)
 
     def __repr__(self) -> str:
         return (
-            f'{self.__class__.__name__}('
-            f'{self._boron}, {self._oxygen1}, {self._hydrogen1}, '
-            f'{self._oxygen2}, {self._hydrogen2}, {self._atom}, '
-            f'bonders={self._bonders}, deleters={self._deleters})'
+            f"{self.__class__.__name__}("
+            f"{self._carbon}, {self._oxygen}, {self._nitrogen}, "
+            f"{self._hydrogen1}, {self._hydrogen2}, {self._atom}, "
+            f"bonders={self._bonders}, deleters={self._deleters})"
         )
```

### Comparing `stk-2022.6.17.0/src/stk/molecular/functional_groups/functional_groups/bromo.py` & `stk-2023.7.5.0/src/stk/_internal/functional_groups/bromo.py`

 * *Files 4% similar despite different names*

```diff
@@ -4,15 +4,17 @@
 
 """
 
 from __future__ import annotations
 
 import typing
 
-from ...atoms import Atom, Br
+from stk._internal.atom import Atom
+from stk._internal.elements import Br
+
 from .generic_functional_group import GenericFunctionalGroup
 
 
 class Bromo(GenericFunctionalGroup):
     """
     Represents a bromo functional group.
 
@@ -91,15 +93,14 @@
         clone._atom = self._atom
         return clone
 
     def _with_ids(
         self,
         id_map: dict[int, int],
     ) -> Bromo:
-
         super()._with_ids(id_map)
         if (bromine_id := self._bromine.get_id()) in id_map:
             self._bromine = self._bromine.with_id(id_map[bromine_id])
 
         if (atom_id := self._atom.get_id()) in id_map:
             self._atom = self._atom.with_id(id_map[atom_id])
 
@@ -109,11 +110,11 @@
         self,
         id_map: dict[int, int],
     ) -> Bromo:
         return self.clone()._with_ids(id_map)
 
     def __repr__(self) -> str:
         return (
-            f'{self.__class__.__name__}('
-            f'{self._bromine}, {self._atom}, '
-            f'bonders={self._bonders}, deleters={self._deleters})'
+            f"{self.__class__.__name__}("
+            f"{self._bromine}, {self._atom}, "
+            f"bonders={self._bonders}, deleters={self._deleters})"
         )
```

### Comparing `stk-2022.6.17.0/src/stk/molecular/functional_groups/functional_groups/carboxylic_acid.py` & `stk-2023.7.5.0/src/stk/_internal/functional_groups/carboxylic_acid.py`

 * *Files 1% similar despite different names*

```diff
@@ -166,12 +166,12 @@
             self._atom.get_id(),
             self._atom,
         )
         return clone
 
     def __repr__(self):
         return (
-            f'{self.__class__.__name__}('
-            f'{self._carbon}, {self._oxygen1}, {self._oxygen2}, '
-            f'{self._hydrogen}, {self._atom}, '
-            f'bonders={self._bonders}, deleters={self._deleters})'
+            f"{self.__class__.__name__}("
+            f"{self._carbon}, {self._oxygen1}, {self._oxygen2}, "
+            f"{self._hydrogen}, {self._atom}, "
+            f"bonders={self._bonders}, deleters={self._deleters})"
         )
```

### Comparing `stk-2022.6.17.0/src/stk/molecular/functional_groups/functional_groups/dibromo.py` & `stk-2023.7.5.0/src/stk/_internal/functional_groups/dibromo.py`

 * *Files 2% similar despite different names*

```diff
@@ -143,12 +143,12 @@
             self._bromine2.get_id(),
             self._bromine2,
         )
         return clone
 
     def __repr__(self):
         return (
-            f'{self.__class__.__name__}('
-            f'{self._bromine1}, {self._atom1}, {self._bromine2}, '
-            f'{self._atom2}, '
-            f'bonders={self._bonders}, deleters={self._deleters})'
+            f"{self.__class__.__name__}("
+            f"{self._bromine1}, {self._atom1}, {self._bromine2}, "
+            f"{self._atom2}, "
+            f"bonders={self._bonders}, deleters={self._deleters})"
         )
```

### Comparing `stk-2022.6.17.0/src/stk/molecular/functional_groups/functional_groups/difluoro.py` & `stk-2023.7.5.0/src/stk/_internal/functional_groups/difluoro.py`

 * *Files 1% similar despite different names*

```diff
@@ -137,12 +137,12 @@
         clone._fluorine1 = self._fluorine1
         clone._atom2 = self._atom2
         clone._fluorine2 = self._fluorine2
         return clone
 
     def __repr__(self):
         return (
-            f'{self.__class__.__name__}('
-            f'{self._fluorine1}, {self._atom1}, {self._fluorine2}, '
-            f'{self._atom2}, '
-            f'bonders={self._bonders}, deleters={self._deleters})'
+            f"{self.__class__.__name__}("
+            f"{self._fluorine1}, {self._atom1}, {self._fluorine2}, "
+            f"{self._atom2}, "
+            f"bonders={self._bonders}, deleters={self._deleters})"
         )
```

### Comparing `stk-2022.6.17.0/src/stk/molecular/functional_groups/functional_groups/diol.py` & `stk-2023.7.5.0/src/stk/_internal/functional_groups/diol.py`

 * *Files 1% similar despite different names*

```diff
@@ -190,12 +190,12 @@
             self._hydrogen2.get_id(),
             self._hydrogen2,
         )
         return clone
 
     def __repr__(self):
         return (
-            f'{self.__class__.__name__}('
-            f'{self._atom1}, {self._oxygen1}, {self._hydrogen1}, '
-            f'{self._atom2}, {self._oxygen2}, {self._hydrogen2}, '
-            f'bonders={self._bonders}, deleters={self._deleters})'
+            f"{self.__class__.__name__}("
+            f"{self._atom1}, {self._oxygen1}, {self._hydrogen1}, "
+            f"{self._atom2}, {self._oxygen2}, {self._hydrogen2}, "
+            f"bonders={self._bonders}, deleters={self._deleters})"
         )
```

### Comparing `stk-2022.6.17.0/src/stk/molecular/functional_groups/functional_groups/fluoro.py` & `stk-2023.7.5.0/src/stk/_internal/functional_groups/fluoro.py`

 * *Files 1% similar despite different names*

```diff
@@ -97,11 +97,11 @@
             self._atom.get_id(),
             self._atom,
         )
         return clone
 
     def __repr__(self):
         return (
-            f'{self.__class__.__name__}('
-            f'{self._fluorine}, {self._atom}, '
-            f'bonders={self._bonders}, deleters={self._deleters})'
+            f"{self.__class__.__name__}("
+            f"{self._fluorine}, {self._atom}, "
+            f"bonders={self._bonders}, deleters={self._deleters})"
         )
```

### Comparing `stk-2022.6.17.0/src/stk/molecular/functional_groups/functional_groups/generic_functional_group.py` & `stk-2023.7.5.0/src/stk/_internal/functional_groups/generic_functional_group.py`

 * *Files 6% similar despite different names*

```diff
@@ -5,18 +5,18 @@
 """
 
 
 from __future__ import annotations
 
 import typing
 
-from ...atoms import Atom
-from .functional_group import FunctionalGroup
+from stk._internal.atom import Atom
+from stk._internal.functional_groups.functional_group import FunctionalGroup
 
-_T = typing.TypeVar('_T', bound='GenericFunctionalGroup')
+_T = typing.TypeVar("_T", bound="GenericFunctionalGroup")
 
 
 class GenericFunctionalGroup(FunctionalGroup):
     """
     A functional group which defines general atomic classes.
 
     *Bonders* are atoms which should have bonds added by a
@@ -57,16 +57,15 @@
         """
 
         deleter_set = set(atom.get_id() for atom in deleters)
         super().__init__(
             atoms=atoms,
             placers=bonders if placers is None else placers,
             core_atoms=tuple(
-                atom for atom in atoms
-                if atom.get_id() not in deleter_set
+                atom for atom in atoms if atom.get_id() not in deleter_set
             ),
         )
         self._bonders = bonders
         self._deleters = deleters
 
     def _clone(self: _T) -> _T:
         clone = super()._clone()
@@ -77,55 +76,49 @@
     def clone(self) -> GenericFunctionalGroup:
         return self._clone()
 
     def with_atoms(
         self,
         atom_map: dict[int, Atom],
     ) -> GenericFunctionalGroup:
-
         return GenericFunctionalGroup(
-            atoms=tuple(
-                atom_map.get(a.get_id(), a) for a in self._atoms
-            ),
-            bonders=tuple(
-                atom_map.get(a.get_id(), a) for a in self._bonders
-            ),
+            atoms=tuple(atom_map.get(a.get_id(), a) for a in self._atoms),
+            bonders=tuple(atom_map.get(a.get_id(), a) for a in self._bonders),
             deleters=tuple(
                 atom_map.get(a.get_id(), a) for a in self._deleters
             ),
-            placers=tuple(
-                atom_map.get(a.get_id(), a) for a in self._placers
-            ),
+            placers=tuple(atom_map.get(a.get_id(), a) for a in self._placers),
         )
 
     def _with_ids(self: _T, id_map: dict[int, int]) -> _T:
         super()._with_ids(id_map)
         self._bonders = tuple(
             bonder.with_id(
                 id=id_map.get(
                     bonder.get_id(),
                     bonder.get_id(),
                 )
-            ) for bonder in self._bonders
+            )
+            for bonder in self._bonders
         )
         self._deleters = tuple(
             deleter.with_id(
                 id=id_map.get(
                     deleter.get_id(),
                     deleter.get_id(),
                 ),
-            ) for deleter in self._deleters
+            )
+            for deleter in self._deleters
         )
         return self
 
     def with_ids(
         self,
         id_map: dict[int, int],
     ) -> GenericFunctionalGroup:
-
         return self.clone()._with_ids(id_map)
 
     def get_bonders(self) -> typing.Iterator[Atom]:
         """
         Yield bonder atoms in the functional group.
 
         These are atoms which have bonds added during
@@ -183,13 +176,13 @@
 
         """
 
         yield from (a.get_id() for a in self._deleters)
 
     def __repr__(self) -> str:
         return (
-            f'{self.__class__.__name__}('
-            f'atoms={self._atoms}, '
-            f'bonders={self._bonders}, '
-            f'deleters={self._deleters}'
-            ')'
+            f"{self.__class__.__name__}("
+            f"atoms={self._atoms}, "
+            f"bonders={self._bonders}, "
+            f"deleters={self._deleters}"
+            ")"
         )
```

### Comparing `stk-2022.6.17.0/src/stk/molecular/functional_groups/functional_groups/iodo.py` & `stk-2023.7.5.0/src/stk/_internal/functional_groups/iodo.py`

 * *Files 0% similar despite different names*

```diff
@@ -90,11 +90,11 @@
             self._atom.get_id(),
             self._atom,
         )
         return clone
 
     def __repr__(self):
         return (
-            f'{self.__class__.__name__}('
-            f'{self._iodine}, {self._atom}, '
-            f'bonders={self._bonders}, deleters={self._deleters})'
+            f"{self.__class__.__name__}("
+            f"{self._iodine}, {self._atom}, "
+            f"bonders={self._bonders}, deleters={self._deleters})"
         )
```

### Comparing `stk-2022.6.17.0/src/stk/molecular/functional_groups/functional_groups/primary_amino.py` & `stk-2023.7.5.0/src/stk/_internal/functional_groups/primary_amino.py`

 * *Files 1% similar despite different names*

```diff
@@ -115,19 +115,19 @@
 
         """
 
         return self._atom
 
     def __repr__(self):
         return (
-            f'{self.__class__.__name__}('
-            f'{self._nitrogen}, {self._hydrogen1}, {self._hydrogen2}, '
-            f'{self._atom}, bonders={self._bonders}, '
-            f'deleters={self._deleters}'
-            ')'
+            f"{self.__class__.__name__}("
+            f"{self._nitrogen}, {self._hydrogen1}, {self._hydrogen2}, "
+            f"{self._atom}, bonders={self._bonders}, "
+            f"deleters={self._deleters}"
+            ")"
         )
 
     def clone(self):
         clone = super().clone()
         clone._nitrogen = self._nitrogen
         clone._hydrogen1 = self._hydrogen1
         clone._hydrogen2 = self._hydrogen2
```

### Comparing `stk-2022.6.17.0/src/stk/molecular/functional_groups/functional_groups/ring_amine.py` & `stk-2023.7.5.0/src/stk/_internal/functional_groups/ring_amine.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,14 +1,14 @@
 """
 Ring Amine
 ==========
 
 """
 
-from . import FunctionalGroup
+from .functional_group import FunctionalGroup
 
 
 class RingAmine(FunctionalGroup):
     """
     Represents an amine bonded to a ring.
 
     The structure of the functional group is given by the pseudo-SMILES
@@ -69,16 +69,16 @@
             carbon1,
             carbon2,
             hydrogen3,
             carbon3,
         )
         super().__init__(
             atoms=atoms,
-            placers=(nitrogen, ),
-            core_atoms=(nitrogen, ),
+            placers=(nitrogen,),
+            core_atoms=(nitrogen,),
         )
 
     def get_nitrogen(self):
         """
         Get the ``[nitrogen]`` atom.
 
         Returns
@@ -209,12 +209,12 @@
             self._carbon3.get_id(),
             self._carbon3,
         )
         return clone
 
     def __repr__(self):
         return (
-            f'{self.__class__.__name__}('
-            f'{self._nitrogen}, {self._hydrogen1}, {self._hydrogen2}, '
-            f'{self._carbon1}, {self._carbon2}, {self._hydrogen3}, '
-            f'{self._carbon3})'
+            f"{self.__class__.__name__}("
+            f"{self._nitrogen}, {self._hydrogen1}, {self._hydrogen2}, "
+            f"{self._carbon1}, {self._carbon2}, {self._hydrogen3}, "
+            f"{self._carbon3})"
         )
```

### Comparing `stk-2022.6.17.0/src/stk/molecular/functional_groups/functional_groups/secondary_amino.py` & `stk-2023.7.5.0/src/stk/_internal/functional_groups/secondary_amino.py`

 * *Files 2% similar despite different names*

```diff
@@ -143,12 +143,12 @@
             self._atom2.get_id(),
             self._atom2,
         )
         return clone
 
     def __repr__(self):
         return (
-            f'{self.__class__.__name__}('
-            f'{self._nitrogen}, {self._hydrogen}, {self._atom1}, '
-            f'{self._atom2}, '
-            f'bonders={self._bonders}, deleters={self._deleters})'
+            f"{self.__class__.__name__}("
+            f"{self._nitrogen}, {self._hydrogen}, {self._atom1}, "
+            f"{self._atom2}, "
+            f"bonders={self._bonders}, deleters={self._deleters})"
         )
```

### Comparing `stk-2022.6.17.0/src/stk/molecular/functional_groups/functional_groups/single_atom.py` & `stk-2023.7.5.0/src/stk/_internal/functional_groups/single_atom.py`

 * *Files 7% similar despite different names*

```diff
@@ -24,15 +24,15 @@
         ----------
         atom : :class:`.Atom`
             Any :class:`.Atom` will work.
 
         """
 
         self._atom = atom
-        atoms = (atom, )
+        atoms = (atom,)
         super().__init__(atoms, atoms, ())
 
     def get_atom(self):
         """
         Get the atom that defines the functional group.
 
         Returns
@@ -41,24 +41,21 @@
             The atom.
 
         """
 
         return self._atom
 
     def with_atoms(self, atom_map):
-
         clone = super().with_atoms(atom_map)
         clone._atom = atom_map.get(
             self._atom.get_id(),
             self._atom,
         )
         return clone
 
     def clone(self):
         clone = super().clone()
         clone._atom = self._atom
         return clone
 
     def __repr__(self):
-        return (
-            f'{self.__class__.__name__}({self._atom})'
-        )
+        return f"{self.__class__.__name__}({self._atom})"
```

### Comparing `stk-2022.6.17.0/src/stk/molecular/functional_groups/functional_groups/thioacid.py` & `stk-2023.7.5.0/src/stk/_internal/functional_groups/thioacid.py`

 * *Files 11% similar despite different names*

```diff
@@ -166,12 +166,12 @@
             self._atom.get_id(),
             self._atom,
         )
         return clone
 
     def __repr__(self):
         return (
-            f'{self.__class__.__name__}('
-            f'{self._carbon}, {self._oxygen}, {self._sulfur}, '
-            f'{self._hydrogen}, {self._atom}, '
-            f'bonders={self._bonders}, deleters={self._deleters})'
+            f"{self.__class__.__name__}("
+            f"{self._carbon}, {self._oxygen}, {self._sulfur}, "
+            f"{self._hydrogen}, {self._atom}, "
+            f"bonders={self._bonders}, deleters={self._deleters})"
         )
```

### Comparing `stk-2022.6.17.0/src/stk/molecular/functional_groups/functional_groups/thiol.py` & `stk-2023.7.5.0/src/stk/_internal/functional_groups/thiol.py`

 * *Files 5% similar despite different names*

```diff
@@ -121,11 +121,11 @@
             self._atom.get_id(),
             self._atom,
         )
         return clone
 
     def __repr__(self):
         return (
-            f'{self.__class__.__name__}('
-            f'{self._sulfur}, {self._hydrogen}, {self._atom}, '
-            f'bonders={self._bonders}, deleters={self._deleters})'
+            f"{self.__class__.__name__}("
+            f"{self._sulfur}, {self._hydrogen}, {self._atom}, "
+            f"bonders={self._bonders}, deleters={self._deleters})"
         )
```

### Comparing `stk-2022.6.17.0/src/stk/molecular/key_makers/inchi.py` & `stk-2023.7.5.0/src/stk/_internal/key_makers/inchi.py`

 * *Files 6% similar despite different names*

```diff
@@ -2,17 +2,17 @@
 InChI
 =====
 
 """
 
 from __future__ import annotations
 
-from ..molecules import Molecule
-from .molecule import MoleculeKeyMaker
-from .utilities import get_inchi
+from stk._internal.key_makers.molecule import MoleculeKeyMaker
+from stk._internal.key_makers.utilities import get_inchi
+from stk._internal.molecule import Molecule
 
 
 class Inchi(MoleculeKeyMaker):
     """
     Used to get the InChI of molecules.
 
     Examples:
@@ -57,17 +57,17 @@
         Initialize a :class:`.Inchi` instance.
 
         """
 
         pass
 
     def get_key_name(self) -> str:
-        return 'InChI'
+        return "InChI"
 
     def get_key(self, molecule: Molecule) -> str:
         return get_inchi(molecule)
 
     def __str__(self) -> str:
         return repr(self)
 
     def __repr__(self) -> str:
-        return 'Inchi()'
+        return "Inchi()"
```

### Comparing `stk-2022.6.17.0/src/stk/molecular/key_makers/inchi_key.py` & `stk-2023.7.5.0/src/stk/_internal/key_makers/inchi_key.py`

 * *Files 6% similar despite different names*

```diff
@@ -2,17 +2,17 @@
 InChIKey
 ========
 
 """
 
 from __future__ import annotations
 
-from ..molecules import Molecule
-from .molecule import MoleculeKeyMaker
-from .utilities import get_inchi_key
+from stk._internal.key_makers.molecule import MoleculeKeyMaker
+from stk._internal.key_makers.utilities import get_inchi_key
+from stk._internal.molecule import Molecule
 
 
 class InchiKey(MoleculeKeyMaker):
     """
     Used to get the InChIKey of molecules.
 
     Examples:
@@ -51,17 +51,17 @@
         Initialize an :class:`.InchiKey` instance.
 
         """
 
         pass
 
     def get_key_name(self) -> str:
-        return 'InChIKey'
+        return "InChIKey"
 
     def get_key(self, molecule: Molecule) -> str:
         return get_inchi_key(molecule)
 
     def __str__(self) -> str:
         return repr(self)
 
     def __repr__(self) -> str:
-        return 'InchiKey()'
+        return "InchiKey()"
```

### Comparing `stk-2022.6.17.0/src/stk/molecular/key_makers/molecule.py` & `stk-2023.7.5.0/src/stk/_internal/key_makers/molecule.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,25 +1,12 @@
-"""
-Molecule Key Maker
-==================
-
-.. toctree::
-    :maxdepth: 2
-
-    InChI <stk.molecular.key_makers.inchi>
-    InChIKey <stk.molecular.key_makers.inchi_key>
-    SMILES <stk.molecular.key_makers.smiles>
-
-"""
-
 from __future__ import annotations
 
-import typing
+from collections.abc import Callable
 
-from ..molecules import Molecule
+from stk._internal.molecule import Molecule
 
 
 class MoleculeKeyMaker:
     """
     An abstract base class for making :class:`.Molecule` keys.
 
     Keys are used in :mod:`stk` to determine if two molecules are
@@ -72,15 +59,15 @@
             assert json['matrix']['num_atoms'] == 12
 
     """
 
     def __init__(
         self,
         key_name: str,
-        get_key: typing.Callable[[Molecule], object],
+        get_key: Callable[[Molecule], object],
     ) -> None:
         """
         Initialize a :class:`.MoleculeKeyMaker` instance.
 
         Parameters:
 
             key_name:
@@ -126,11 +113,11 @@
         return self._get_key(molecule)
 
     def __str__(self) -> str:
         return repr(self)
 
     def __repr__(self) -> str:
         return (
-            f'{self.__class__.__name__}('
-            f'{self._key_name!r}, {self._get_key!r}'
-            ')'
+            f"{self.__class__.__name__}("
+            f"{self._key_name!r}, {self._get_key!r}"
+            ")"
         )
```

### Comparing `stk-2022.6.17.0/src/stk/molecular/key_makers/smiles.py` & `stk-2023.7.5.0/src/stk/_internal/key_makers/smiles.py`

 * *Files 3% similar despite different names*

```diff
@@ -2,15 +2,16 @@
 SMILES
 ======
 
 """
 
 from __future__ import annotations
 
-from ..molecules import Molecule
+from stk._internal.molecule import Molecule
+
 from .molecule import MoleculeKeyMaker
 from .utilities import get_smiles
 
 
 class Smiles(MoleculeKeyMaker):
     """
     Used to get the SMILES of molecules.
@@ -45,17 +46,17 @@
         Initialize a :class:`.Smiles` instance.
 
         """
 
         pass
 
     def get_key_name(self) -> str:
-        return 'SMILES'
+        return "SMILES"
 
     def get_key(self, molecule: Molecule) -> str:
         return get_smiles(molecule)
 
     def __str__(self) -> str:
         return repr(self)
 
     def __repr__(self) -> str:
-        return 'Smiles()'
+        return "Smiles()"
```

### Comparing `stk-2022.6.17.0/src/stk/molecular/key_makers/utilities.py` & `stk-2023.7.5.0/src/stk/_internal/key_makers/utilities.py`

 * *Files 2% similar despite different names*

```diff
@@ -4,15 +4,15 @@
 
 """
 
 from __future__ import annotations
 
 import rdkit.Chem.AllChem as rdkit
 
-from ..molecules import Molecule
+from stk._internal.molecule import Molecule
 
 
 def get_inchi(
     molecule: Molecule,
 ) -> str:
     """
     Get the InChI of `molecule`.
@@ -32,15 +32,15 @@
             If the InChI of `molecule` cannot be generated.
 
     """
 
     inchi = rdkit.MolToInchi(molecule.to_rdkit_mol())
     if inchi:
         return inchi
-    raise ValueError('The InChI of {molecule} was empty.')
+    raise ValueError("The InChI of {molecule} was empty.")
 
 
 def get_inchi_key(
     molecule: Molecule,
 ) -> str:
     """
     Get the InChIKey of `molecule`.
@@ -59,15 +59,15 @@
         :class:`ValueError`
             If the InChIKey of `molecule` cannot be generated.
 
     """
 
     key = rdkit.MolToInchiKey(molecule.to_rdkit_mol())
     if not key:
-        raise ValueError(f'InChIKey of {molecule} is empty.')
+        raise ValueError(f"InChIKey of {molecule} is empty.")
     return key
 
 
 def get_smiles(molecule: Molecule) -> str:
     """
     Get the RDKit canonical, isomeric SMILES of `molecule`.
```

### Comparing `stk-2022.6.17.0/src/stk/molecular/molecules/building_block.py` & `stk-2023.7.5.0/src/stk/_internal/building_block.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,31 +1,25 @@
-"""
-Building Block
-==============
-
-"""
-
-from __future__ import annotations
-
 import logging
 import os
 import typing
-import warnings
-from collections.abc import Collection
+from collections.abc import Collection, Iterable, Iterator
 from functools import partial
 
 import numpy as np
 import rdkit.Chem.AllChem as rdkit
 import vabene
 
-from ...utilities import OneOrMany, flatten, remake
-from ..atoms import Atom
-from ..bonds import Bond
-from ..functional_groups import FunctionalGroup, FunctionalGroupFactory
-from .molecule import Molecule
+from stk._internal.atom import Atom
+from stk._internal.bond import Bond
+from stk._internal.functional_group_factories.functional_group_factory import (
+    FunctionalGroupFactory,
+)
+from stk._internal.functional_groups.functional_group import FunctionalGroup
+from stk._internal.molecule import Molecule
+from stk._internal.utilities.utilities import flatten, remake
 
 logger = logging.getLogger(__name__)
 
 
 class BuildingBlock(Molecule):
     """
     Represents a building block of a :class:`.ConstructedMolecule`.
@@ -37,71 +31,46 @@
     modified during construction.
 
     """
 
     # Maps file extensions to functions which can be used to
     # create an rdkit molecule from that file type.
     _init_funcs = {
-        '.mol': partial(
-            rdkit.MolFromMolFile,
-            sanitize=False,
-            removeHs=False
-        ),
-
-        '.sdf': partial(
-            rdkit.MolFromMolFile,
-            sanitize=False,
-            removeHs=False
-        ),
-
-        '.pdb': partial(
-            rdkit.MolFromPDBFile,
-            sanitize=False,
-            removeHs=False,
-            proximityBonding=False,
-        ),
+        ".mol": partial(rdkit.MolFromMolFile, sanitize=False, removeHs=False),
+        ".sdf": partial(rdkit.MolFromMolFile, sanitize=False, removeHs=False),
     }
 
     _placer_ids: frozenset[int]
     _core_ids: frozenset[int]
 
     def __init__(
         self,
         smiles: str,
-        functional_groups: typing.Iterable[
-            typing.Union[FunctionalGroup, FunctionalGroupFactory]
+        functional_groups: Iterable[
+            FunctionalGroup | FunctionalGroupFactory
         ] = (),
-        placer_ids: typing.Optional[tuple[int, ...]] = None,
-        position_matrix: typing.Optional[np.ndarray] = None,
+        placer_ids: Iterable[int] | None = None,
+        position_matrix: np.ndarray | None = None,
     ) -> None:
         """
-        Initialize a :class:`.BuildingBlock`.
-
-        Notes:
-
-            The molecule is given 3D coordinates with
-            :func:`rdkit.ETKDGv2`.
-
         Parameters:
 
             smiles:
                 A SMILES string of the molecule.
 
-            functional_groups:
-                An :class:`iterable` of :class:`.FunctionalGroup` or
-                :class:`.FunctionalGroupFactory` or both.
-                :class:`.FunctionalGroup` instances are added to the
+            functional_groups (list[FunctionalGroup | FunctionalGroupFactory]):
+                :class:`.FunctionalGroup` instances added to the
                 building block and :class:`.FunctionalGroupFactory`
-                instances are used to create :class:`.FunctionalGroup`
-                instances the building block should hold.
+                instances used to create :class:`.FunctionalGroup`
+                instances added to the building block.
                 :class:`.FunctionalGroup` instances are used to
                 identify which atoms are modified during
                 :class:`.ConstructedMolecule` construction.
 
-            placer_ids:
+            placer_ids (list[int]):
                 The ids of *placer* atoms. These are the atoms which
                 should be used for calculating the position of the
                 building block. Depending on the values passed to
                 `placer_ids`, and the functional groups in the building
                 block, different *placer* ids will be used by the
                 building block.
 
@@ -133,16 +102,15 @@
         molecule = rdkit.AddHs(rdkit.MolFromSmiles(smiles))
         if position_matrix is None:
             params = rdkit.ETKDGv2()
             random_seed = 4
             params.randomSeed = random_seed
             if rdkit.EmbedMolecule(molecule, params) == -1:
                 raise RuntimeError(
-                    f'Embedding with seed value of {random_seed} '
-                    'failed.'
+                    f"Embedding with seed value of {random_seed} " "failed."
                 )
             rdkit.Kekulize(molecule)
         else:
             # Make sure the position matrix always holds floats.
             position_matrix = np.array(
                 position_matrix,
                 dtype=np.float64,
@@ -158,39 +126,37 @@
             placer_ids=placer_ids,
         )
 
     @classmethod
     def init_from_molecule(
         cls,
         molecule: Molecule,
-        functional_groups: typing.Iterable[
-            typing.Union[FunctionalGroup, FunctionalGroupFactory]
+        functional_groups: Iterable[
+            FunctionalGroup | FunctionalGroupFactory
         ] = (),
-        placer_ids: typing.Optional[tuple[int, ...]] = None,
-    ) -> BuildingBlock:
+        placer_ids: Iterable[int] | None = None,
+    ) -> typing.Self:
         """
         Initialize from a :class:`.Molecule`.
 
         Parameters:
 
             molecule:
                 The molecule to initialize from.
 
-            functional_groups:
-                An :class:`iterable` of :class:`.FunctionalGroup` or
-                :class:`.FunctionalGroupFactory` or both.
-                :class:`.FunctionalGroup` instances are added to the
+            functional_groups (list[FunctionalGroup | FunctionalGroupFactory]):
+                :class:`.FunctionalGroup` instances added to the
                 building block and :class:`.FunctionalGroupFactory`
-                instances are used to create :class:`.FunctionalGroup`
-                instances the building block should hold.
+                instances used to create :class:`.FunctionalGroup`
+                instances added to the building block.
                 :class:`.FunctionalGroup` instances are used to
                 identify which atoms are modified during
                 :class:`.ConstructedMolecule` construction.
 
-            placer_ids:
+            placer_ids (list[int]):
                 The ids of *placer* atoms. These are the atoms which
                 should be used for calculating the position of the
                 building block. Depending on the values passed to
                 `placer_ids`, and the functional groups in the
                 building block, different *placer* ids will be used by
                 the building block.
 
@@ -204,17 +170,16 @@
                    of the building block.
 
                 #. `placer_ids` is ``None`` and `functional_groups` is
                    empty. All atoms of the molecule will be used for
                    *placer* ids.
 
         Returns:
-
-             The building block. It will have the same atoms, bonds and
-             atomic positions as `molecule`.
+            BuildingBlock: The building block. It will have the same
+            atoms, bonds and atomic positions as `molecule`.
 
         """
 
         return cls.init(
             atoms=tuple(molecule.get_atoms()),
             bonds=tuple(molecule.get_bonds()),
             position_matrix=molecule.get_position_matrix(),
@@ -222,45 +187,43 @@
             placer_ids=placer_ids,
         )
 
     @classmethod
     def init_from_vabene_molecule(
         cls,
         molecule: vabene.Molecule,
-        functional_groups: typing.Iterable[
-            typing.Union[FunctionalGroup, FunctionalGroupFactory]
+        functional_groups: Iterable[
+            FunctionalGroup | FunctionalGroupFactory
         ] = (),
-        placer_ids: typing.Optional[tuple[int, ...]] = None,
-        position_matrix: typing.Optional[np.ndarray] = None,
-    ) -> BuildingBlock:
+        placer_ids: Iterable[int] | None = None,
+        position_matrix: np.ndarray | None = None,
+    ) -> typing.Self:
         """
         Initialize from a :mod:`vabene.Molecule`.
 
         Notes:
 
             The molecule is given 3D coordinates with
             :func:`rdkit.ETKDGv2()`.
 
         Parameters:
 
             molecule:
                 The :class:`vabene.Molecule` from which to initialize.
 
-            functional_groups:
-                An :class:`iterable` of :class:`.FunctionalGroup` or
-                :class:`.FunctionalGroupFactory` or both.
-                :class:`.FunctionalGroup` instances are added to the
+            functional_groups (list[FunctionalGroup | FunctionalGroupFactory]):
+                :class:`.FunctionalGroup` instances added to the
                 building block and :class:`.FunctionalGroupFactory`
-                instances are used to create :class:`.FunctionalGroup`
-                instances the building block should hold.
+                instances used to create :class:`.FunctionalGroup`
+                instances added to the building block.
                 :class:`.FunctionalGroup` instances are used to
                 identify which atoms are modified during
                 :class:`.ConstructedMolecule` construction.
 
-            placer_ids:
+            placer_ids (list[int]):
                 The ids of *placer* atoms. These are the atoms which
                 should be used for calculating the position of the
                 building block. Depending on the values passed to
                 `placer_ids`, and the functional groups in the building
                 block, different *placer* ids will be used by the
                 building block.
 
@@ -280,15 +243,15 @@
             position_matrix:
                 The position matrix the building block should use. If
                 ``None``, :func:`rdkit.ETKDGv2` will be used to
                 calculate it.
 
         Returns:
 
-             The building block.
+            BuildingBlock: The building block.
 
         Raises:
 
             :class:`RuntimeError`
                 If embedding the molecule fails.
 
         """
@@ -312,16 +275,15 @@
 
         if position_matrix is None:
             params = rdkit.ETKDGv2()
             random_seed = 4
             params.randomSeed = random_seed
             if rdkit.EmbedMolecule(rdkit_molecule, params) == -1:
                 raise RuntimeError(
-                    f'Embedding with seed value of {random_seed} '
-                    'failed.'
+                    f"Embedding with seed value of {random_seed} " "failed."
                 )
         else:
             # Make sure the position matrix always holds floats.
             position_matrix = np.array(
                 position_matrix,
                 dtype=np.float64,
             )
@@ -336,43 +298,46 @@
             functional_groups=functional_groups,
             placer_ids=placer_ids,
         )
 
     @classmethod
     def init(
         cls,
-        atoms: tuple[Atom, ...],
-        bonds: tuple[Bond, ...],
+        atoms: Iterable[Atom],
+        bonds: Iterable[Bond],
         position_matrix: np.ndarray,
-        functional_groups: typing.Iterable[
-            typing.Union[FunctionalGroup, FunctionalGroupFactory]
+        functional_groups: Iterable[
+            FunctionalGroup | FunctionalGroupFactory
         ] = (),
-        placer_ids: typing.Optional[tuple[int, ...]] = None,
-    ) -> BuildingBlock:
+        placer_ids: Iterable[int] | None = None,
+    ) -> typing.Self:
         """
         Initialize a :class:`.BuildingBlock` from its components.
 
         Parameters:
 
-            atoms:
+            atoms (list[Atom]):
                 The atoms of the building block.
 
-            bonds:
+            bonds (list[Bond]):
                 The bonds of the building block.
 
             position_matrix:
                 An ``(n, 3)`` position matrix of the building block.
 
-            functional_groups:
-                An :class:`iterable` holding the
-                :class:`.FunctionalGroup` instances the building block
-                should have, and / or :class:`.FunctionalGroupFactory`
-                instances used for creating them.
+            functional_groups (list[FunctionalGroup | FunctionalGroupFactory]):
+                :class:`.FunctionalGroup` instances added to the
+                building block and :class:`.FunctionalGroupFactory`
+                instances used to create :class:`.FunctionalGroup`
+                instances added to the building block.
+                :class:`.FunctionalGroup` instances are used to
+                identify which atoms are modified during
+                :class:`.ConstructedMolecule` construction.
 
-            placer_ids:
+            placer_ids (list[int]):
                 The ids of *placer* atoms. These are the atoms which
                 should be used for calculating the position of the
                 building block. Depending on the values passed to
                 `placer_ids`, and the functional groups in the building
                 block, different *placer* ids will be used by the
                 building block.
 
@@ -387,74 +352,70 @@
 
                 #. `placer_ids` is ``None`` and `functional_groups` is
                    empty. All atoms of the molecule will be used for
                    *placer* ids.
 
         Returns:
 
-            The building block.
+            BuildingBlock: The building block.
 
         """
 
         building_block = cls.__new__(cls)
         Molecule.__init__(
             self=building_block,
             atoms=atoms,
             bonds=bonds,
             position_matrix=position_matrix,
         )
         functional_groups = building_block._extract_functional_groups(
             functional_groups=functional_groups,
         )
         building_block._with_functional_groups(functional_groups)
-        building_block._placer_ids = (
-            building_block._normalize_placer_ids(
-                placer_ids=placer_ids,
-                functional_groups=building_block._functional_groups,
-            )
+        building_block._placer_ids = building_block._normalize_placer_ids(
+            placer_ids=placer_ids,
+            functional_groups=building_block._functional_groups,
         )
         building_block._core_ids = frozenset(
             building_block._get_core_ids(
                 functional_groups=building_block._functional_groups,
             )
         )
         return building_block
 
     @classmethod
     def init_from_file(
         cls,
         path: str,
-        functional_groups: typing.Iterable[
-            typing.Union[FunctionalGroup, FunctionalGroupFactory]
+        functional_groups: Iterable[
+            FunctionalGroup | FunctionalGroupFactory
         ] = (),
-        placer_ids: typing.Optional[tuple[int, ...]] = None,
-    ):
+        placer_ids: Iterable[int] | None = None,
+    ) -> typing.Self:
         """
         Initialize from a file.
 
         Parameters:
 
             path:
                 The path to a molecular structure file. Supported file
                 types are:
 
                     #. ``.mol``, ``.sdf`` - MDL V3000 MOL file
 
-            functional_groups:
-                An :class:`iterable` of :class:`.FunctionalGroup` or
-                :class:`.FunctionalGroupFactory` or both.
-                :class:`.FunctionalGroup` instances are added to the
+            functional_groups (list[FunctionalGroup | FunctionalGroupFactory]):
+                :class:`.FunctionalGroup` instances added to the
                 building block and :class:`.FunctionalGroupFactory`
-                instances are used to create :class:`.FunctionalGroup`
-                instances the building block should hold.
+                instances used to create :class:`.FunctionalGroup`
+                instances added to the building block.
                 :class:`.FunctionalGroup` instances are used to
                 identify which atoms are modified during
                 :class:`.ConstructedMolecule` construction.
 
-            placer_ids:
+            placer_ids (list[int]):
                 The ids of *placer* atoms. These are the atoms which
                 should be used for calculating the position of the
                 building block. Depending on the values passed to
                 `placer_ids`, and the functional groups in the building
                 block, different *placer* ids will be used by the
                 building block.
 
@@ -469,38 +430,27 @@
 
                 #. `placer_ids` is ``None`` and `functional_groups` is
                    empty. All atoms of the molecule will be used for
                    *placer* ids.
 
         Returns:
 
-            The building block.
+            BuildingBlock: The building block.
 
         Raises:
 
             :class:`ValueError`
                 If the file type cannot be used for initialization.
 
         """
 
         _, extension = os.path.splitext(path)
 
-        if extension == '.pdb':
-            warnings.warn(
-                'Loading from .pdb files is deprecated and will be '
-                'removed from stk versions released after 1st Nov '
-                '2022. Please use .mol files for loading molecules '
-                'instead.',
-                category=FutureWarning,
-            )
-
         if extension not in cls._init_funcs:
-            raise ValueError(
-                f'Unable to initialize from "{extension}" files.'
-            )
+            raise ValueError(f'Unable to initialize from "{extension}" files.')
         # This remake needs to be here because molecules loaded
         # with rdkit often have issues, because rdkit tries to do
         # bits of structural analysis like stereocenters. Remake
         # gets rid of all this problematic metadata.
         molecule = remake(cls._init_funcs[extension](path))
 
         return cls.init_from_rdkit_mol(
@@ -509,19 +459,19 @@
             placer_ids=placer_ids,
         )
 
     @classmethod
     def init_from_rdkit_mol(
         cls,
         molecule: rdkit.Mol,
-        functional_groups: typing.Iterable[
-            typing.Union[FunctionalGroup, FunctionalGroupFactory]
+        functional_groups: Iterable[
+            FunctionalGroup | FunctionalGroupFactory
         ] = (),
-        placer_ids: typing.Optional[tuple[int, ...]] = None,
-    ) -> BuildingBlock:
+        placer_ids: Iterable[int] | None = None,
+    ) -> typing.Self:
         """
         Initialize from an :mod:`rdkit` molecule.
 
         Warnings:
 
             For :mod:`rdkit` molecules with non-integer bond orders,
             such as 1.5, the molecule should be kekulized prior to
@@ -529,26 +479,24 @@
             set to an integer value in the building block.
 
         Parameters:
 
             molecule:
                 The molecule.
 
-            functional_groups:
-                An :class:`iterable` of :class:`.FunctionalGroup` or
-                :class:`.FunctionalGroupFactory` or both.
-                :class:`.FunctionalGroup` instances are added to the
+            functional_groups (list[FunctionalGroup | FunctionalGroupFactory]):
+                :class:`.FunctionalGroup` instances added to the
                 building block and :class:`.FunctionalGroupFactory`
-                instances are used to create :class:`.FunctionalGroup`
-                instances the building block should hold.
+                instances used to create :class:`.FunctionalGroup`
+                instances added to the building block.
                 :class:`.FunctionalGroup` instances are used to
                 identify which atoms are modified during
                 :class:`.ConstructedMolecule` construction.
 
-            placer_ids:
+            placer_ids (list[int]):
                 The ids of *placer* atoms. These are the atoms which
                 should be used for calculating the position of the
                 building block. Depending on the values passed to
                 `placer_ids`, and the functional groups in the building
                 block, different *placer* ids will be used by the
                 building block.
 
@@ -563,54 +511,50 @@
 
                 #. `placer_ids` is ``None`` and `functional_groups` is
                    empty. All atoms of the molecule will be used for
                    *placer* ids.
 
         Returns:
 
-            The molecule.
+            BuildingBlock: The building block.
 
         """
 
         building_block = cls.__new__(cls)
         building_block._init_from_rdkit_mol(
             molecule=molecule,
             functional_groups=functional_groups,
             placer_ids=placer_ids,
         )
         return building_block
 
     def _init_from_rdkit_mol(
         self,
         molecule: rdkit.Mol,
-        functional_groups: typing.Iterable[
-            typing.Union[FunctionalGroup, FunctionalGroupFactory]
-        ],
-        placer_ids: typing.Optional[tuple[int, ...]],
+        functional_groups: Iterable[FunctionalGroup | FunctionalGroupFactory],
+        placer_ids: Iterable[int] | None,
     ) -> None:
         """
         Initialize from an :mod:`rdkit` molecule.
 
         Parameters:
 
             molecule:
                 The molecule.
 
-            functional_groups:
-                An :class:`iterable` of :class:`.FunctionalGroup` or
-                :class:`.FunctionalGroupFactory` or both.
-                :class:`.FunctionalGroup` instances are added to the
+            functional_groups (list[FunctionalGroup | FunctionalGroupFactory]):
+                :class:`.FunctionalGroup` instances added to the
                 building block and :class:`.FunctionalGroupFactory`
-                instances are used to create :class:`.FunctionalGroup`
-                instances the building block should hold.
+                instances used to create :class:`.FunctionalGroup`
+                instances added to the building block.
                 :class:`.FunctionalGroup` instances are used to
                 identify which atoms are modified during
                 :class:`.ConstructedMolecule` construction.
 
-            placer_ids:
+            placer_ids (list[int]):
                 The ids of *placer* atoms. These are the atoms which
                 should be used for calculating the position of the
                 building block. Depending on the values passed to
                 `placer_ids`, and the functional groups in the building
                 block, different *placer* ids will be used by the
                 building block.
 
@@ -634,37 +578,42 @@
             for a in molecule.GetAtoms()
         )
         bonds = tuple(
             Bond(
                 atom1=atoms[b.GetBeginAtomIdx()],
                 atom2=atoms[b.GetEndAtomIdx()],
                 order=(
-                    9 if b.GetBondType() == rdkit.BondType.DATIVE
+                    9
+                    if b.GetBondType() == rdkit.BondType.DATIVE
                     else b.GetBondTypeAsDouble()
-                )
+                ),
             )
             for b in molecule.GetBonds()
         )
         position_matrix = molecule.GetConformer().GetPositions()
 
         super().__init__(atoms, bonds, position_matrix)
-        self._with_functional_groups(self._extract_functional_groups(
-            functional_groups=functional_groups,
-        ))
+        self._with_functional_groups(
+            self._extract_functional_groups(
+                functional_groups=functional_groups,
+            )
+        )
         self._placer_ids = self._normalize_placer_ids(
             placer_ids=placer_ids,
             functional_groups=self._functional_groups,
         )
-        self._core_ids = frozenset(self._get_core_ids(
-            functional_groups=self._functional_groups,
-        ))
+        self._core_ids = frozenset(
+            self._get_core_ids(
+                functional_groups=self._functional_groups,
+            )
+        )
 
     def _normalize_placer_ids(
         self,
-        placer_ids: typing.Optional[tuple[int, ...]],
+        placer_ids: Iterable[int] | None,
         functional_groups: Collection[FunctionalGroup],
     ) -> frozenset[int]:
         """
         Get the final *placer* ids.
 
         Parameters:
 
@@ -692,25 +641,27 @@
 
         """
 
         if placer_ids is not None:
             return frozenset(placer_ids)
 
         if functional_groups:
-            return frozenset(flatten(
-                functional_group.get_placer_ids()
-                for functional_group in functional_groups
-            ))
+            return frozenset(
+                flatten(
+                    functional_group.get_placer_ids()
+                    for functional_group in functional_groups
+                )
+            )
 
         return frozenset(atom.get_id() for atom in self._atoms)
 
     def _get_core_ids(
         self,
-        functional_groups: typing.Iterable[FunctionalGroup],
-    ) -> typing.Iterator[int]:
+        functional_groups: Iterable[FunctionalGroup],
+    ) -> Iterator[int]:
         """
         Get the final *core* ids.
 
         This method may return duplicate ids.
 
         Parameters:
 
@@ -736,18 +687,16 @@
 
         for functional_group in functional_groups:
             for atom_id in functional_group.get_core_atom_ids():
                 yield atom_id
 
     def _extract_functional_groups(
         self,
-        functional_groups: typing.Iterable[
-            typing.Union[FunctionalGroup, FunctionalGroupFactory]
-        ],
-    ) -> typing.Iterator[FunctionalGroup]:
+        functional_groups: Iterable[FunctionalGroup | FunctionalGroupFactory],
+    ) -> Iterator[FunctionalGroup]:
         """
         Yield functional groups.
 
         The input can be a mixture of :class:`.FunctionalGroup` and
         :class:`.FunctionalGroupFactory`. The output yields
         :class:`.FunctionalGroup` instances only. Either those
         held directly in `functional_groups` or created by the
@@ -772,63 +721,57 @@
                 yield functional_group
             else:
                 # Else it's a factory.
                 yield from functional_group.get_functional_groups(self)
 
     def _with_functional_groups(
         self,
-        functional_groups: typing.Iterable[FunctionalGroup],
-    ) -> BuildingBlock:
+        functional_groups: Iterable[FunctionalGroup],
+    ) -> typing.Self:
         """
         Modify the molecule.
 
         """
 
         self._functional_groups = tuple(functional_groups)
         return self
 
     def with_functional_groups(
         self,
-        functional_groups: typing.Iterable[FunctionalGroup],
-    ) -> BuildingBlock:
+        functional_groups: Iterable[FunctionalGroup],
+    ) -> typing.Self:
         """
         Return a clone with specific functional groups.
 
         Parameters:
 
-            functional_groups:
-                :class:`.FunctionalGroup` instances which the clone
-                should have.
+            functional_groups (list[FunctionalGroup]):
+                Functional groups the clone should have.
 
         Returns:
 
-            The clone.
+            BuildingBlock: The clone.
 
         """
 
         return self.clone()._with_functional_groups(functional_groups)
 
-    def _with_canonical_atom_ordering(self) -> BuildingBlock:
+    def _with_canonical_atom_ordering(self) -> typing.Self:
         ordering = rdkit.CanonicalRankAtoms(self.to_rdkit_mol())
         super()._with_canonical_atom_ordering()
-        id_map = {
-            old_id: new_id
-            for old_id, new_id in enumerate(ordering)
-        }
+        id_map = {old_id: new_id for old_id, new_id in enumerate(ordering)}
         self._functional_groups = tuple(
             functional_group.with_ids(id_map)
             for functional_group in self._functional_groups
         )
         self._placer_ids = frozenset(
-            id_map[placer_id]
-            for placer_id in self._placer_ids
+            id_map[placer_id] for placer_id in self._placer_ids
         )
         self._core_ids = frozenset(
-            id_map[core_id]
-            for core_id in self._core_ids
+            id_map[core_id] for core_id in self._core_ids
         )
         return self
 
     def get_num_functional_groups(self) -> int:
         """
         Return the number of functional groups.
 
@@ -838,42 +781,46 @@
 
         """
 
         return len(self._functional_groups)
 
     def get_functional_groups(
         self,
-        fg_ids: typing.Optional[OneOrMany[int]] = None,
-    ) -> typing.Iterator[FunctionalGroup]:
+        fg_ids: int | Iterable[int] | None = None,
+    ) -> Iterator[FunctionalGroup]:
         """
         Yield the functional groups, ordered by id.
 
         Parameters:
 
-            fg_ids:
+            fg_ids (int | list[int] | None):
                 The ids of functional groups yielded. If ``None``, then
-                all functional groups are yielded. Can be a single
-                :class:`int`, if a single functional group is
-                desired.
+                all functional groups are yielded.
 
         Yields:
 
             A functional group of the building block.
 
         """
 
         if fg_ids is None:
             fg_ids = range(len(self._functional_groups))
         elif isinstance(fg_ids, int):
-            fg_ids = (fg_ids, )
+            fg_ids = (fg_ids,)
 
         for fg_id in fg_ids:
             yield self._functional_groups[fg_id]
 
-    def clone(self) -> BuildingBlock:
+    def clone(self) -> typing.Self:
+        """
+        Return a clone.
+
+        Returns:
+            BuildingBlock: The clone.
+        """
         clone = self._clone()
         clone._functional_groups = self._functional_groups
         clone._placer_ids = self._placer_ids
         clone._core_ids = self._core_ids
         return clone
 
     def get_num_placers(self) -> int:
@@ -884,151 +831,321 @@
 
             The number of *placer* atoms in the building block.
 
         """
 
         return len(self._placer_ids)
 
-    def get_placer_ids(self) -> typing.Iterator[int]:
+    def get_placer_ids(self) -> Iterator[int]:
         """
         Yield the ids of *placer* atoms.
 
         *Placer* atoms are those, which should be used to calculate
         the position of the building block.
 
         See Also:
 
-            :meth:`.FunctionalGroup.get_placer_ids`
+            * :meth:`.FunctionalGroup.get_placer_ids`: For getting
+              the placer ids of functional groups.
 
         Yields:
 
             The id of a *placer* atom.
 
         """
 
         yield from self._placer_ids
 
-    def get_core_atom_ids(self) -> typing.Iterator[int]:
+    def get_core_atom_ids(self) -> Iterator[int]:
         """
         Yield ids of atoms which form the core of the building block.
 
         This includes all atoms in the building block not part of a
         functional group, as well as any atoms in a functional group,
         specifically labelled as core atoms.
 
         See Also:
 
-            :meth:`.FunctionalGroup.get_core_atom_ids`
+            * :meth:`.FunctionalGroup.get_core_atom_ids`: For getting
+              the core atom ids of functional groups.
 
         Yields:
 
             The id of a *core* atom.
 
 
         """
 
         yield from self._core_ids
 
-    def with_canonical_atom_ordering(self) -> BuildingBlock:
-        return self.clone()._with_canonical_atom_ordering()
+    def with_canonical_atom_ordering(self) -> typing.Self:
+        """
+        Return a clone, with canonically ordered atoms.
+
+        Returns:
+            BuildingBlock: The clone.
+        """
+        return super().with_canonical_atom_ordering()
 
     def with_centroid(
         self,
         position: np.ndarray,
-        atom_ids: typing.Optional[OneOrMany[int]] = None,
-    ) -> BuildingBlock:
+        atom_ids: int | Iterable[int] | None = None,
+    ) -> typing.Self:
+        """
+        Return a clone with its centroid at `position`.
 
-        return self.clone()._with_centroid(position, atom_ids)
+        Parameters:
 
-    def with_displacement(
-        self,
-        displacement: np.ndarray,
-    ) -> BuildingBlock:
+            position:
+                This array holds the position on which the centroid of
+                the clone is going to be placed.
+
+            atom_ids (int | list[int] | None):
+                The ids of atoms which should have their centroid set
+                to `position`. If ``None``, all atoms are used.
 
-        return self.clone()._with_displacement(displacement)
+        Returns:
 
-    def with_position_matrix(
-        self,
-        position_matrix: np.ndarray,
-    ) -> BuildingBlock:
+            BuildingBlock: A clone with its centroid at `position`.
+        """
+        return super().with_centroid(position, atom_ids)
+
+    def with_displacement(self, displacement: np.ndarray) -> typing.Self:
+        """
+        Return a displaced clone.
 
-        return self.clone()._with_position_matrix(position_matrix)
+        Parameters:
+
+            displacement:
+                The displacement vector to be applied.
+
+        Returns:
+
+            BuildingBlock: A displaced clone.
+        """
+        return super().with_displacement(displacement)
+
+    def with_position_matrix(self, position_matrix: np.ndarray) -> typing.Self:
+        """
+        Return a clone with atomic positions set by `position_matrix`.
+
+        Parameters:
+
+            position_matrix:
+                The position matrix of the clone. The shape of the
+                matrix is ``(n, 3)``.
+
+        Returns:
+
+            BuildingBlock: The clone.
+
+        """
+        return super().with_position_matrix(position_matrix)
 
     def with_rotation_about_axis(
         self,
         angle: float,
         axis: np.ndarray,
         origin: np.ndarray,
-    ) -> BuildingBlock:
+    ) -> typing.Self:
+        """
+        Return a rotated clone.
 
-        return self.clone()._with_rotation_about_axis(
-            angle=angle,
-            axis=axis,
-            origin=origin,
-        )
+        The clone is rotated by `angle` about `axis` on the
+        `origin`.
+
+        Parameters:
+
+            angle:
+                The size of the rotation in radians.
+
+            axis:
+                The axis about which the rotation happens. Must have
+                unit magnitude.
+
+            origin:
+                The origin about which the rotation happens.
+
+        Returns:
+
+            BuildingBlock: A rotated clone.
+
+        """
+        return super().with_rotation_about_axis(angle, axis, origin)
 
     def with_rotation_between_vectors(
         self,
         start: np.ndarray,
         target: np.ndarray,
         origin: np.ndarray,
-    ) -> BuildingBlock:
+    ) -> typing.Self:
+        """
+        Return a rotated clone.
 
-        return self.clone()._with_rotation_between_vectors(
-            start=start,
-            target=target,
-            origin=origin,
-        )
+        The rotation is equal to a rotation from `start` to `target`.
+
+        Given two direction vectors, `start` and `target`, this method
+        applies the rotation required transform `start` to `target`
+        onto the clone. The rotation occurs about the `origin`.
+
+        For example, if the `start` and `target` vectors
+        are 45 degrees apart, a 45 degree rotation will be applied to
+        the clone. The rotation will be along the appropriate
+        direction.
+
+        The great thing about this method is that you as long as you
+        can associate a geometric feature of the molecule with a
+        vector, then the clone can be rotated so that this vector is
+        aligned with `target`. The defined vector can be virtually
+        anything. This means that any geometric feature of the molecule
+        can be easily aligned with any arbitrary direction.
+
+        Parameters:
+
+            start:
+                A vector which is to be rotated so that it transforms
+                into the `target` vector.
+
+            target:
+                The vector onto which `start` is rotated.
+
+            origin:
+                The point about which the rotation occurs.
+
+        Returns:
+
+            BuildingBlock: A rotated clone.
+
+        """
+        return super().with_rotation_between_vectors(start, target, origin)
 
     def with_rotation_to_minimize_angle(
         self,
         start: np.ndarray,
         target: np.ndarray,
         axis: np.ndarray,
         origin: np.ndarray,
-    ) -> BuildingBlock:
+    ) -> typing.Self:
+        """
+        Return a rotated clone.
+
+        The clone is rotated by the rotation required to minimize
+        the angle between `start` and `target`.
+
+        Note that this function will not necessarily overlay the
+        `start` and `target` vectors. This is because the possible
+        rotation is restricted to the `axis`.
+
+        Parameters:
+
+            start:
+                The vector which is rotated.
+
+            target:
+                The vector which is stationary.
+
+            axis:
+                The vector about which the rotation happens. Must have
+                unit magnitude.
 
-        return self.clone()._with_rotation_to_minimize_angle(
+            origin:
+                The origin about which the rotation happens.
+
+        Returns:
+
+            BuildingBlock: A rotated clone.
+
+        Raises:
+
+            :class:`ValueError`
+                If `target` has a magnitude of 0. In this case it is
+                not possible to calculate an angle between `start` and
+                `target`.
+
+        """
+        return super().with_rotation_to_minimize_angle(
             start=start,
             target=target,
             axis=axis,
             origin=origin,
         )
 
     def with_structure_from_file(
         self,
         path: str,
-        extension: typing.Optional[str] = None,
-    ) -> BuildingBlock:
+        extension: str | None = None,
+    ) -> typing.Self:
+        """
+        Return a clone, with its structure taken from a file.
 
-        return typing.cast(
-            BuildingBlock,
-            super().with_structure_from_file(
-                path=path,
-                extension=extension,
-            )
-        )
+        Multiple file types are supported, namely:
+
+        #. ``.mol``, ``.sdf`` - MDL V2000 and V3000 files
+        #. ``.xyz`` - XYZ files
+        #. ``.mae`` - Schrodinger Maestro files
+        #. ``.coord`` - Turbomole files
+        #. ``.pdb`` - PDB files
+
+        Parameters:
+
+            path:
+                The path to a molecular structure file holding updated
+                coordinates for the :class:`.Molecule`.
+
+            extension:
+                If you want to treat the file as though it has a
+                particular extension, put it here. Include the dot.
+
+        Returns:
+
+            BuildingBlock: A clone with atomic positions found in `path`.
+
+        """
+        return super().with_structure_from_file(path, extension)
 
     def write(
         self,
         path: str,
-        atom_ids: typing.Optional[OneOrMany[int]] = None,
-    ) -> BuildingBlock:
+        atom_ids: int | Iterable[int] | None = None,
+    ) -> typing.Self:
+        """
+        Write the structure to a file.
 
-        return typing.cast(
-            BuildingBlock,
-            super().write(path, atom_ids)
-        )
+        This function will write the format based on the extension
+        of `path`.
+
+        #. ``.mol``, ``.sdf`` - MDL V3000 MOL file
+        #. ``.xyz`` - XYZ file
+        #. ``.pdb`` - PDB file
+
+        Parameters:
+
+            path:
+                The `path` to which the molecule should be written.
+
+            atom_ids (int | list[int] | None):
+                The ids of atoms to write. If ``None``, all
+                atoms are used. If you use this parameter, the atom
+                ids in the file may not correspond to the atom ids
+                in the molecule.
+
+        Returns:
+
+            BuildingBlock: The molecule.
+
+        """
+        return super().write(path, atom_ids)
 
     def __str__(self) -> str:
         if self._functional_groups:
-            fg_repr = f', {self._functional_groups!r}'
+            fg_repr = f", {self._functional_groups!r}"
         else:
-            fg_repr = ''
+            fg_repr = ""
 
         smiles = rdkit.MolToSmiles(
             mol=rdkit.RemoveHs(self.to_rdkit_mol()),
         )
-        return f'{self.__class__.__name__}({smiles!r}{fg_repr})'
+        return f"{self.__class__.__name__}({smiles!r}{fg_repr})"
 
     def __repr__(self) -> str:
         return str(self)
```

### Comparing `stk-2022.6.17.0/src/stk/molecular/molecules/constructed_molecule.py` & `stk-2023.7.5.0/src/stk/_internal/constructed_molecule.py`

 * *Files 4% similar despite different names*

```diff
@@ -8,23 +8,30 @@
 
 import logging
 import typing
 
 import numpy as np
 import rdkit.Chem.AllChem as rdkit
 
-from ...utilities import OneOrMany
-from ..atoms import Atom, AtomInfo
-from ..bonds import Bond, BondInfo
-from ..topology_graphs import TopologyGraph
-from ..topology_graphs.topology_graph.construction_result import (
+from stk._internal.atom import Atom
+from stk._internal.atom_info import AtomInfo
+from stk._internal.bond import Bond
+from stk._internal.bond_info import BondInfo
+from stk._internal.construction_result.construction_result import (
     ConstructionResult,
 )
-from .molecule import Molecule
-from .utilities import get_bond_info_atom_ids, sort_bond_atoms_by_id
+from stk._internal.molecule import Molecule
+from stk._internal.topology_graphs.topology_graph.topology_graph import (
+    TopologyGraph,
+)
+from stk._internal.utilities.molecule import (
+    get_bond_info_atom_ids,
+    sort_bond_atoms_by_id,
+)
+from stk._internal.utilities.utilities import OneOrMany
 
 logger = logging.getLogger(__name__)
 
 
 class ConstructedMolecule(Molecule):
     """
     Represents constructed molecules.
@@ -85,15 +92,15 @@
         Obviously, the initialization of the
         :class:`.ConstructedMolecule` depends mostly on the specifics
         of the :class:`.TopologyGraph` used, and the documentation of
         those classes should be examined for more examples.
 
     """
 
-    _atom_infos:  tuple[AtomInfo, ...]
+    _atom_infos: tuple[AtomInfo, ...]
     _bond_infos: tuple[BondInfo, ...]
     _num_building_blocks: dict[Molecule, int]
 
     def __init__(
         self,
         topology_graph: TopologyGraph,
     ) -> None:
@@ -216,16 +223,15 @@
         )
         obj._atom_infos = construction_result.get_atom_infos()
         obj._bond_infos = construction_result.get_bond_infos()
         obj._num_building_blocks = {
             building_block: construction_result.get_num_building_block(
                 building_block=building_block,
             )
-            for building_block
-            in construction_result.get_building_blocks()
+            for building_block in construction_result.get_building_blocks()
         }
         return obj
 
     def clone(self) -> ConstructedMolecule:
         clone = self._clone()
         clone._atom_infos = self._atom_infos
         clone._bond_infos = self._bond_infos
@@ -291,15 +297,15 @@
             Data about an atom.
 
         """
 
         if atom_ids is None:
             atom_ids = range(len(self._atoms))
         elif isinstance(atom_ids, int):
-            atom_ids = (atom_ids, )
+            atom_ids = (atom_ids,)
 
         for atom_id in atom_ids:
             yield self._atom_infos[atom_id]
 
     def get_bond_infos(self) -> typing.Iterator[BondInfo]:
         """
         Yield data about bonds in the molecule.
@@ -314,86 +320,80 @@
 
     def with_canonical_atom_ordering(self) -> ConstructedMolecule:
         return self.clone()._with_canonical_atom_ordering()
 
     def _with_canonical_atom_ordering(self) -> ConstructedMolecule:
         # Make all building blocks canonically ordered too.
         building_blocks = {
-            building_block:
-                building_block.with_canonical_atom_ordering()
-
+            building_block: building_block.with_canonical_atom_ordering()
             for building_block in self._num_building_blocks
         }
 
         # Cache these mappings for later, to avoid unnecessary
         # re-computations of canonical ordering.
         canonical_map = {
             building_block: building_block.get_canonical_atom_ids()
             for building_block in self._num_building_blocks
         }
 
-        self._num_building_blocks = {
-            building_block: num
-            for building_block, num
-            in zip(
+        self._num_building_blocks = dict(
+            zip(
                 building_blocks.values(),
                 self._num_building_blocks.values(),
-            )
-        }
+            ),
+        )
 
         ordering = rdkit.CanonicalRankAtoms(self.to_rdkit_mol())
         id_map = {
             new_id: atom.get_id()
             for new_id, atom in zip(ordering, self._atoms)
         }
         super()._with_canonical_atom_ordering()
         atom_map = {
             old_id: self._atoms[new_id]
             for old_id, new_id in enumerate(ordering)
         }
         old_atom_infos = self._atom_infos
 
         def get_atom_info(atom: Atom) -> AtomInfo:
-
             old_atom_info = old_atom_infos[id_map[atom.get_id()]]
             old_building_block = old_atom_info.get_building_block()
 
             if old_building_block is None:
                 return AtomInfo(
                     atom=atom,
                     building_block_atom=None,
                     building_block=None,
                     building_block_id=None,
                 )
 
-            old_building_block_atom = (
-                old_atom_info.get_building_block_atom()
+            # If old_building_block is not None then neither is the
+            # old_building_block_atom.
+            old_building_block_atom = typing.cast(
+                Atom,
+                old_atom_info.get_building_block_atom(),
             )
 
             canonical_building_block_atom_id = canonical_map[
                 old_building_block
             ][old_building_block_atom.get_id()]
 
-            canonical_building_block = building_blocks[
-                old_building_block
-            ]
+            canonical_building_block = building_blocks[old_building_block]
 
-            canonical_building_block_atom, = (
-                canonical_building_block.get_atoms(
-                    atom_ids=canonical_building_block_atom_id,
-                )
+            (
+                canonical_building_block_atom,
+            ) = canonical_building_block.get_atoms(
+                atom_ids=canonical_building_block_atom_id,
             )
 
             return AtomInfo(
                 atom=atom,
                 building_block_atom=canonical_building_block_atom,
                 building_block=canonical_building_block,
-                building_block_id=(
-                    old_atom_info.get_building_block_id()
-                ),
+                building_block_id=(old_atom_info.get_building_block_id()),
             )
 
         def get_bond_info(info: BondInfo) -> BondInfo:
             building_block = info.get_building_block()
             return BondInfo(
                 bond=sort_bond_atoms_by_id(
                     info.get_bond().with_atoms(atom_map)
@@ -403,97 +403,91 @@
                     if building_block is None
                     else building_blocks[building_block]
                 ),
                 building_block_id=info.get_building_block_id(),
             )
 
         self._atom_infos = tuple(map(get_atom_info, self._atoms))
-        self._bond_infos = tuple(sorted(
-            map(get_bond_info, self._bond_infos),
-            key=get_bond_info_atom_ids,
-        ))
+        self._bond_infos = tuple(
+            sorted(
+                map(get_bond_info, self._bond_infos),
+                key=get_bond_info_atom_ids,
+            )
+        )
         return self
 
     def with_centroid(
         self,
         position: np.ndarray,
         atom_ids: typing.Optional[OneOrMany[int]] = None,
     ) -> ConstructedMolecule:
-
         return self.clone()._with_centroid(position, atom_ids)
 
     def with_displacement(
         self,
         displacement: np.ndarray,
     ) -> ConstructedMolecule:
-
         return self.clone()._with_displacement(displacement)
 
     def with_position_matrix(
         self,
         position_matrix: np.ndarray,
     ) -> ConstructedMolecule:
-
         return self.clone()._with_position_matrix(position_matrix)
 
     def with_rotation_about_axis(
         self,
         angle: float,
         axis: np.ndarray,
         origin: np.ndarray,
     ) -> ConstructedMolecule:
-
         return self.clone()._with_rotation_about_axis(
             angle=angle,
             axis=axis,
             origin=origin,
         )
 
     def with_rotation_between_vectors(
         self,
         start: np.ndarray,
         target: np.ndarray,
         origin: np.ndarray,
     ) -> ConstructedMolecule:
-
         return self.clone()._with_rotation_between_vectors(
             start=start,
             target=target,
             origin=origin,
         )
 
     def with_rotation_to_minimize_angle(
         self,
         start: np.ndarray,
         target: np.ndarray,
         axis: np.ndarray,
         origin: np.ndarray,
     ) -> ConstructedMolecule:
-
         return self.clone()._with_rotation_to_minimize_angle(
             start=start,
             target=target,
             axis=axis,
             origin=origin,
         )
 
     def with_structure_from_file(
         self,
         path: str,
         extension: typing.Optional[str] = None,
     ) -> ConstructedMolecule:
-
         return typing.cast(
             ConstructedMolecule,
             super().with_structure_from_file(path, extension),
         )
 
     def write(
         self,
         path: str,
         atom_ids: typing.Optional[OneOrMany[int]] = None,
     ) -> ConstructedMolecule:
-
         return typing.cast(
             ConstructedMolecule,
             super().write(path, atom_ids),
         )
```

### Comparing `stk-2022.6.17.0/src/stk/molecular/molecules/molecule/molecule.py` & `stk-2023.7.5.0/src/stk/_internal/molecule.py`

 * *Files 13% similar despite different names*

```diff
@@ -1,42 +1,30 @@
-"""
-Molecule
-========
-
-.. toctree::
-    :maxdepth: 2
-
-    Building Block <stk.molecular.molecules.building_block>
-    Constructed Molecule <stk.molecular.molecules.constructed_molecule>
-
-"""
-
-
-from __future__ import annotations
-
 import os
 import typing
+from collections.abc import Iterable, Iterator
 
 import numpy as np
 import rdkit.Chem.AllChem as rdkit
 from scipy.spatial.distance import euclidean
 
-from stk.utilities import (
+from stk._internal.atom import Atom
+from stk._internal.bond import Bond
+from stk._internal.utilities.molecule import (
+    get_bond_atom_ids,
+    sort_bond_atoms_by_id,
+)
+from stk._internal.utilities.updaters import mae, mdl_mol, pdb, turbomole, xyz
+from stk._internal.utilities.utilities import (
     rotation_matrix,
     rotation_matrix_arbitrary_axis,
     vector_angle,
 )
-
-from ....utilities import OneOrMany
-from ...atoms import Atom
-from ...bonds import Bond
-from ..utilities import get_bond_atom_ids, sort_bond_atoms_by_id
-from .utilities import updaters, writers
-
-_T = typing.TypeVar('_T', bound='Molecule')
+from stk._internal.utilities.writers.mdl_mol import _write_mdl_mol_file
+from stk._internal.utilities.writers.pdb import _write_pdb_file
+from stk._internal.utilities.writers.xyz import _write_xyz_file
 
 
 class Molecule:
     """
     An abstract base class for molecules.
 
     Notes:
@@ -104,84 +92,76 @@
                 origin=benzene.get_centroid(),
             )
 
     """
 
     def __init__(
         self,
-        atoms: tuple[Atom, ...],
-        bonds: tuple[Bond, ...],
+        atoms: Iterable[Atom],
+        bonds: Iterable[Bond],
         position_matrix: np.ndarray,
     ) -> None:
         """
         Initialize a :class:`.Molecule`.
 
         Parameters:
 
-            atoms:
+            atoms (list[Atom]):
                 The atoms which compose the molecule.
 
-            bonds:
+            bonds (list[Bond]):
                 The bonds of the molecule.
 
             position_matrix:
                 A ``(n, 3)`` matrix holding the position of every atom
                 in the :class:`.Molecule`.
 
         """
 
-        self._atoms = atoms
-        self._bonds = bonds
+        self._atoms = tuple(atoms)
+        self._bonds = tuple(bonds)
         # Take the transpose because it will make some matrix
         # multiplications faster.
         self._position_matrix = np.array(
             position_matrix.T,
             dtype=np.float64,
         )
 
-    def _with_displacement(
-        self: _T,
-        displacement: np.ndarray,
-    ) -> _T:
+    def _with_displacement(self, displacement: np.ndarray) -> typing.Self:
         """
         Modify molecule.
 
         """
 
-        self._position_matrix = (
-            self._position_matrix.T + displacement
-        ).T
+        self._position_matrix = (self._position_matrix.T + displacement).T
         return self
 
-    def with_displacement(
-        self,
-        displacement: np.ndarray,
-    ) -> Molecule:
+    def with_displacement(self, displacement: np.ndarray) -> typing.Self:
         """
         Return a displaced clone.
 
         Parameters:
 
             displacement:
                 The displacement vector to be applied.
 
         Returns:
 
-            A displaced clone.
+            Molecule: A displaced clone.
 
         """
 
         return self.clone()._with_displacement(displacement)
 
     def _with_rotation_about_axis(
-        self: _T,
+        self,
         angle: float,
         axis: np.ndarray,
         origin: np.ndarray,
-    ) -> _T:
+    ) -> typing.Self:
         """
         Modify molecule.
 
         """
 
         # Set the origin of the rotation to "origin".
         self._with_displacement(-origin)
@@ -196,15 +176,15 @@
         return self
 
     def with_rotation_about_axis(
         self,
         angle: float,
         axis: np.ndarray,
         origin: np.ndarray,
-    ) -> Molecule:
+    ) -> typing.Self:
         """
         Return a rotated clone.
 
         The clone is rotated by `angle` about `axis` on the
         `origin`.
 
         Parameters:
@@ -217,30 +197,30 @@
                 unit magnitude.
 
             origin:
                 The origin about which the rotation happens.
 
         Returns:
 
-            A rotated clone.
+            Molecule: A rotated clone.
 
         """
 
         return self.clone()._with_rotation_about_axis(
             angle=angle,
             axis=axis,
             origin=origin,
         )
 
     def _with_rotation_between_vectors(
-        self: _T,
+        self,
         start: np.ndarray,
         target: np.ndarray,
         origin: np.ndarray,
-    ) -> _T:
+    ) -> typing.Self:
         """
         Modify molecule.
 
         """
 
         # Set the origin of the rotation to "origin".
         self._with_displacement(-origin)
@@ -255,15 +235,15 @@
         return self
 
     def with_rotation_between_vectors(
         self,
         start: np.ndarray,
         target: np.ndarray,
         origin: np.ndarray,
-    ) -> Molecule:
+    ) -> typing.Self:
         """
         Return a rotated clone.
 
         The rotation is equal to a rotation from `start` to `target`.
 
         Given two direction vectors, `start` and `target`, this method
         applies the rotation required transform `start` to `target`
@@ -291,79 +271,78 @@
                 The vector onto which `start` is rotated.
 
             origin:
                 The point about which the rotation occurs.
 
         Returns:
 
-            A rotated clone.
+            Molecule: A rotated clone.
 
         """
 
         return self.clone()._with_rotation_between_vectors(
             start=start,
             target=target,
             origin=origin,
         )
 
     def _with_rotation_to_minimize_angle(
-        self: _T,
+        self,
         start: np.ndarray,
         target: np.ndarray,
         axis: np.ndarray,
         origin: np.ndarray,
-    ) -> _T:
-
+    ) -> typing.Self:
         # If the vector being rotated is not finite, exit. This is
         # probably due to a planar molecule.
         if not all(np.isfinite(x) for x in start):
             return self
         if np.allclose(target, [0, 0, 0], atol=1e-15):
             raise ValueError(
-                'target has a magnitude of 0. It is therefore not '
-                'possible to calculate an angle.'
+                "target has a magnitude of 0. It is therefore not "
+                "possible to calculate an angle."
             )
 
         self._with_displacement(-origin)
 
         # 1. Remove any component of the start and target vectors long
         # the axis. This puts them both on the same plane.
         # 2. Calculate the angle between them.
         # 3. Apply the rotation.
-        tstart = start - np.dot(start, axis)*axis
+        tstart = start - np.dot(start, axis) * axis
 
         # If `tstart` is 0, it is parallel to the rotation axis, stop.
         if np.allclose(tstart, [0, 0, 0], 1e-8):
             self._with_displacement(origin)
             return self
 
-        tend = target - np.dot(target, axis)*axis
+        tend = target - np.dot(target, axis) * axis
         # If `tend` is 0, it is parallel to the rotation axis, stop.
         if np.allclose(tend, [0, 0, 0], 1e-8):
             self._with_displacement(origin)
             return self
 
         angle = vector_angle(tstart, tend)
 
         projection = tstart @ np.cross(axis, tend)
         if projection > 0:
-            angle = 2*np.pi - angle
+            angle = 2 * np.pi - angle
 
         rotation_matrix = rotation_matrix_arbitrary_axis(angle, axis)
         self._position_matrix = rotation_matrix @ self._position_matrix
         self._with_displacement(origin)
         return self
 
     def with_rotation_to_minimize_angle(
         self,
         start: np.ndarray,
         target: np.ndarray,
         axis: np.ndarray,
         origin: np.ndarray,
-    ) -> Molecule:
+    ) -> typing.Self:
         """
         Return a rotated clone.
 
         The clone is rotated by the rotation required to minimize
         the angle between `start` and `target`.
 
         Note that this function will not necessarily overlay the
@@ -383,15 +362,15 @@
                 unit magnitude.
 
             origin:
                 The origin about which the rotation happens.
 
         Returns:
 
-            A rotated clone.
+            Molecule: A rotated clone.
 
         Raises:
 
             :class:`ValueError`
                 If `target` has a magnitude of 0. In this case it is
                 not possible to calculate an angle between `start` and
                 `target`.
@@ -401,91 +380,88 @@
         return self.clone()._with_rotation_to_minimize_angle(
             start=start,
             target=target,
             axis=axis,
             origin=origin,
         )
 
-    def _clone(self: _T) -> _T:
+    def _clone(self) -> typing.Self:
         clone = self.__class__.__new__(self.__class__)
         Molecule.__init__(
             self=clone,
             atoms=self._atoms,
             bonds=self._bonds,
             position_matrix=self._position_matrix.T,
         )
         return clone
 
-    def clone(self) -> Molecule:
+    def clone(self) -> typing.Self:
         """
         Return a clone.
 
         Returns:
             The clone.
 
         """
 
         return self._clone()
 
     def get_atomic_positions(
         self,
-        atom_ids: typing.Optional[OneOrMany[int]] = None,
-    ) -> typing.Iterator[np.ndarray]:
+        atom_ids: int | Iterable[int] | None = None,
+    ) -> Iterator[np.ndarray]:
         """
         Yield the positions of atoms.
 
         Parameters:
 
-            atom_ids:
+            atom_ids (int | list[int] | None):
                 The ids of the atoms whose positions are desired.
-                If ``None``, then the positions of all atoms will be
-                yielded. Can be a single :class:`int`, if the position
-                of a single atom is desired.
+                If ``None``, all atoms are used.
 
         Yields:
 
             The x, y and z coordinates of an atom.
 
         """
 
         if atom_ids is None:
             atom_ids = range(len(self._atoms))
         elif isinstance(atom_ids, int):
-            atom_ids = (atom_ids, )
+            atom_ids = (atom_ids,)
         elif not isinstance(atom_ids, (list, tuple)):
             atom_ids = list(atom_ids)
 
         positions = self._position_matrix[:, atom_ids].T
         for atomic_position in positions:
             yield atomic_position
 
     def get_atoms(
         self,
-        atom_ids: typing.Optional[OneOrMany[int]] = None,
-    ) -> typing.Iterator[Atom]:
+        atom_ids: int | Iterable[int] | None = None,
+    ) -> Iterator[Atom]:
         """
         Yield the atoms in the molecule, ordered by id.
 
         Parameters:
 
-            atom_ids:
-                The ids of atoms to yield. Can be a single
-                :class:`int` if a single atom is wanted, or ``None`` if
-                all atoms are wanted.
+            atom_ids (int | list[int] | None):
+                The ids of atoms to yield. If ``None``, all
+                atoms are used.
 
         Yields:
 
             An atom in the molecule.
 
         """
 
         if atom_ids is None:
             atom_ids = range(len(self._atoms))
         elif isinstance(atom_ids, int):
-            atom_ids = (atom_ids, )
+            atom_ids = (atom_ids,)
 
         for atom_id in atom_ids:
             yield self._atoms[atom_id]
 
     def get_num_atoms(self) -> int:
         """
         Return the number of atoms in the molecule.
@@ -494,15 +470,15 @@
 
             The number of atoms in the molecule.
 
         """
 
         return len(self._atoms)
 
-    def get_bonds(self) -> typing.Iterator[Bond]:
+    def get_bonds(self) -> Iterator[Bond]:
         """
         Yield the bond in the molecule.
 
         Yields:
 
             A bond in the molecule.
 
@@ -521,26 +497,24 @@
 
         """
 
         return len(self._bonds)
 
     def get_centroid(
         self,
-        atom_ids: typing.Optional[OneOrMany[int]] = None,
+        atom_ids: int | Iterable[int] | None = None,
     ) -> np.ndarray:
         """
         Return the centroid.
 
         Parameters:
 
-            atom_ids:
+            atom_ids (int | list[int] | None):
                 The ids of atoms which are used to calculate the
-                centroid. Can be a single :class:`int`, if a single
-                atom is to be used, or ``None`` if all atoms are to be
-                used.
+                centroid. If ``None``, all atoms are used.
 
         Returns:
 
             The centroid of atoms specified by `atom_ids`.
 
         Raises:
 
@@ -548,40 +522,38 @@
                 If `atom_ids` has a length of ``0``.
 
         """
 
         if atom_ids is None:
             atom_ids = range(len(self._atoms))
         elif isinstance(atom_ids, int):
-            atom_ids = (atom_ids, )
+            atom_ids = (atom_ids,)
         elif not isinstance(atom_ids, (list, tuple)):
             atom_ids = list(atom_ids)
 
         if len(atom_ids) == 0:
-            raise ValueError('atom_ids was of length 0.')
+            raise ValueError("atom_ids was of length 0.")
 
         return np.divide(
             self._position_matrix[:, atom_ids].sum(axis=1),
-            len(atom_ids)
+            len(atom_ids),
         )
 
     def get_direction(
         self,
-        atom_ids: typing.Optional[OneOrMany[int]] = None,
+        atom_ids: int | Iterable[int] | None = None,
     ) -> np.ndarray:
         """
         Return a vector of best fit through the atoms.
 
         Parameters:
 
-            atom_ids:
+            atom_ids (int | list[int] | None):
                 The ids of atoms which should be used to calculate the
-                vector. Can be a single :class:`int`, if a single atom
-                is to be used, or ``None``, if all atoms are to be
-                used.
+                vector. If ``None``, all atoms are used.
 
         Returns:
 
             The vector of best fit.
 
         Raises:
 
@@ -589,44 +561,42 @@
                 If `atom_ids` has a length of ``0``.
 
         """
 
         if atom_ids is None:
             atom_ids = range(len(self._atoms))
         elif isinstance(atom_ids, int):
-            atom_ids = (atom_ids, )
+            atom_ids = (atom_ids,)
         elif not isinstance(atom_ids, (list, tuple)):
             atom_ids = list(atom_ids)
 
         if len(atom_ids) == 0:
-            raise ValueError('atom_ids was of length 0.')
+            raise ValueError("atom_ids was of length 0.")
 
         pos = self._position_matrix[:, atom_ids].T
         return np.around(
             a=np.linalg.svd(pos - pos.mean(axis=0))[-1][0],
             decimals=14,
         )
 
     def get_maximum_diameter(
         self,
-        atom_ids: typing.Optional[OneOrMany[int]] = None,
+        atom_ids: int | Iterable[int] | None = None,
     ) -> float:
         """
         Return the maximum diameter.
 
         This method does not account for the van der Waals radius of
         atoms.
 
         Parameters:
 
-            atom_ids:
+            atom_ids (int | list[int] | None):
                 The ids of atoms which are considered when looking for
-                the maximum diameter. Can be a single :class:`int`, if
-                a single atom is to be used, or ``None``, if all atoms
-                are to be used.
+                the maximum diameter. If ``None``, all atoms are used.
 
         Returns:
 
             The maximum diameter in the molecule.
 
         Raises:
 
@@ -634,38 +604,36 @@
                 If `atom_ids` has a length of ``0``.
 
         """
 
         if atom_ids is None:
             atom_ids = range(len(self._atoms))
         elif isinstance(atom_ids, int):
-            atom_ids = (atom_ids, )
+            atom_ids = (atom_ids,)
         elif not isinstance(atom_ids, (list, tuple)):
             atom_ids = list(atom_ids)
 
         if len(atom_ids) == 0:
-            raise ValueError('atom_ids was of length 0.')
+            raise ValueError("atom_ids was of length 0.")
 
         coords = self._position_matrix[:, atom_ids]
         return float(euclidean(coords.min(axis=1), coords.max(axis=1)))
 
     def get_plane_normal(
         self,
-        atom_ids: typing.Optional[OneOrMany[int]] = None,
+        atom_ids: int | Iterable[int] | None = None,
     ) -> np.ndarray:
         """
         Return the normal to the plane of best fit.
 
         Parameters:
 
-            atom_ids:
+            atom_ids (int | list[int] | None):
                 The ids of atoms which should be used to calculate the
-                plane. Can be a single :class:`int`, if a
-                single atom is to be used, or ``None``, if all atoms
-                are to be used.
+                plane. If ``None``, all atoms are used.
 
         Returns:
 
             Vector orthonormal to the plane of the molecule.
 
         Raises:
 
@@ -673,20 +641,20 @@
                 If `atom_ids` has a length of ``0``.
 
         """
 
         if atom_ids is None:
             atom_ids = range(len(self._atoms))
         elif isinstance(atom_ids, int):
-            atom_ids = (atom_ids, )
+            atom_ids = (atom_ids,)
         elif not isinstance(atom_ids, (list, tuple)):
             atom_ids = list(atom_ids)
 
         if len(atom_ids) == 0:
-            raise ValueError('atom_ids was of length 0.')
+            raise ValueError("atom_ids was of length 0.")
 
         pos = self._position_matrix[:, atom_ids].T
         centroid = self.get_centroid(atom_ids)
         return np.around(np.linalg.svd(pos - centroid)[-1][2, :], 14)
 
     def get_position_matrix(self) -> np.ndarray:
         """
@@ -698,79 +666,73 @@
             x, y and z coordinates of an atom.
 
         """
 
         return np.array(self._position_matrix.T)
 
     def _with_centroid(
-        self: _T,
+        self,
         position: np.ndarray,
-        atom_ids: typing.Optional[OneOrMany[int]],
-    ) -> _T:
-
+        atom_ids: int | Iterable[int] | None,
+    ) -> typing.Self:
         centroid = self.get_centroid(atom_ids=atom_ids)
-        self._with_displacement(position-centroid)
+        self._with_displacement(position - centroid)
         return self
 
     def with_centroid(
         self,
         position: np.ndarray,
-        atom_ids: typing.Optional[OneOrMany[int]] = None,
-    ) -> Molecule:
+        atom_ids: int | Iterable[int] | None = None,
+    ) -> typing.Self:
         """
         Return a clone with its centroid at `position`.
 
         Parameters:
 
             position:
                 This array holds the position on which the centroid of
                 the clone is going to be placed.
 
-            atom_ids:
+            atom_ids (int | list[int] | None):
                 The ids of atoms which should have their centroid set
-                to `position`. Can be a single :class:`int`, if a
-                single atom is to be used, or ``None``, if all atoms
-                are to be used.
+                to `position`. If ``None``, all atoms are used.
 
         Returns:
 
-            A clone with its centroid at `position`.
+            Molecule: A clone with its centroid at `position`.
 
         """
 
         return self.clone()._with_centroid(position, atom_ids)
 
     def _with_position_matrix(
-        self: _T,
+        self,
         position_matrix: np.ndarray,
-    ) -> _T:
+    ) -> typing.Self:
         """
         Modify molecule.
 
         """
 
         self._position_matrix = np.array(position_matrix.T)
         return self
 
-    def with_position_matrix(
-        self,
-        position_matrix: np.ndarray,
-    ) -> Molecule:
+    def with_position_matrix(self, position_matrix: np.ndarray) -> typing.Self:
         """
         Return a clone with atomic positions set by `position_matrix`.
 
         Parameters:
 
             position_matrix:
                 The position matrix of the clone. The shape of the
                 matrix is ``(n, 3)``.
 
         Returns:
 
-            The clone.
+            Molecule: The clone.
 
         """
         return self.clone()._with_position_matrix(position_matrix)
 
     def to_rdkit_mol(self) -> rdkit.Mol:
         """
         Return an :mod:`rdkit` representation.
@@ -788,15 +750,16 @@
             mol.AddAtom(rdkit_atom)
 
         for bond in self._bonds:
             mol.AddBond(
                 beginAtomIdx=bond.get_atom1().get_id(),
                 endAtomIdx=bond.get_atom2().get_id(),
                 order=(
-                    rdkit.BondType.DATIVE if bond.get_order() == 9
+                    rdkit.BondType.DATIVE
+                    if bond.get_order() == 9
                     else rdkit.BondType(bond.get_order())
                 ),
             )
 
         mol = mol.GetMol()
         rdkit_conf = rdkit.Conformer(len(self._atoms))
         for atom_id, atom_coord in enumerate(self._position_matrix.T):
@@ -804,16 +767,16 @@
             mol.GetAtomWithIdx(atom_id).SetNoImplicit(True)
         mol.AddConformer(rdkit_conf)
         return mol
 
     def with_structure_from_file(
         self,
         path: str,
-        extension: typing.Optional[str] = None,
-    ) -> Molecule:
+        extension: str | None = None,
+    ) -> typing.Self:
         """
         Return a clone, with its structure taken from a file.
 
         Multiple file types are supported, namely:
 
         #. ``.mol``, ``.sdf`` - MDL V2000 and V3000 files
         #. ``.xyz`` - XYZ files
@@ -829,73 +792,76 @@
 
             extension:
                 If you want to treat the file as though it has a
                 particular extension, put it here. Include the dot.
 
         Returns:
 
-            A clone with atomic positions found in `path`.
+            Molecule: A clone with atomic positions found in `path`.
 
         """
 
         if extension is None:
             _, extension = os.path.splitext(path)
 
         return {
-            '.mol': updaters._with_structure_from_mol,
-            '.sdf': updaters._with_structure_from_mol,
-            '.mae': updaters._with_structure_from_mae,
-            '.xyz': updaters._with_structure_from_xyz,
-            '.coord': updaters._with_structure_from_turbomole,
-            '.pdb': updaters._with_structure_from_pdb,
+            ".mol": mdl_mol._with_structure_from_mol,
+            ".sdf": mdl_mol._with_structure_from_mol,
+            ".mae": mae._with_structure_from_mae,
+            ".xyz": xyz._with_structure_from_xyz,
+            ".coord": turbomole._with_structure_from_turbomole,
+            ".pdb": pdb._with_structure_from_pdb,
         }[extension](self.clone(), path)
 
-    def with_canonical_atom_ordering(self) -> Molecule:
+    def with_canonical_atom_ordering(self) -> typing.Self:
         """
         Return a clone, with canonically ordered atoms.
 
         Returns:
 
             The clone.
 
         """
 
         return self.clone()._with_canonical_atom_ordering()
 
-    def _with_canonical_atom_ordering(self: _T) -> _T:
+    def _with_canonical_atom_ordering(self) -> typing.Self:
         """
         Modify the molecule.
 
         """
 
         atom_map = {
             atom.get_id(): atom.with_id(new_id)
             for new_id, atom in zip(
                 rdkit.CanonicalRankAtoms(self.to_rdkit_mol()),
                 self._atoms,
             )
         }
-        self._atoms = tuple(sorted(
-            atom_map.values(),
-            key=lambda atom: atom.get_id()
-        ))
-        self._bonds = tuple(sorted(
-            (
-                sort_bond_atoms_by_id(bond.with_atoms(atom_map))
-                for bond in self._bonds
-            ),
-            key=get_bond_atom_ids,
-        ))
-        old_ids = {
-            atom.get_id(): old_id for old_id, atom in atom_map.items()
-        }
-        self._position_matrix = np.array(np.array([
-            self._position_matrix.T[old_ids[new_id]]
-            for new_id in range(len(self._atoms))
-        ]).T)
+        self._atoms = tuple(
+            sorted(atom_map.values(), key=lambda atom: atom.get_id())
+        )
+        self._bonds = tuple(
+            sorted(
+                (
+                    sort_bond_atoms_by_id(bond.with_atoms(atom_map))
+                    for bond in self._bonds
+                ),
+                key=get_bond_atom_ids,
+            )
+        )
+        old_ids = {atom.get_id(): old_id for old_id, atom in atom_map.items()}
+        self._position_matrix = np.array(
+            np.array(
+                [
+                    self._position_matrix.T[old_ids[new_id]]
+                    for new_id in range(len(self._atoms))
+                ]
+            ).T
+        )
         return self
 
     def get_canonical_atom_ids(self) -> dict[int, int]:
         """
         Map the id of each atom to its id under canonical ordering.
 
         Returns:
@@ -911,16 +877,16 @@
                 rdkit.CanonicalRankAtoms(self.to_rdkit_mol()),
             )
         }
 
     def write(
         self,
         path: str,
-        atom_ids: typing.Optional[OneOrMany[int]] = None,
-    ) -> Molecule:
+        atom_ids: int | Iterable[int] | None = None,
+    ) -> typing.Self:
         """
         Write the structure to a file.
 
         This function will write the format based on the extension
         of `path`.
 
         #. ``.mol``, ``.sdf`` - MDL V3000 MOL file
@@ -928,34 +894,33 @@
         #. ``.pdb`` - PDB file
 
         Parameters:
 
             path:
                 The `path` to which the molecule should be written.
 
-            atom_ids:
-                The atom ids of atoms to write. Can be a single
-                :class:`int`, if a single atom is to be used, or
-                ``None``, if all atoms are to be used. If you use this
-                parameter, the atom ids in the file may not correspond
-                to the atom ids in the molecule.
+            atom_ids (int | list[int] | None):
+                The atom ids of atoms to write. If ``None``,
+                all atoms are used. If you use this parameter, the
+                atom ids in the file may not correspond to the atom
+                ids in the molecule.
 
         Returns:
 
-            The molecule.
+            Molecule: The molecule.
 
         """
 
         _, extension = os.path.splitext(path)
         {
-            '.mol': writers._write_mdl_mol_file,
-            '.sdf': writers._write_mdl_mol_file,
-            '.xyz': writers._write_xyz_file,
-            '.pdb': writers._write_pdb_file,
+            ".mol": _write_mdl_mol_file,
+            ".sdf": _write_mdl_mol_file,
+            ".xyz": _write_xyz_file,
+            ".pdb": _write_pdb_file,
         }[extension](self, path, atom_ids)
         return self
 
     def __str__(self) -> str:
         return repr(self)
 
     def __repr__(self) -> str:
-        return f'<{self.__class__.__name__} at {id(self)}>'
+        return f"<{self.__class__.__name__} at {id(self)}>"
```

### Comparing `stk-2022.6.17.0/src/stk/molecular/molecules/molecule/utilities/updaters/mae.py` & `stk-2023.7.5.0/src/stk/_internal/utilities/updaters/mae.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,15 +1,15 @@
 """
 MAE Updating Utilities
 ======================
 
 """
 
 
-from stk.utilities import mol_from_mae_file
+from stk._internal.utilities.utilities import mol_from_mae_file
 
 
 def _with_structure_from_mae(self, path):
     """
     Change structure to match an ``.mae`` file.
 
     Parameters
```

### Comparing `stk-2022.6.17.0/src/stk/molecular/molecules/molecule/utilities/updaters/mdl_mol.py` & `stk-2023.7.5.0/src/stk/_internal/utilities/updaters/mdl_mol.py`

 * *Files 3% similar despite different names*

```diff
@@ -2,15 +2,15 @@
 MDL Mol Updating Utilities
 ==========================
 
 """
 
 import rdkit.Chem.AllChem as rdkit
 
-from stk.utilities import remake
+from stk._internal.utilities.utilities import remake
 
 
 def _with_structure_from_mol(self, path):
     """
     Change structure to match a ``.mol`` file.
 
     Parameters
```

### Comparing `stk-2022.6.17.0/src/stk/molecular/molecules/molecule/utilities/updaters/pdb.py` & `stk-2023.7.5.0/src/stk/_internal/utilities/updaters/pdb.py`

 * *Files 3% similar despite different names*

```diff
@@ -2,15 +2,15 @@
 PDB Updating Utilities
 ======================
 
 """
 
 import rdkit.Chem.AllChem as rdkit
 
-from stk.utilities import remake
+from stk._internal.utilities.utilities import remake
 
 
 def _with_structure_from_pdb(self, path):
     """
     Change structure to match a ``.pdb`` file.
 
     Parameters
```

### Comparing `stk-2022.6.17.0/src/stk/molecular/molecules/molecule/utilities/updaters/turbomole.py` & `stk-2023.7.5.0/src/stk/_internal/utilities/updaters/turbomole.py`

 * *Files 2% similar despite different names*

```diff
@@ -2,15 +2,15 @@
 Turbomole Updating Utilities
 ============================
 
 """
 
 import numpy as np
 
-from stk.utilities import periodic_table
+from stk._internal.utilities.utilities import periodic_table
 
 
 class _CoordSection:
     """
     Holds the coord section of a turbomole file.
 
     """
@@ -71,19 +71,21 @@
         for line in lines:
             x, y, z, element = line.split()
 
             if element.isnumeric():
                 element = periodic_table[int(element)]
 
             elements.append(element)
-            position_matrix.append([
-                float(x)*bohr_to_ang,
-                float(y)*bohr_to_ang,
-                float(z)*bohr_to_ang,
-            ])
+            position_matrix.append(
+                [
+                    float(x) * bohr_to_ang,
+                    float(y) * bohr_to_ang,
+                    float(z) * bohr_to_ang,
+                ]
+            )
 
         obj._elements = tuple(elements)
         obj._position_matrix = np.array(position_matrix)
         return obj
 
     def get_position_matrix(self):
         """
@@ -151,34 +153,33 @@
         currently supported.
 
     :class:`RuntimeError`
         If no coord section in found in `path`.
 
     """
 
-    with open(path, 'r') as f:
+    with open(path, "r") as f:
         content = f.readlines()
 
     for line_number, line in enumerate(content):
-        if '$coord' in line:
-
-            lines = content[line_number+1:line_number+1+num_atoms]
+        if "$coord" in line:
+            lines = content[line_number + 1 : line_number + 1 + num_atoms]
 
-            if 'angs' in line:
+            if "angs" in line:
                 return _CoordSection(lines)
 
-            elif 'frac' in line:
+            elif "frac" in line:
                 raise RuntimeError(
-                    f'{path} uses fractional coordinates, which are '
-                    'not currently supported.'
+                    f"{path} uses fractional coordinates, which are "
+                    "not currently supported."
                 )
 
             return _CoordSection.init_bohr(lines)
 
-    raise RuntimeError(f'No coord section found in {path}.')
+    raise RuntimeError(f"No coord section found in {path}.")
 
 
 def _with_structure_from_turbomole(self, path):
     """
     Update the structure with one taken from a Turbomole file.
 
     Note that coordinates in ``.coord`` files can be given in Bohr or
@@ -209,24 +210,26 @@
     """
 
     num_atoms = len(self._atoms)
     section = _get_coord_section(path, num_atoms)
 
     if section.get_num_atoms() != num_atoms:
         raise RuntimeError(
-            f'The number of atoms in {path}, '
-            f'{section.get_num_atoms()}, does not match the number '
-            f'of atoms in the molecule, {num_atoms}.'
+            f"The number of atoms in {path}, "
+            f"{section.get_num_atoms()}, does not match the number "
+            f"of atoms in the molecule, {num_atoms}."
         )
 
-    for atom_id, (element, atom) in enumerate(zip(
-        section.get_elements(),
-        self._atoms,
-    )):
+    for atom_id, (element, atom) in enumerate(
+        zip(
+            section.get_elements(),
+            self._atoms,
+        )
+    ):
         if element != atom.__class__.__name__:
             raise RuntimeError(
-                f'The element of atom {atom_id} in {path}, '
-                f'{element}, does not match the element in the '
-                f'molecule, {atom.__class__.__name__}.'
+                f"The element of atom {atom_id} in {path}, "
+                f"{element}, does not match the element in the "
+                f"molecule, {atom.__class__.__name__}."
             )
 
     return self._with_position_matrix(section.get_position_matrix())
```

### Comparing `stk-2022.6.17.0/src/stk/molecular/molecules/molecule/utilities/updaters/xyz.py` & `stk-2023.7.5.0/src/stk/_internal/utilities/updaters/xyz.py`

 * *Files 10% similar despite different names*

```diff
@@ -2,15 +2,15 @@
 XYZ Updating Utilities
 ======================
 
 """
 
 import numpy as np
 
-from stk.utilities import periodic_table
+from stk._internal.utilities.utilities import periodic_table
 
 
 def _with_structure_from_xyz(self, path):
     """
     Return a clone, with its structure taken from an ``.xyz`` file.
 
     Parameters
@@ -29,47 +29,45 @@
     :class:`RuntimeError`
         If the number of atoms in the file does not match the
         number of atoms in the molecule or if atom elements in the
         file do not agree with the atom elements in the molecule.
 
     """
 
-    with open(path, 'r') as f:
+    with open(path, "r") as f:
         atom_count, _, *content = f.readlines()
 
     # Check the atom count is correct.
     num_atoms = len(self._atoms)
     if int(atom_count) != num_atoms:
         raise RuntimeError(
-            f'The number of atoms in the xyz file, {atom_count}, '
-            'does not match the number of atoms in the '
-            f'molecule, {num_atoms}.'
+            f"The number of atoms in the xyz file, {atom_count}, "
+            "does not match the number of atoms in the "
+            f"molecule, {num_atoms}."
         )
 
     # Save all the coords in the file.
     new_coords = []
     for i, line in enumerate(content):
         element, *coords = line.split()
         # Handle XYZ files with capitilisation of element symbols.
         element = element.title()
         if element.isnumeric():
             element = periodic_table[int(element)]
 
         if element != self._atoms[i].__class__.__name__:
-            raise RuntimeError(
-                f'Atom {i} element does not match file.'
-            )
+            raise RuntimeError(f"Atom {i} element does not match file.")
 
         new_coords.append([float(i) for i in coords])
 
     # Check that the correct number of atom
     # lines was present in the file.
-    if i+1 != num_atoms:
+    if i + 1 != num_atoms:
         raise RuntimeError(
-            f'The number of atom lines in the xyz file, {i+1}, '
-            'does not match the number of atoms in the '
-            f'molecule, {num_atoms}.'
+            f"The number of atom lines in the xyz file, {i+1}, "
+            "does not match the number of atoms in the "
+            f"molecule, {num_atoms}."
         )
 
     # Update the structure.
     new_coords = np.array(new_coords)
     return self._with_position_matrix(new_coords)
```

### Comparing `stk-2022.6.17.0/src/stk/molecular/molecules/molecule/utilities/writers/mdl_mol.py` & `stk-2023.7.5.0/src/stk/_internal/utilities/writers/mdl_mol.py`

 * *Files 13% similar despite different names*

```diff
@@ -24,15 +24,15 @@
 
     Returns
     -------
     None : :class:`NoneType`
 
     """
 
-    with open(path, 'w') as f:
+    with open(path, "w") as f:
         f.write(_to_mdl_mol_block(self, atom_ids))
 
 
 def _to_mdl_mol_block(self, atom_ids=None):
     """
     Return a V3000 mol block of the molecule.
 
@@ -49,57 +49,57 @@
         The V3000 mol block representing the molecule.
 
     """
 
     if atom_ids is None:
         atom_ids = range(len(self._atoms))
     elif isinstance(atom_ids, int):
-        atom_ids = (atom_ids, )
+        atom_ids = (atom_ids,)
 
     atom_lines = []
     # This set gets used by bonds.
     id_map = {}
     for new_atom_id, old_atom_id in enumerate(atom_ids, 1):
         id_map[old_atom_id] = new_atom_id
 
         x, y, z = self._position_matrix[:, old_atom_id]
         atom = self._atoms[old_atom_id]
         symbol = atom.__class__.__name__
         charge = atom.get_charge()
-        charge = f' CHG={charge}' if charge else ''
+        charge = f" CHG={charge}" if charge else ""
         atom_lines.append(
-            f'M  V30 {new_atom_id} {symbol} {x:.4f} '
-            f'{y:.4f} {z:.4f} 0{charge}\n'
+            f"M  V30 {new_atom_id} {symbol} {x:.4f} "
+            f"{y:.4f} {z:.4f} 0{charge}\n"
         )
-    atom_block = ''.join(atom_lines)
+    atom_block = "".join(atom_lines)
 
     bond_lines = []
     for bond in self._bonds:
         a1 = bond.get_atom1().get_id()
         a2 = bond.get_atom2().get_id()
         if a1 in id_map and a2 in id_map:
             bond_lines.append(
-                f'M  V30 {len(bond_lines)+1} '
-                f'{int(bond.get_order())} '
-                f'{id_map[a1]} {id_map[a2]}\n'
+                f"M  V30 {len(bond_lines)+1} "
+                f"{int(bond.get_order())} "
+                f"{id_map[a1]} {id_map[a2]}\n"
             )
 
     num_bonds = len(bond_lines)
-    bond_block = ''.join(bond_lines)
+    bond_block = "".join(bond_lines)
     return (
-        '\n'
-        '     RDKit          3D\n'
-        '\n'
-        '  0  0  0  0  0  0  0  0  0  0999 V3000\n'
-        'M  V30 BEGIN CTAB\n'
-        f'M  V30 COUNTS {len(id_map)} {num_bonds} 0 0 0\n'
-        'M  V30 BEGIN ATOM\n'
-        f'{atom_block}'
-        'M  V30 END ATOM\n'
-        'M  V30 BEGIN BOND\n'
-        f'{bond_block}'
-        'M  V30 END BOND\n'
-        'M  V30 END CTAB\n'
-        'M  END\n'
-        '\n'
-        '$$$$\n'
+        "\n"
+        "     RDKit          3D\n"
+        "\n"
+        "  0  0  0  0  0  0  0  0  0  0999 V3000\n"
+        "M  V30 BEGIN CTAB\n"
+        f"M  V30 COUNTS {len(id_map)} {num_bonds} 0 0 0\n"
+        "M  V30 BEGIN ATOM\n"
+        f"{atom_block}"
+        "M  V30 END ATOM\n"
+        "M  V30 BEGIN BOND\n"
+        f"{bond_block}"
+        "M  V30 END BOND\n"
+        "M  V30 END CTAB\n"
+        "M  END\n"
+        "\n"
+        "$$$$\n"
     )
```

### Comparing `stk-2022.6.17.0/src/stk/molecular/molecules/molecule/utilities/writers/pdb.py` & `stk-2023.7.5.0/src/stk/_internal/utilities/writers/pdb.py`

 * *Files 10% similar despite different names*

```diff
@@ -27,54 +27,52 @@
     None : :class:`NoneType`
 
     """
 
     if atom_ids is None:
         atom_ids = range(len(self._atoms))
     elif isinstance(atom_ids, int):
-        atom_ids = (atom_ids, )
+        atom_ids = (atom_ids,)
 
     lines = []
     atom_counts = {}
-    hetatm = 'HETATM'
-    alt_loc = ''
-    res_name = 'UNL'
-    chain_id = ''
-    res_seq = '1'
-    i_code = ''
-    occupancy = '1.00'
-    temp_factor = '0.00'
+    hetatm = "HETATM"
+    alt_loc = ""
+    res_name = "UNL"
+    chain_id = ""
+    res_seq = "1"
+    i_code = ""
+    occupancy = "1.00"
+    temp_factor = "0.00"
 
     coords = self._position_matrix
     # This set will be used by bonds.
     atoms = set()
     for atom in atom_ids:
         atoms.add(atom)
 
-        serial = atom+1
+        serial = atom + 1
         element = self._atoms[atom].__class__.__name__
         atom_counts[element] = atom_counts.get(element, 0) + 1
-        name = f'{element}{atom_counts[element]}'
+        name = f"{element}{atom_counts[element]}"
         # Make sure the coords are no more than 8 columns wide
         # each.
         x, y, z = (i for i in coords[:, atom])
         lines.append(
-            f'{hetatm:<6}{serial:>5} {name:<4}'
-            f'{alt_loc:<1}{res_name:<3} {chain_id:<1}'
-            f'{res_seq:>4}{i_code:<1}   '
-            f' {x:>7.3f} {y:>7.3f} {z:>7.3f}'
-            f'{occupancy:>6}{temp_factor:>6}          '
-            f'{element:>2}{self._atoms[atom].get_charge():>2}\n'
+            f"{hetatm:<6}{serial:>5} {name:<4}"
+            f"{alt_loc:<1}{res_name:<3} {chain_id:<1}"
+            f"{res_seq:>4}{i_code:<1}   "
+            f" {x:>7.3f} {y:>7.3f} {z:>7.3f}"
+            f"{occupancy:>6}{temp_factor:>6}          "
+            f"{element:>2}{self._atoms[atom].get_charge():>2}\n"
         )
 
-    conect = 'CONECT'
+    conect = "CONECT"
     for bond in self._bonds:
         a1 = bond.get_atom1().get_id()
         a2 = bond.get_atom2().get_id()
         if a1 in atoms and a2 in atoms:
-            lines.append(
-                f'{conect:<6}{a1+1:>5}{a2+1:>5}               \n'
-            )
-
-    lines.append('END\n')
-    with open(path, 'w') as f:
-        f.write(''.join(lines))
+            lines.append(f"{conect:<6}{a1+1:>5}{a2+1:>5}               \n")
+
+    lines.append("END\n")
+    with open(path, "w") as f:
+        f.write("".join(lines))
```

### Comparing `stk-2022.6.17.0/src/stk/molecular/molecules/molecule/utilities/writers/xyz.py` & `stk-2023.7.5.0/src/stk/_internal/utilities/writers/xyz.py`

 * *Files 13% similar despite different names*

```diff
@@ -27,19 +27,19 @@
     None : :class:`NoneType`
 
     """
 
     if atom_ids is None:
         atom_ids = range(len(self._atoms))
     elif isinstance(atom_ids, int):
-        atom_ids = (atom_ids, )
+        atom_ids = (atom_ids,)
 
     content = [0]
     for i, atom_id in enumerate(atom_ids, 1):
         x, y, z = self._position_matrix[:, atom_id]
         symbol = self._atoms[atom_id].__class__.__name__
-        content.append(f'{symbol} {x:f} {y:f} {z:f}\n')
+        content.append(f"{symbol} {x:f} {y:f} {z:f}\n")
     # Set first line to the atom_count.
-    content[0] = f'{i}\n\n'
+    content[0] = f"{i}\n\n"
 
-    with open(path, 'w') as xyz:
-        xyz.write(''.join(content))
+    with open(path, "w") as xyz:
+        xyz.write("".join(content))
```

### Comparing `stk-2022.6.17.0/src/stk/molecular/molecules/utilities.py` & `stk-2023.7.5.0/src/stk/_internal/utilities/molecule.py`

 * *Files 16% similar despite different names*

```diff
@@ -19,15 +19,17 @@
             atom2=bond.get_atom1(),
             order=bond.get_order(),
             periodicity=bond.get_periodicity(),
         )
 
 
 def get_bond_atom_ids(bond):
-    return sorted((
-        bond.get_atom1().get_id(),
-        bond.get_atom2().get_id(),
-    ))
+    return sorted(
+        (
+            bond.get_atom1().get_id(),
+            bond.get_atom2().get_id(),
+        )
+    )
 
 
 def get_bond_info_atom_ids(bond_info):
     return get_bond_atom_ids(bond_info.get_bond())
```

### Comparing `stk-2022.6.17.0/src/stk/molecular/periodic_info.py` & `stk-2023.7.5.0/src/stk/_internal/periodic_info.py`

 * *Files 2% similar despite different names*

```diff
@@ -8,15 +8,15 @@
 
 from __future__ import annotations
 
 import logging
 
 import numpy as np
 
-from ..utilities import cap_absolute_value
+from stk._internal.utilities.utilities import cap_absolute_value
 
 logger = logging.getLogger(__name__)
 
 
 class PeriodicInfo:
     """
     Periodic cell information for periodic systems.
@@ -60,30 +60,29 @@
         self._cell_matrix = (
             self._vector_1,
             self._vector_2,
             self._vector_3,
         )
 
         a, b, c = tuple(
-            np.sqrt(np.sum(i ** 2)).tolist() for i in self._cell_matrix
+            np.sqrt(np.sum(i**2)).tolist() for i in self._cell_matrix
         )
         self._a = a
         self._b = b
         self._c = c
 
         lengths = (a, b, c)
         angles = np.zeros(3)
         for i in range(3):
             j = (i + 1) % 3
             k = (i + 2) % 3
             angles[i] = cap_absolute_value(
                 value=(
-                    np.dot(
-                        self._cell_matrix[j], self._cell_matrix[k]
-                    ) / (lengths[j] * lengths[k])
+                    np.dot(self._cell_matrix[j], self._cell_matrix[k])
+                    / (lengths[j] * lengths[k])
                 ),
             )
         angles = np.arccos(angles) * 180.0 / np.pi
 
         alpha, beta, gamma = angles
         self._alpha = alpha
         self._beta = beta
@@ -232,16 +231,15 @@
             *Gamma* angle of cell in degrees.
 
         """
 
         return self._gamma
 
     def __str__(self) -> str:
-
         return (
-            f'{self.__class__.__name__}(a={self._a}, b={self._b}, '
-            f'c={self._c}, alpha={self._alpha}, beta={self._beta}, '
-            f'gamma={self._gamma})'
+            f"{self.__class__.__name__}(a={self._a}, b={self._b}, "
+            f"c={self._c}, alpha={self._alpha}, beta={self._beta}, "
+            f"gamma={self._gamma})"
         )
 
     def __repr__(self) -> str:
         return str(self)
```

### Comparing `stk-2022.6.17.0/src/stk/molecular/reactions/factories/dative_reaction_factory.py` & `stk-2023.7.5.0/src/stk/_internal/reaction_factories/dative_reaction_factory.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,14 +1,14 @@
 """
 Dative Reaction Factory
 =======================
 
 """
 
-from ..reactions import DativeReaction
+from ..reactions.dative_reaction.dative_reaction import DativeReaction
 from .reaction_factory import ReactionFactory
 
 
 class DativeReactionFactory(ReactionFactory):
     """
     Create :class:`.DativeReaction` instances.
 
@@ -42,11 +42,8 @@
         )
         return DativeReaction(reaction)
 
     def __str__(self):
         return repr(self)
 
     def __repr__(self):
-        return (
-            f'{self.__class__.__name__}'
-            f'({self._reaction_factory})'
-        )
+        return f"{self.__class__.__name__}" f"({self._reaction_factory})"
```

### Comparing `stk-2022.6.17.0/src/stk/molecular/reactions/factories/generic_reaction_factory.py` & `stk-2023.7.5.0/src/stk/_internal/reaction_factories/generic_reaction_factory.py`

 * *Files 16% similar despite different names*

```diff
@@ -1,62 +1,63 @@
 """
 Generic Reaction Factory
 ========================
 
 """
 
-from ...functional_groups import (
-    Aldehyde,
-    Alkene,
-    Alkyne,
-    Amide,
-    PrimaryAmino,
-)
-from ..reactions import OneOneReaction, OneTwoReaction, TwoTwoReaction
+from stk._internal.functional_groups.aldehyde import Aldehyde
+from stk._internal.functional_groups.alkene import Alkene
+from stk._internal.functional_groups.alkyne import Alkyne
+from stk._internal.functional_groups.amide import Amide
+from stk._internal.functional_groups.primary_amino import PrimaryAmino
+from stk._internal.reactions.one_one_reaction import OneOneReaction
+from stk._internal.reactions.one_two_reaction import OneTwoReaction
+from stk._internal.reactions.two_two_reaction import TwoTwoReaction
+
 from .reaction_factory import ReactionFactory
 
 # Impose the same interface on all reaction initializers.
 
 
 def _one_one_reaction(
     construction_state,
     functional_group1,
     functional_group2,
     bond_order,
-    periodicity
+    periodicity,
 ):
     return OneOneReaction(
         functional_group1=functional_group1,
         functional_group2=functional_group2,
         bond_order=bond_order,
         periodicity=periodicity,
     )
 
 
 def _one_two_reaction(
     construction_state,
     functional_group1,
     functional_group2,
     bond_order,
-    periodicity
+    periodicity,
 ):
     return OneTwoReaction(
         functional_group1=functional_group1,
         functional_group2=functional_group2,
         bond_order=bond_order,
         periodicity=periodicity,
     )
 
 
 def _two_two_reaction(
     construction_state,
     functional_group1,
     functional_group2,
     bond_order,
-    periodicity
+    periodicity,
 ):
     return TwoTwoReaction(
         construction_state=construction_state,
         functional_group1=functional_group1,
         functional_group2=functional_group2,
         bond_order=bond_order,
         periodicity=periodicity,
@@ -195,10 +196,10 @@
         return frozenset(map(type, functional_groups))
 
     def __str__(self):
         return repr(self)
 
     def __repr__(self):
         bond_orders = (
-            '' if self._default_bond_orders else f'{self._bond_orders}'
+            "" if self._default_bond_orders else f"{self._bond_orders}"
         )
-        return f'{self.__class__.__name__}({bond_orders})'
+        return f"{self.__class__.__name__}({bond_orders})"
```

### Comparing `stk-2022.6.17.0/src/stk/molecular/reactions/factories/reaction_factory.py` & `stk-2023.7.5.0/src/stk/_internal/reaction_factories/reaction_factory.py`

 * *Files 12% similar despite different names*

```diff
@@ -1,24 +1,7 @@
-"""
-Reaction Factory
-================
-
-.. toctree::
-    :maxdepth: 2
-
-    Generic Reaction Factory <\
-stk.molecular.reactions.factories.generic_reaction_factory\
->
-    Dative Reaction Factory <\
-stk.molecular.reactions.factories.dative_reaction_factory\
->
-
-"""
-
-
 class ReactionFactory:
     """
     An abstract base class for reaction factories.
 
     Reaction factories are responsible for creating :class:`.Reaction`
     instances. Different subclasses of this class will provide
     different options for creating :class:`.Reaction` instances.
```

### Comparing `stk-2022.6.17.0/src/stk/molecular/reactions/reactions/dative_reaction/dative_reaction.py` & `stk-2023.7.5.0/src/stk/_internal/reactions/dative_reaction/dative_reaction.py`

 * *Files 7% similar despite different names*

```diff
@@ -1,15 +1,16 @@
 """
 Dative Reaction
 ===============
 
 """
 
-from ....bonds import Bond
-from ..reaction import Reaction
+from stk._internal.bond import Bond
+
+from ..reaction.reaction import Reaction
 from .utilities import is_metal
 
 
 class DativeReaction(Reaction):
     """
     A reaction between two functional groups.
```

### Comparing `stk-2022.6.17.0/src/stk/molecular/reactions/reactions/one_one_reaction.py` & `stk-2023.7.5.0/src/stk/_internal/reactions/one_one_reaction.py`

 * *Files 16% similar despite different names*

```diff
@@ -1,15 +1,16 @@
 """
 One-One Reaction
 ================
 
 """
 
-from ...bonds import Bond
-from .reaction import Reaction
+from stk._internal.bond import Bond
+
+from .reaction.reaction import Reaction
 
 
 class OneOneReaction(Reaction):
     """
     A reaction between two functional groups, each with 1 bonder atom.
 
     The reaction creates a bond between the *bonder* atoms, and deletes
```

### Comparing `stk-2022.6.17.0/src/stk/molecular/reactions/reactions/one_two_reaction.py` & `stk-2023.7.5.0/src/stk/_internal/reactions/one_two_reaction.py`

 * *Files 3% similar despite different names*

```diff
@@ -2,16 +2,17 @@
 One-Two Reaction
 ================
 
 """
 
 import itertools as it
 
-from ...bonds import Bond
-from .reaction import Reaction
+from stk._internal.bond import Bond
+
+from .reaction.reaction import Reaction
 
 
 class OneTwoReaction(Reaction):
     """
     A reaction between two functional groups.
 
     One functional group has 1 *bonder* atom, A, and the other has 2, B
```

### Comparing `stk-2022.6.17.0/src/stk/molecular/reactions/reactions/reaction/new_atom.py` & `stk-2023.7.5.0/src/stk/_internal/reactions/reaction/new_atom.py`

 * *Files 8% similar despite different names*

```diff
@@ -35,15 +35,15 @@
 
         C(-1) [1. 2. 3.]
         H(-2) [2. 5. 7.]
         F(-3) [8. 2. 3.]
 
     """
 
-    __slots__ = ['_atom', '_position']
+    __slots__ = ["_atom", "_position"]
 
     def __init__(self, atom, position):
         """
         Initialize a :class:`.NewAtom` instance.
 
         Parameters
         ----------
```

### Comparing `stk-2022.6.17.0/src/stk/molecular/reactions/reactions/reaction/reaction.py` & `stk-2023.7.5.0/src/stk/_internal/reactions/reaction/reaction.py`

 * *Files 13% similar despite different names*

```diff
@@ -1,32 +1,7 @@
-"""
-Reaction
-========
-
-.. toctree::
-    :maxdepth: 2
-
-    One One Reaction <\
-stk.molecular.reactions.reactions.one_one_reaction\
->
-    One Two Reaction <\
-stk.molecular.reactions.reactions.one_two_reaction\
->
-    Ring Amine Reaction <\
-stk.molecular.reactions.reactions.ring_amine_reaction\
->
-    Two Two Reaction <\
-stk.molecular.reactions.reactions.two_two_reaction\
->
-    Dative Reaction <\
-stk.molecular.reactions.reactions.dative_reaction.dative_reaction\
->
-
-"""
-
 from .reaction_result import ReactionResult
 
 
 class Reaction:
     """
     An abstract base class for reactions.
```

### Comparing `stk-2022.6.17.0/src/stk/molecular/reactions/reactions/reaction/reaction_result.py` & `stk-2023.7.5.0/src/stk/_internal/reactions/reaction/reaction_result.py`

 * *Files 4% similar despite different names*

```diff
@@ -8,18 +8,18 @@
 class ReactionResult:
     """
     The result of a reaction.
 
     """
 
     __slots__ = [
-        '_new_atoms',
-        '_new_bonds',
-        '_deleted_atoms',
-        '_deleted_bonds',
+        "_new_atoms",
+        "_new_bonds",
+        "_deleted_atoms",
+        "_deleted_bonds",
     ]
 
     def __init__(
         self,
         new_atoms,
         new_bonds,
         deleted_atoms,
```

### Comparing `stk-2022.6.17.0/src/stk/molecular/reactions/reactions/ring_amine_reaction.py` & `stk-2023.7.5.0/src/stk/_internal/reactions/ring_amine_reaction.py`

 * *Files 10% similar despite different names*

```diff
@@ -2,17 +2,19 @@
 Ring Amine Reaction
 ===================
 
 """
 
 import numpy as np
 
-from ... import atoms
-from ...bonds import Bond
-from .reaction import NewAtom, Reaction
+from stk._internal.bond import Bond
+from stk._internal.elements import C, H
+
+from .reaction.new_atom import NewAtom
+from .reaction.reaction import Reaction
 
 
 class RingAmineReaction(Reaction):
     """
     Performs a reaction between two :class:`.RingAmine` groups.
 
     The reaction creates a new ring, merging the two functional groups.
@@ -42,64 +44,64 @@
 
     def _get_new_atoms(self):
         n1_coord = self._get_position(self._ring_amine1.get_nitrogen())
         n2_coord = self._get_position(self._ring_amine2.get_nitrogen())
         c1_coord = self._get_position(self._ring_amine1.get_carbon1())
         c2_coord = self._get_position(self._ring_amine2.get_carbon1())
 
-        n_joiner = atoms.C(-1)
+        n_joiner = C(-1)
         n_joiner_coord = (n1_coord + n2_coord) / 2
         yield NewAtom(n_joiner, n_joiner_coord)
 
-        nh1 = atoms.H(-2)
+        nh1 = H(-2)
         nh1_coord = n_joiner_coord + [0, 0, 1]
         yield NewAtom(nh1, nh1_coord)
 
-        nh2 = atoms.H(-3)
+        nh2 = H(-3)
         nh2_coord = n_joiner_coord + [0, 0, -1]
         yield NewAtom(nh2, nh2_coord)
 
-        nc_joiner1 = atoms.C(-4)
+        nc_joiner1 = C(-4)
         nc_joiner1_coord = (c1_coord + n2_coord) / 2
         yield NewAtom(nc_joiner1, nc_joiner1_coord)
 
-        nc1h1 = atoms.H(-5)
+        nc1h1 = H(-5)
         nc1h1_coord = nc_joiner1_coord + [0, 0, 1]
         yield NewAtom(nc1h1, nc1h1_coord)
 
-        nc1h2 = atoms.H(-6)
+        nc1h2 = H(-6)
         nc1h2_coord = nc_joiner1_coord + [0, 0, -1]
         yield NewAtom(nc1h2, nc1h2_coord)
 
-        nc_joiner2 = atoms.C(-7)
+        nc_joiner2 = C(-7)
         nc_joiner2_coord = (c2_coord + n1_coord) / 2
         yield NewAtom(nc_joiner2, nc_joiner2_coord)
 
-        nc2h1 = atoms.H(-8)
+        nc2h1 = H(-8)
         nc2h1_coord = nc_joiner2_coord + [0, 0, 1]
         yield NewAtom(nc2h1, nc2h1_coord)
 
-        nc2h2 = atoms.H(-9)
+        nc2h2 = H(-9)
         nc2h2_coord = nc_joiner2_coord + [0, 0, -1]
         yield NewAtom(nc2h2, nc2h2_coord)
 
     def _get_new_bonds(self):
         n1 = self._ring_amine1.get_nitrogen()
         n2 = self._ring_amine2.get_nitrogen()
         c1 = self._ring_amine1.get_carbon2()
         c2 = self._ring_amine2.get_carbon2()
-        n_joiner = atoms.C(-1)
-        nh1 = atoms.H(-2)
-        nh2 = atoms.H(-3)
-        nc_joiner1 = atoms.C(-4)
-        nc1h1 = atoms.H(-5)
-        nc1h2 = atoms.H(-6)
-        nc_joiner2 = atoms.C(-7)
-        nc2h1 = atoms.C(-8)
-        nc2h2 = atoms.C(-9)
+        n_joiner = C(-1)
+        nh1 = H(-2)
+        nh2 = H(-3)
+        nc_joiner1 = C(-4)
+        nc1h1 = H(-5)
+        nc1h2 = H(-6)
+        nc_joiner2 = C(-7)
+        nc2h1 = C(-8)
+        nc2h2 = C(-9)
 
         yield Bond(n1, n_joiner, 1),
         yield Bond(n_joiner, n2, 1, self._periodicity),
         yield Bond(n_joiner, nh1, 1),
         yield Bond(n_joiner, nh2, 1),
         yield Bond(c1, nc_joiner1, 1),
         yield Bond(nc_joiner1, n2, 1, self._periodicity),
```

### Comparing `stk-2022.6.17.0/src/stk/molecular/reactions/reactions/two_two_reaction.py` & `stk-2023.7.5.0/src/stk/_internal/reactions/two_two_reaction.py`

 * *Files 10% similar despite different names*

```diff
@@ -4,16 +4,17 @@
 
 """
 
 import itertools as it
 
 from scipy.spatial.distance import euclidean
 
-from ...bonds import Bond
-from .reaction import Reaction
+from stk._internal.bond import Bond
+
+from .reaction.reaction import Reaction
 
 
 class TwoTwoReaction(Reaction):
     """
     A reaction between two functional groups, each with 2 bonder atoms.
 
     The reaction creates the two shortest possible bonds between the
@@ -48,17 +49,15 @@
             The bond order of the bonds created by the reaction.
 
         periodicity : :class:`tuple` of :class:`int`
             The periodicity of the bonds created by the reaction.
 
         """
 
-        self._position_matrix = (
-            construction_state.get_position_matrix()
-        )
+        self._position_matrix = construction_state.get_position_matrix()
         self._functional_group1 = functional_group1
         self._functional_group2 = functional_group2
         self._bond_order = bond_order
         self._periodicity = periodicity
 
     def _get_new_atoms(self):
         return
```

### Comparing `stk-2022.6.17.0/src/stk/molecular/topology_graphs/cage/cage.py` & `stk-2023.7.5.0/src/stk/_internal/topology_graphs/cage/cage.py`

 * *Files 15% similar despite different names*

```diff
@@ -1,133 +1,26 @@
-"""
-Cage
-====
-
-Organic
--------
-
-.. toctree::
-    :maxdepth: 2
-
-    One Plus One <\
-stk.molecular.topology_graphs.cage.three_plus_three.one_plus_one\
->
-    Two Plus Two <\
-stk.molecular.topology_graphs.cage.three_plus_three.two_plus_two\
->
-    Two Plus Three <\
-stk.molecular.topology_graphs.cage.two_plus_three.two_plus_three\
->
-    Two Plus Four <\
-stk.molecular.topology_graphs.cage.two_plus_four.two_plus_four\
->
-    Three Plus Six <\
-stk.molecular.topology_graphs.cage.two_plus_four.three_plus_six\
->
-    Four Plus Four <\
-stk.molecular.topology_graphs.cage.three_plus_three.four_plus_four\
->
-    Four Plus Six <\
-stk.molecular.topology_graphs.cage.two_plus_three.four_plus_six\
->
-    Four Plus Six 2 <\
-stk.molecular.topology_graphs.cage.two_plus_three.four_plus_six_2\
->
-    Four Plus Eight <\
-stk.molecular.topology_graphs.cage.two_plus_four.four_plus_eight\
->
-    Five Plus Ten <\
-stk.molecular.topology_graphs.cage.two_plus_four.five_plus_ten\
->
-    Six Plus Eight <\
-stk.molecular.topology_graphs.cage.three_plus_four.six_plus_eight\
->
-    Six Plus Nine <\
-stk.molecular.topology_graphs.cage.two_plus_three.six_plus_nine\
->
-    Six Plus Twelve <\
-stk.molecular.topology_graphs.cage.two_plus_four.six_plus_twelve\
->
-    Eight Plus Twelve <\
-stk.molecular.topology_graphs.cage.two_plus_three.eight_plus_twelve\
->
-    Eight Plus Sixteen <\
-stk.molecular.topology_graphs.cage.two_plus_four.eight_plus_sixteen\
->
-    Ten Plus Twenty <\
-stk.molecular.topology_graphs.cage.two_plus_four.ten_plus_twenty\
->
-    Twelve Plus Thirty <\
-stk.molecular.topology_graphs.cage.two_plus_five.twelve_plus_thirty\
->
-    Twenty Plus Thirty <\
-stk.molecular.topology_graphs.cage.two_plus_three.twenty_plus_thirty\
->
-
-Metal-Organic
--------------
-
-.. toctree::
-    :maxdepth: 2
-
-    M2L4 Lantern <\
-stk.molecular.topology_graphs.cage.metal_topologies.m2l4_lantern\
->
-    M3L3 Triangle <\
-stk.molecular.topology_graphs.cage.metal_topologies.m3l3_triangle\
->
-    M3L6 <\
-stk.molecular.topology_graphs.cage.metal_topologies.m3l6\
->
-    M4L4 Square <\
-stk.molecular.topology_graphs.cage.metal_topologies.m4l4_square\
->
-    M4L4 Tetrahedron <\
-stk.molecular.topology_graphs.cage.metal_topologies.m4l4_tetrahedron\
->
-    M4L6 Tetrahedron Spacer <\
-stk.molecular.topology_graphs.cage.metal_topologies\
-.m4l6_tetrahedron_spacer\
->
-    M4L6 Tetrahedron <\
-stk.molecular.topology_graphs.cage.metal_topologies.m4l6_tetrahedron\
->
-    M4L8 <\
-stk.molecular.topology_graphs.cage.metal_topologies.m4l8\
->
-    M6L2L3 Prism <\
-stk.molecular.topology_graphs.cage.metal_topologies.m6l2l3_prism\
->
-    M6L12 Cube <\
-stk.molecular.topology_graphs.cage.metal_topologies.m6l12_cube\
->
-    M8L6 Cube <\
-stk.molecular.topology_graphs.cage.metal_topologies.m8l6_cube\
->
-    M12L24 <\
-stk.molecular.topology_graphs.cage.metal_topologies.m12l24\
->
-    M24L48 <\
-stk.molecular.topology_graphs.cage.metal_topologies.m24l48\
->
-
-"""
-
 from __future__ import annotations
 
 import typing
 from collections import Counter, abc, defaultdict
 from functools import partial
 
-from ...molecules import BuildingBlock
-from ...reactions import GenericReactionFactory, ReactionFactory
-from ..topology_graph import NullOptimizer, TopologyGraph
-from ..topology_graph.edge import Edge
-from ..topology_graph.optimizers import Optimizer
-from ..topology_graph.vertex import Vertex
+from stk._internal.building_block import BuildingBlock
+from stk._internal.optimizers.null import NullOptimizer
+from stk._internal.optimizers.optimizer import Optimizer
+from stk._internal.reaction_factories.generic_reaction_factory import (
+    GenericReactionFactory,
+)
+from stk._internal.reaction_factories.reaction_factory import ReactionFactory
+from stk._internal.topology_graphs.edge import Edge
+from stk._internal.topology_graphs.topology_graph.topology_graph import (
+    TopologyGraph,
+)
+from stk._internal.topology_graphs.vertex import Vertex
+
 from .cage_construction_state import _CageConstructionState
 from .vertices import UnaligningVertex, _CageVertex
 
 
 class UnoccupiedVertexError(Exception):
     """
     When a cage vertex is not occupied by a building block.
@@ -983,15 +876,15 @@
         for vertex_id, degree in cls._vertex_degrees.items():
             cls._vertices_of_degree[degree].add(vertex_id)
 
     def __init__(
         self,
         building_blocks: typing.Union[
             typing.Iterable[BuildingBlock],
-            dict[BuildingBlock, tuple[int, ...]]
+            dict[BuildingBlock, tuple[int, ...]],
         ],
         vertex_alignments: typing.Optional[dict[int, int]] = None,
         reaction_factory: ReactionFactory = GenericReactionFactory(),
         num_processes: int = 1,
         optimizer: Optimizer = NullOptimizer(),
     ) -> None:
         """
@@ -1060,17 +953,15 @@
 
         """
 
         building_block_vertices = self._normalize_building_blocks(
             building_blocks=building_blocks,
         )
         self._vertex_alignments = (
-            dict(vertex_alignments)
-            if vertex_alignments is not None
-            else {}
+            dict(vertex_alignments) if vertex_alignments is not None else {}
         )
         building_block_vertices = self._with_unaligning_vertices(
             building_block_vertices=building_block_vertices,
         )
         building_block_vertices = self._assign_aligners(
             building_block_vertices=building_block_vertices,
             vertex_alignments=self._vertex_alignments,
@@ -1081,44 +972,42 @@
                 dict[BuildingBlock, abc.Sequence[Vertex]],
                 building_block_vertices,
             ),
             edges=self._edge_prototypes,
             reaction_factory=reaction_factory,
             construction_stages=tuple(
                 partial(self._has_degree, degree)
-                for degree
-                in sorted(self._vertices_of_degree, reverse=True)
+                for degree in sorted(self._vertices_of_degree, reverse=True)
             ),
             num_processes=num_processes,
             optimizer=optimizer,
             edge_groups=None,
         )
 
     @classmethod
     def _normalize_building_blocks(
         cls,
         building_blocks: typing.Union[
             typing.Iterable[BuildingBlock],
-            dict[BuildingBlock, tuple[int, ...]]
+            dict[BuildingBlock, tuple[int, ...]],
         ],
     ) -> dict[BuildingBlock, abc.Sequence[_CageVertex]]:
-
         # Use tuple here because it prints nicely.
         allowed_degrees = tuple(cls._vertices_of_degree.keys())
         if isinstance(building_blocks, dict):
             for building_block in building_blocks:
                 assert (
                     building_block.get_num_functional_groups()
                     in cls._vertices_of_degree.keys()
                 ), (
-                    'The number of functional groups in '
-                    f'{building_block} needs to be one of '
-                    f'{allowed_degrees}, but is '
-                    'currently '
-                    f'{building_block.get_num_functional_groups()}.'
+                    "The number of functional groups in "
+                    f"{building_block} needs to be one of "
+                    f"{allowed_degrees}, but is "
+                    "currently "
+                    f"{building_block.get_num_functional_groups()}."
                 )
             return {
                 building_block: tuple(cls._get_vertices(ids))
                 for building_block, ids in building_blocks.items()
             }
 
         else:
@@ -1128,27 +1017,24 @@
 
     @staticmethod
     def _with_unaligning_vertices(
         building_block_vertices: dict[
             BuildingBlock, abc.Sequence[_CageVertex]
         ],
     ) -> dict[BuildingBlock, abc.Sequence[_CageVertex]]:
-
         clone = dict(building_block_vertices)
         for building_block, vertices in clone.items():
             # Building blocks with 1 placer, cannot be aligned and
             # must therefore use an UnaligningVertex.
             if building_block.get_num_placers() == 1:
                 clone[building_block] = tuple(
                     UnaligningVertex(
                         id=v.get_id(),
                         position=v.get_position(),
-                        use_neighbor_placement=(
-                            v.use_neighbor_placement()
-                        ),
+                        use_neighbor_placement=(v.use_neighbor_placement()),
                         aligner_edge=v.get_aligner_edge(),
                     )
                     for v in vertices
                 )
 
         return clone
 
@@ -1156,56 +1042,52 @@
     def _assign_aligners(
         cls,
         building_block_vertices: dict[
             BuildingBlock, abc.Sequence[_CageVertex]
         ],
         vertex_alignments: dict[int, int],
     ) -> dict[BuildingBlock, abc.Sequence[_CageVertex]]:
-
         def with_aligner(vertex: _CageVertex) -> _CageVertex:
             return vertex.with_aligner_edge(
                 aligner_edge=vertex_alignments.get(vertex.get_id(), 0),
             )
 
         return {
             building_block: tuple(map(with_aligner, vertices))
-            for building_block, vertices
-            in building_block_vertices.items()
+            for building_block, vertices in building_block_vertices.items()
         }
 
     @classmethod
     def _check_building_block_vertices(
         cls,
         building_block_vertices: dict[
             BuildingBlock, abc.Sequence[_CageVertex]
         ],
     ) -> None:
-
         unassigned_ids = set(
             vertex.get_id() for vertex in cls._vertex_prototypes
         )
         assigned_ids = set()
         vertices = (
             vertex
             for vertices_ in building_block_vertices.values()
             for vertex in vertices_
         )
         for vertex in vertices:
             if vertex.get_id() in assigned_ids:
                 raise OverlyOccupiedVertexError(
-                    f'Vertex {vertex.get_id()} has multiple building '
-                    'blocks placed on it.'
+                    f"Vertex {vertex.get_id()} has multiple building "
+                    "blocks placed on it."
                 )
             assigned_ids.add(vertex.get_id())
             unassigned_ids.remove(vertex.get_id())
 
         if unassigned_ids:
             raise UnoccupiedVertexError(
-                'The following vertices are unoccupied '
-                f'{unassigned_ids}.'
+                "The following vertices are unoccupied " f"{unassigned_ids}."
             )
 
     def clone(self) -> Cage:
         clone = self._clone()
         clone._vertex_alignments = dict(self._vertex_alignments)
         return clone
 
@@ -1225,15 +1107,15 @@
         Yields:
 
             A vertex prototype of the topology graph.
 
         """
 
         if isinstance(vertex_ids, int):
-            vertex_ids = (vertex_ids, )
+            vertex_ids = (vertex_ids,)
 
         for vertex_id in vertex_ids:
             yield cls._vertex_prototypes[vertex_id]
 
     def _has_degree(
         self,
         degree: int,
@@ -1292,72 +1174,64 @@
 
         # Use tuple here because it prints nicely.
         allowed_degrees = tuple(cls._vertices_of_degree.keys())
 
         building_blocks_by_degree = {}
         for building_block in building_blocks:
             num_fgs = building_block.get_num_functional_groups()
-            assert (
-                num_fgs in cls._vertices_of_degree.keys()
-            ), (
-                'The number of functional groups in '
-                f'{building_block} needs to be one of '
-                f'{allowed_degrees}, but is '
-                'currently '
-                f'{building_block.get_num_functional_groups()}.'
+            assert num_fgs in cls._vertices_of_degree.keys(), (
+                "The number of functional groups in "
+                f"{building_block} needs to be one of "
+                f"{allowed_degrees}, but is "
+                "currently "
+                f"{building_block.get_num_functional_groups()}."
             )
 
             if num_fgs in building_blocks_by_degree:
                 raise ValueError(
-                    'If there are multiple building blocks with the '
-                    'same number of functional groups, '
-                    'building_block_vertices must be set explicitly.'
+                    "If there are multiple building blocks with the "
+                    "same number of functional groups, "
+                    "building_block_vertices must be set explicitly."
                 )
             building_blocks_by_degree[num_fgs] = building_block
 
         building_block_vertices: dict[BuildingBlock, list[_CageVertex]]
         building_block_vertices = {}
         for vertex in cls._vertex_prototypes:
             vertex_degree = cls._vertex_degrees[vertex.get_id()]
             building_block = building_blocks_by_degree[vertex_degree]
-            building_block_vertices[building_block] = (
-                building_block_vertices.get(building_block, [])
-            )
+            building_block_vertices[
+                building_block
+            ] = building_block_vertices.get(building_block, [])
             building_block_vertices[building_block].append(vertex)
         return typing.cast(
             dict[BuildingBlock, abc.Sequence[_CageVertex]],
             building_block_vertices,
         )
 
     def _get_scale(
         self,
-        building_block_vertices: dict[
-            BuildingBlock, abc.Sequence[Vertex]
-        ],
+        building_block_vertices: dict[BuildingBlock, abc.Sequence[Vertex]],
     ) -> float:
-
-        return max(
-            bb.get_maximum_diameter()
-            for bb in building_block_vertices
-        )
+        return max(bb.get_maximum_diameter() for bb in building_block_vertices)
 
     def _get_construction_state(self) -> _CageConstructionState:
         return _CageConstructionState(
             building_block_vertices=self._building_block_vertices,
             edges=self._edges,
             num_placement_stages=self._implementation.get_num_stages(),
             vertex_degrees=self._vertex_degrees,
         )
 
     def __repr__(self) -> str:
         vertex_alignments = (
-            f'vertex_alignments={self._vertex_alignments}'
+            f"vertex_alignments={self._vertex_alignments}"
             if self._vertex_alignments
-            else ''
+            else ""
         )
-        return f'cage.{self.__class__.__name__}({vertex_alignments})'
+        return f"cage.{self.__class__.__name__}({vertex_alignments})"
 
     def with_building_blocks(
         self,
         building_block_map: dict[BuildingBlock, BuildingBlock],
     ) -> Cage:
         return self.clone()._with_building_blocks(building_block_map)
```

### Comparing `stk-2022.6.17.0/src/stk/molecular/topology_graphs/cage/cage_construction_state.py` & `stk-2023.7.5.0/src/stk/_internal/topology_graphs/cage/cage_construction_state.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,14 +1,14 @@
 """
 Cage Construction State
 =======================
 
 """
 
-from ..topology_graph import ConstructionState
+from stk._internal.construction_state import ConstructionState
 
 
 class _CageConstructionState(ConstructionState):
     """
     The construction state of a :class:`.Cage`.
 
     """
@@ -66,18 +66,15 @@
             edges=edges,
             building_blocks=building_blocks,
             results=results,
         )
 
         # No need to update vertex positions after the last stage.
         self._num_placement_stages_done += 1
-        if (
-            self._num_placement_stages_done
-            >= self._num_placement_stages
-        ):
+        if self._num_placement_stages_done >= self._num_placement_stages:
             return self
 
         self._update_neighbor_positions(
             vertices=vertices,
             edges=edges,
             building_blocks=building_blocks,
             results=results,
@@ -164,29 +161,31 @@
             edges,
             building_blocks,
             results,
         ):
             building_block = building_block.with_position_matrix(
                 position_matrix=result.position_matrix,
             )
-            edge_functional_groups = dict(zip(
-                result.functional_group_edges.values(),
-                result.functional_group_edges.keys(),
-            ))
+            edge_functional_groups = dict(
+                zip(
+                    result.functional_group_edges.values(),
+                    result.functional_group_edges.keys(),
+                )
+            )
             for neighbor_id, edge_id in self._get_neighbors(
                 vertex=vertex,
                 vertex_edges=vertex_edges,
             ):
                 fg_id = edge_functional_groups[edge_id]
-                functional_group, = (
-                    building_block.get_functional_groups(fg_id)
-                )
-                self._neighbor_positions[neighbor_id] = (
-                    self._neighbor_positions.get(neighbor_id, [])
+                (functional_group,) = building_block.get_functional_groups(
+                    fg_id
                 )
+                self._neighbor_positions[
+                    neighbor_id
+                ] = self._neighbor_positions.get(neighbor_id, [])
                 self._neighbor_positions[neighbor_id].append(
                     building_block.get_centroid(
                         atom_ids=functional_group.get_placer_ids(),
                     )
                 )
 
         self._graph_state = self._graph_state.with_vertices(
@@ -216,32 +215,30 @@
 
         for edge in vertex_edges:
             neighbor_id = (
                 edge.get_vertex1_id()
                 if vertex.get_id() != edge.get_vertex1_id()
                 else edge.get_vertex2_id()
             )
-            neighbor, = self._graph_state.get_vertices(neighbor_id)
+            (neighbor,) = self._graph_state.get_vertices(neighbor_id)
             if neighbor.use_neighbor_placement():
                 yield neighbor_id, edge.get_id()
 
     def _get_new_vertices(self):
         """
         Yield the vertices once new positions have been added.
 
         Yields
         ------
         :class:`.Vertex`
             A vertex of the topology graph.
 
         """
 
-        for vertex_id, vertex in enumerate(
-            self._graph_state.get_vertices()
-        ):
+        for vertex_id, vertex in enumerate(self._graph_state.get_vertices()):
             if (
                 len(self._neighbor_positions.get(vertex_id, []))
                 == self._vertex_degrees[vertex_id]
             ):
                 yield vertex.with_position(
                     position=(
                         sum(self._neighbor_positions[vertex_id])
@@ -250,16 +247,13 @@
                 )
             else:
                 yield vertex
 
     def clone(self):
         clone = super().clone()
         clone._neighbor_positions = {
-            key: list(value)
-            for key, value in self._neighbor_positions.items()
+            key: list(value) for key, value in self._neighbor_positions.items()
         }
-        clone._num_placement_stages_done = (
-            self._num_placement_stages_done
-        )
+        clone._num_placement_stages_done = self._num_placement_stages_done
         clone._num_placement_stages = self._num_placement_stages
         clone._vertex_degrees = dict(self._vertex_degrees)
         return clone
```

### Comparing `stk-2022.6.17.0/src/stk/molecular/topology_graphs/cage/metal_topologies/m12l24.py` & `stk-2023.7.5.0/src/stk/_internal/topology_graphs/cage/m12l24.py`

 * *Files 1% similar despite different names*

```diff
@@ -1,16 +1,17 @@
 """
 M12L24
 ======
 
 """
 
-from ...topology_graph import Edge
-from ..cage import Cage
-from ..vertices import LinearVertex, NonLinearVertex
+from stk._internal.topology_graphs.edge import Edge
+
+from .cage import Cage
+from .vertices import LinearVertex, NonLinearVertex
 
 
 class M12L24(Cage):
     """
     Represents a cage topology graph.
 
     .. moldoc::
@@ -98,35 +99,30 @@
         NonLinearVertex(5, [0.5, -0.5, 0.707]),
         NonLinearVertex(6, [-0.5, 0.5, 0.707]),
         NonLinearVertex(7, [-0.5, -0.5, 0.707]),
         NonLinearVertex(8, [0.5, 0.5, -0.707]),
         NonLinearVertex(9, [0.5, -0.5, -0.707]),
         NonLinearVertex(10, [-0.5, 0.5, -0.707]),
         NonLinearVertex(11, [-0.5, -0.5, -0.707]),
-
         LinearVertex(12, [0.9, 0.31, 0.31], False),
         LinearVertex(13, [0.9, 0.31, -0.31], False),
         LinearVertex(14, [0.9, -0.31, 0.31], False),
         LinearVertex(15, [0.9, -0.31, -0.31], False),
-
         LinearVertex(16, [-0.9, 0.31, 0.31], False),
         LinearVertex(17, [-0.9, 0.31, -0.31], False),
         LinearVertex(18, [-0.9, -0.31, 0.31], False),
         LinearVertex(19, [-0.9, -0.31, -0.31], False),
-
         LinearVertex(20, [0.31, 0.9, 0.31], False),
         LinearVertex(21, [0.31, 0.9, -0.31], False),
         LinearVertex(22, [-0.31, 0.9, 0.31], False),
         LinearVertex(23, [-0.31, 0.9, -0.31], False),
-
         LinearVertex(24, [0.31, -0.9, 0.31], False),
         LinearVertex(25, [0.31, -0.9, -0.31], False),
         LinearVertex(26, [-0.31, -0.9, 0.31], False),
         LinearVertex(27, [-0.31, -0.9, -0.31], False),
-
         LinearVertex(28, [0.58, 0, 0.82], False),
         LinearVertex(29, [-0.58, 0, 0.82], False),
         LinearVertex(30, [0, 0.58, 0.82], False),
         LinearVertex(31, [0, -0.58, 0.82], False),
         LinearVertex(32, [0.58, 0, -0.82], False),
         LinearVertex(33, [-0.58, 0, -0.82], False),
         LinearVertex(34, [0, 0.58, -0.82], False),
@@ -134,65 +130,54 @@
     )
 
     _edge_prototypes = (
         Edge(0, _vertex_prototypes[0], _vertex_prototypes[12]),
         Edge(1, _vertex_prototypes[0], _vertex_prototypes[13]),
         Edge(2, _vertex_prototypes[0], _vertex_prototypes[14]),
         Edge(3, _vertex_prototypes[0], _vertex_prototypes[15]),
-
         Edge(4, _vertex_prototypes[1], _vertex_prototypes[16]),
         Edge(5, _vertex_prototypes[1], _vertex_prototypes[17]),
         Edge(6, _vertex_prototypes[1], _vertex_prototypes[18]),
         Edge(7, _vertex_prototypes[1], _vertex_prototypes[19]),
-
         Edge(8, _vertex_prototypes[2], _vertex_prototypes[20]),
         Edge(9, _vertex_prototypes[2], _vertex_prototypes[21]),
         Edge(10, _vertex_prototypes[2], _vertex_prototypes[22]),
         Edge(11, _vertex_prototypes[2], _vertex_prototypes[23]),
-
         Edge(12, _vertex_prototypes[3], _vertex_prototypes[24]),
         Edge(13, _vertex_prototypes[3], _vertex_prototypes[25]),
         Edge(14, _vertex_prototypes[3], _vertex_prototypes[26]),
         Edge(15, _vertex_prototypes[3], _vertex_prototypes[27]),
-
         Edge(16, _vertex_prototypes[4], _vertex_prototypes[28]),
         Edge(17, _vertex_prototypes[4], _vertex_prototypes[30]),
         Edge(18, _vertex_prototypes[4], _vertex_prototypes[12]),
         Edge(19, _vertex_prototypes[4], _vertex_prototypes[20]),
-
         Edge(20, _vertex_prototypes[5], _vertex_prototypes[14]),
         Edge(21, _vertex_prototypes[5], _vertex_prototypes[24]),
         Edge(22, _vertex_prototypes[5], _vertex_prototypes[28]),
         Edge(23, _vertex_prototypes[5], _vertex_prototypes[31]),
-
         Edge(24, _vertex_prototypes[6], _vertex_prototypes[16]),
         Edge(25, _vertex_prototypes[6], _vertex_prototypes[29]),
         Edge(26, _vertex_prototypes[6], _vertex_prototypes[30]),
         Edge(27, _vertex_prototypes[6], _vertex_prototypes[22]),
-
         Edge(28, _vertex_prototypes[7], _vertex_prototypes[18]),
         Edge(29, _vertex_prototypes[7], _vertex_prototypes[26]),
         Edge(30, _vertex_prototypes[7], _vertex_prototypes[31]),
         Edge(31, _vertex_prototypes[7], _vertex_prototypes[29]),
-
         Edge(32, _vertex_prototypes[8], _vertex_prototypes[13]),
         Edge(33, _vertex_prototypes[8], _vertex_prototypes[32]),
         Edge(34, _vertex_prototypes[8], _vertex_prototypes[34]),
         Edge(35, _vertex_prototypes[8], _vertex_prototypes[21]),
-
         Edge(36, _vertex_prototypes[9], _vertex_prototypes[15]),
         Edge(37, _vertex_prototypes[9], _vertex_prototypes[32]),
         Edge(38, _vertex_prototypes[9], _vertex_prototypes[35]),
         Edge(39, _vertex_prototypes[9], _vertex_prototypes[25]),
-
         Edge(40, _vertex_prototypes[10], _vertex_prototypes[17]),
         Edge(41, _vertex_prototypes[10], _vertex_prototypes[23]),
         Edge(42, _vertex_prototypes[10], _vertex_prototypes[34]),
         Edge(43, _vertex_prototypes[10], _vertex_prototypes[33]),
-
         Edge(44, _vertex_prototypes[11], _vertex_prototypes[19]),
         Edge(45, _vertex_prototypes[11], _vertex_prototypes[33]),
         Edge(46, _vertex_prototypes[11], _vertex_prototypes[27]),
         Edge(47, _vertex_prototypes[11], _vertex_prototypes[35]),
     )
 
     _num_windows = 14
```

### Comparing `stk-2022.6.17.0/src/stk/molecular/topology_graphs/cage/metal_topologies/m24l48.py` & `stk-2023.7.5.0/src/stk/_internal/topology_graphs/cage/m24l48.py`

 * *Files 1% similar despite different names*

```diff
@@ -1,16 +1,17 @@
 """
 M24L48
 ======
 
 """
 
-from ...topology_graph import Edge
-from ..cage import Cage
-from ..vertices import LinearVertex, NonLinearVertex
+from stk._internal.topology_graphs.edge import Edge
+
+from .cage import Cage
+from .vertices import LinearVertex, NonLinearVertex
 
 
 class M24L48(Cage):
     """
     Represents a cage topology graph.
 
     .. moldoc::
@@ -87,18 +88,18 @@
 
     See :class:`.Cage` for more details and examples.
 
     """
 
     _coord1 = 0.621
     _coord2 = -0.621
-    _coord3 = _coord1 - (_coord1-_coord2)/2
+    _coord3 = _coord1 - (_coord1 - _coord2) / 2
     _coord4 = -1.5
     _coord5 = 1.5
-    _coord6 = _coord5 - (_coord5-_coord1)/2
+    _coord6 = _coord5 - (_coord5 - _coord1) / 2
 
     _vertex_prototypes = (
         NonLinearVertex(0, [_coord1, _coord1, _coord4]),
         NonLinearVertex(1, [_coord1, _coord1, _coord5]),
         NonLinearVertex(2, [_coord1, _coord4, _coord2]),
         NonLinearVertex(3, [_coord1, _coord5, _coord2]),
         NonLinearVertex(4, [_coord1, _coord2, _coord4]),
@@ -117,60 +118,54 @@
         NonLinearVertex(17, [_coord4, _coord2, _coord1]),
         NonLinearVertex(18, [_coord4, _coord2, _coord2]),
         NonLinearVertex(19, [_coord4, _coord1, _coord2]),
         NonLinearVertex(20, [_coord5, _coord1, _coord1]),
         NonLinearVertex(21, [_coord5, _coord2, _coord1]),
         NonLinearVertex(22, [_coord5, _coord2, _coord2]),
         NonLinearVertex(23, [_coord5, _coord1, _coord2]),
-
         LinearVertex(24, [_coord1, _coord3, _coord4], False),
         LinearVertex(25, [_coord1, _coord4, _coord3], False),
         LinearVertex(26, [_coord1, _coord3, _coord5], False),
         LinearVertex(27, [_coord1, _coord5, _coord3], False),
         LinearVertex(28, [_coord2, _coord3, _coord4], False),
         LinearVertex(29, [_coord2, _coord4, _coord3], False),
         LinearVertex(30, [_coord2, _coord3, _coord5], False),
         LinearVertex(31, [_coord2, _coord5, _coord3], False),
-
         LinearVertex(32, [_coord3, _coord1, _coord4], False),
         LinearVertex(33, [_coord4, _coord1, _coord3], False),
         LinearVertex(34, [_coord3, _coord1, _coord5], False),
         LinearVertex(35, [_coord5, _coord1, _coord3], False),
         LinearVertex(36, [_coord3, _coord2, _coord4], False),
         LinearVertex(37, [_coord4, _coord2, _coord3], False),
         LinearVertex(38, [_coord3, _coord2, _coord5], False),
         LinearVertex(39, [_coord5, _coord2, _coord3], False),
-
         LinearVertex(40, [_coord3, _coord4, _coord1], False),
         LinearVertex(41, [_coord4, _coord3, _coord1], False),
         LinearVertex(42, [_coord3, _coord5, _coord1], False),
         LinearVertex(43, [_coord5, _coord3, _coord1], False),
         LinearVertex(44, [_coord3, _coord4, _coord2], False),
         LinearVertex(45, [_coord4, _coord3, _coord2], False),
         LinearVertex(46, [_coord3, _coord5, _coord2], False),
         LinearVertex(47, [_coord5, _coord3, _coord2], False),
-
         LinearVertex(48, [_coord1, _coord6, _coord6], False),
         LinearVertex(49, [_coord1, _coord6, -_coord6], False),
         LinearVertex(50, [_coord1, -_coord6, _coord6], False),
         LinearVertex(51, [_coord1, -_coord6, -_coord6], False),
         LinearVertex(52, [_coord2, _coord6, _coord6], False),
         LinearVertex(53, [_coord2, _coord6, -_coord6], False),
         LinearVertex(54, [_coord2, -_coord6, _coord6], False),
         LinearVertex(55, [_coord2, -_coord6, -_coord6], False),
-
         LinearVertex(56, [_coord6, _coord1, _coord6], False),
         LinearVertex(57, [_coord6, _coord1, -_coord6], False),
         LinearVertex(58, [-_coord6, _coord1, _coord6], False),
         LinearVertex(59, [-_coord6, _coord1, -_coord6], False),
         LinearVertex(60, [_coord6, _coord2, _coord6], False),
         LinearVertex(61, [_coord6, _coord2, -_coord6], False),
         LinearVertex(62, [-_coord6, _coord2, _coord6], False),
         LinearVertex(63, [-_coord6, _coord2, -_coord6], False),
-
         LinearVertex(64, [_coord6, _coord6, _coord1], False),
         LinearVertex(65, [_coord6, -_coord6, _coord1], False),
         LinearVertex(66, [-_coord6, _coord6, _coord1], False),
         LinearVertex(67, [-_coord6, -_coord6, _coord1], False),
         LinearVertex(68, [_coord6, _coord6, _coord2], False),
         LinearVertex(69, [_coord6, -_coord6, _coord2], False),
         LinearVertex(70, [-_coord6, _coord6, _coord2], False),
@@ -178,125 +173,102 @@
     )
 
     _edge_prototypes = (
         Edge(0, _vertex_prototypes[0], _vertex_prototypes[57]),
         Edge(1, _vertex_prototypes[0], _vertex_prototypes[32]),
         Edge(2, _vertex_prototypes[0], _vertex_prototypes[49]),
         Edge(3, _vertex_prototypes[0], _vertex_prototypes[24]),
-
         Edge(4, _vertex_prototypes[1], _vertex_prototypes[26]),
         Edge(5, _vertex_prototypes[1], _vertex_prototypes[56]),
         Edge(6, _vertex_prototypes[1], _vertex_prototypes[48]),
         Edge(7, _vertex_prototypes[1], _vertex_prototypes[34]),
-
         Edge(8, _vertex_prototypes[2], _vertex_prototypes[44]),
         Edge(9, _vertex_prototypes[2], _vertex_prototypes[25]),
         Edge(10, _vertex_prototypes[2], _vertex_prototypes[69]),
         Edge(11, _vertex_prototypes[2], _vertex_prototypes[51]),
-
         Edge(12, _vertex_prototypes[3], _vertex_prototypes[68]),
         Edge(13, _vertex_prototypes[3], _vertex_prototypes[49]),
         Edge(14, _vertex_prototypes[3], _vertex_prototypes[27]),
         Edge(15, _vertex_prototypes[3], _vertex_prototypes[46]),
-
         Edge(16, _vertex_prototypes[4], _vertex_prototypes[51]),
         Edge(17, _vertex_prototypes[4], _vertex_prototypes[36]),
         Edge(18, _vertex_prototypes[4], _vertex_prototypes[24]),
         Edge(19, _vertex_prototypes[4], _vertex_prototypes[61]),
-
         Edge(20, _vertex_prototypes[5], _vertex_prototypes[50]),
         Edge(21, _vertex_prototypes[5], _vertex_prototypes[60]),
         Edge(22, _vertex_prototypes[5], _vertex_prototypes[26]),
         Edge(23, _vertex_prototypes[5], _vertex_prototypes[38]),
-
         Edge(24, _vertex_prototypes[6], _vertex_prototypes[40]),
         Edge(25, _vertex_prototypes[6], _vertex_prototypes[25]),
         Edge(26, _vertex_prototypes[6], _vertex_prototypes[65]),
         Edge(27, _vertex_prototypes[6], _vertex_prototypes[50]),
-
         Edge(28, _vertex_prototypes[7], _vertex_prototypes[64]),
         Edge(29, _vertex_prototypes[7], _vertex_prototypes[48]),
         Edge(30, _vertex_prototypes[7], _vertex_prototypes[27]),
         Edge(31, _vertex_prototypes[7], _vertex_prototypes[42]),
-
         Edge(32, _vertex_prototypes[8], _vertex_prototypes[53]),
         Edge(33, _vertex_prototypes[8], _vertex_prototypes[32]),
         Edge(34, _vertex_prototypes[8], _vertex_prototypes[28]),
         Edge(35, _vertex_prototypes[8], _vertex_prototypes[59]),
-
         Edge(36, _vertex_prototypes[9], _vertex_prototypes[34]),
         Edge(37, _vertex_prototypes[9], _vertex_prototypes[52]),
         Edge(38, _vertex_prototypes[9], _vertex_prototypes[30]),
         Edge(39, _vertex_prototypes[9], _vertex_prototypes[58]),
-
         Edge(40, _vertex_prototypes[10], _vertex_prototypes[63]),
         Edge(41, _vertex_prototypes[10], _vertex_prototypes[28]),
         Edge(42, _vertex_prototypes[10], _vertex_prototypes[36]),
         Edge(43, _vertex_prototypes[10], _vertex_prototypes[55]),
-
         Edge(44, _vertex_prototypes[11], _vertex_prototypes[38]),
         Edge(45, _vertex_prototypes[11], _vertex_prototypes[54]),
         Edge(46, _vertex_prototypes[11], _vertex_prototypes[62]),
         Edge(47, _vertex_prototypes[11], _vertex_prototypes[30]),
-
         Edge(48, _vertex_prototypes[12], _vertex_prototypes[67]),
         Edge(49, _vertex_prototypes[12], _vertex_prototypes[54]),
         Edge(50, _vertex_prototypes[12], _vertex_prototypes[29]),
         Edge(51, _vertex_prototypes[12], _vertex_prototypes[40]),
-
         Edge(52, _vertex_prototypes[13], _vertex_prototypes[42]),
         Edge(53, _vertex_prototypes[13], _vertex_prototypes[31]),
         Edge(54, _vertex_prototypes[13], _vertex_prototypes[66]),
         Edge(55, _vertex_prototypes[13], _vertex_prototypes[52]),
-
         Edge(56, _vertex_prototypes[14], _vertex_prototypes[71]),
         Edge(57, _vertex_prototypes[14], _vertex_prototypes[55]),
         Edge(58, _vertex_prototypes[14], _vertex_prototypes[44]),
         Edge(59, _vertex_prototypes[14], _vertex_prototypes[29]),
-
         Edge(60, _vertex_prototypes[15], _vertex_prototypes[46]),
         Edge(61, _vertex_prototypes[15], _vertex_prototypes[31]),
         Edge(62, _vertex_prototypes[15], _vertex_prototypes[70]),
         Edge(63, _vertex_prototypes[15], _vertex_prototypes[53]),
-
         Edge(64, _vertex_prototypes[16], _vertex_prototypes[66]),
         Edge(65, _vertex_prototypes[16], _vertex_prototypes[58]),
         Edge(66, _vertex_prototypes[16], _vertex_prototypes[41]),
         Edge(67, _vertex_prototypes[16], _vertex_prototypes[33]),
-
         Edge(68, _vertex_prototypes[17], _vertex_prototypes[41]),
         Edge(69, _vertex_prototypes[17], _vertex_prototypes[37]),
         Edge(70, _vertex_prototypes[17], _vertex_prototypes[67]),
         Edge(71, _vertex_prototypes[17], _vertex_prototypes[62]),
-
         Edge(72, _vertex_prototypes[18], _vertex_prototypes[45]),
         Edge(73, _vertex_prototypes[18], _vertex_prototypes[37]),
         Edge(74, _vertex_prototypes[18], _vertex_prototypes[71]),
         Edge(75, _vertex_prototypes[18], _vertex_prototypes[63]),
-
         Edge(76, _vertex_prototypes[19], _vertex_prototypes[70]),
         Edge(77, _vertex_prototypes[19], _vertex_prototypes[59]),
         Edge(78, _vertex_prototypes[19], _vertex_prototypes[45]),
         Edge(79, _vertex_prototypes[19], _vertex_prototypes[33]),
-
         Edge(80, _vertex_prototypes[20], _vertex_prototypes[43]),
         Edge(81, _vertex_prototypes[20], _vertex_prototypes[35]),
         Edge(82, _vertex_prototypes[20], _vertex_prototypes[56]),
         Edge(83, _vertex_prototypes[20], _vertex_prototypes[64]),
-
         Edge(84, _vertex_prototypes[21], _vertex_prototypes[43]),
         Edge(85, _vertex_prototypes[21], _vertex_prototypes[39]),
         Edge(86, _vertex_prototypes[21], _vertex_prototypes[65]),
         Edge(87, _vertex_prototypes[21], _vertex_prototypes[60]),
-
         Edge(88, _vertex_prototypes[22], _vertex_prototypes[69]),
         Edge(89, _vertex_prototypes[22], _vertex_prototypes[61]),
         Edge(90, _vertex_prototypes[22], _vertex_prototypes[47]),
         Edge(91, _vertex_prototypes[22], _vertex_prototypes[39]),
-
         Edge(92, _vertex_prototypes[23], _vertex_prototypes[47]),
         Edge(93, _vertex_prototypes[23], _vertex_prototypes[57]),
         Edge(94, _vertex_prototypes[23], _vertex_prototypes[68]),
         Edge(95, _vertex_prototypes[23], _vertex_prototypes[35]),
     )
 
     _num_windows = 26
```

### Comparing `stk-2022.6.17.0/src/stk/molecular/topology_graphs/cage/metal_topologies/m2l4_lantern.py` & `stk-2023.7.5.0/src/stk/_internal/topology_graphs/cage/m2l4_lantern.py`

 * *Files 1% similar despite different names*

```diff
@@ -1,16 +1,17 @@
 """
 M2L4 Lantern
 ============
 
 """
 
-from ...topology_graph import Edge
-from ..cage import Cage
-from ..vertices import LinearVertex, NonLinearVertex
+from stk._internal.topology_graphs.edge import Edge
+
+from .cage import Cage
+from .vertices import LinearVertex, NonLinearVertex
 
 
 class M2L4Lantern(Cage):
     """
     Represents a cage topology graph.
 
     Unoptimized construction
@@ -150,27 +151,25 @@
     See :class:`.Cage` for more details and examples.
 
     """
 
     _vertex_prototypes = (
         NonLinearVertex(0, [0, 0.5, 0]),
         NonLinearVertex(1, [0, -0.5, 0]),
-
         LinearVertex(2, [1, 0, 0], False),
         LinearVertex(3, [0, 0, 1], False),
         LinearVertex(4, [-1, 0, 0], False),
         LinearVertex(5, [0, 0, -1], False),
     )
 
     _edge_prototypes = (
         Edge(0, _vertex_prototypes[0], _vertex_prototypes[2]),
         Edge(1, _vertex_prototypes[0], _vertex_prototypes[3]),
         Edge(2, _vertex_prototypes[0], _vertex_prototypes[4]),
         Edge(3, _vertex_prototypes[0], _vertex_prototypes[5]),
-
         Edge(4, _vertex_prototypes[1], _vertex_prototypes[2]),
         Edge(5, _vertex_prototypes[1], _vertex_prototypes[3]),
         Edge(6, _vertex_prototypes[1], _vertex_prototypes[4]),
         Edge(7, _vertex_prototypes[1], _vertex_prototypes[5]),
     )
 
     _num_windows = 4
```

### Comparing `stk-2022.6.17.0/src/stk/molecular/topology_graphs/cage/metal_topologies/m3l3_triangle.py` & `stk-2023.7.5.0/src/stk/_internal/topology_graphs/cage/m3l3_triangle.py`

 * *Files 2% similar despite different names*

```diff
@@ -2,18 +2,22 @@
 M3L3 Triangle
 =============
 
 """
 
 import numpy as np
 
-from ....reactions import GenericReactionFactory
-from ...topology_graph import Edge, NullOptimizer
-from ..cage import Cage
-from ..vertices import AngledVertex, LinearVertex
+from stk._internal.optimizers.null import NullOptimizer
+from stk._internal.reaction_factories.generic_reaction_factory import (
+    GenericReactionFactory,
+)
+from stk._internal.topology_graphs.edge import Edge
+
+from .cage import Cage
+from .vertices import AngledVertex, LinearVertex
 
 
 class M3L3Triangle(Cage):
     """
     Represents a cage topology graph.
 
     Unoptimized construction
@@ -223,25 +227,24 @@
             building_blocks,
             vertex_alignments=vertex_alignments,
             reaction_factory=reaction_factory,
             num_processes=num_processes,
             optimizer=optimizer,
         )
 
-    _x = 2*np.sqrt(3)/4
+    _x = 2 * np.sqrt(3) / 4
     _y = 2
     _angled_vertices = (
         AngledVertex(0, [0, _x, 0]),
-        AngledVertex(1, [_y/2, -_x, 0]),
-        AngledVertex(2, [-_y/2, -_x, 0]),
+        AngledVertex(1, [_y / 2, -_x, 0]),
+        AngledVertex(2, [-_y / 2, -_x, 0]),
     )
 
     _vertex_prototypes = (
         *_angled_vertices,
-
         LinearVertex.init_at_center(
             id=3,
             vertices=(_angled_vertices[0], _angled_vertices[1]),
         ),
         LinearVertex.init_at_center(
             id=4,
             vertices=(_angled_vertices[1], _angled_vertices[2]),
@@ -251,17 +254,15 @@
             vertices=(_angled_vertices[2], _angled_vertices[0]),
         ),
     )
 
     _edge_prototypes = (
         Edge(0, _vertex_prototypes[0], _vertex_prototypes[3]),
         Edge(1, _vertex_prototypes[1], _vertex_prototypes[3]),
-
         Edge(2, _vertex_prototypes[1], _vertex_prototypes[4]),
         Edge(3, _vertex_prototypes[2], _vertex_prototypes[4]),
-
         Edge(4, _vertex_prototypes[2], _vertex_prototypes[5]),
         Edge(5, _vertex_prototypes[0], _vertex_prototypes[5]),
     )
 
     _num_windows = 1
     _num_window_types = 1
```

### Comparing `stk-2022.6.17.0/src/stk/molecular/topology_graphs/cage/metal_topologies/m3l6.py` & `stk-2023.7.5.0/src/stk/_internal/topology_graphs/cage/m3l6.py`

 * *Files 18% similar despite different names*

```diff
@@ -2,17 +2,18 @@
 M3L6
 ====
 
 """
 
 import numpy as np
 
-from ...topology_graph import Edge
-from ..cage import Cage
-from ..vertices import LinearVertex, NonLinearVertex
+from stk._internal.topology_graphs.edge import Edge
+
+from .cage import Cage
+from .vertices import LinearVertex, NonLinearVertex
 
 
 class M3L6(Cage):
     """
     Represents a cage topology graph.
 
     Unoptimized construction
@@ -154,102 +155,97 @@
     """
 
     _R, _theta = 1, 0
 
     _vertex_prototypes = (
         NonLinearVertex(
             id=0,
-            position=[_R*np.cos(_theta), _R*np.sin(_theta), 0]
+            position=[_R * np.cos(_theta), _R * np.sin(_theta), 0],
         ),
         NonLinearVertex(
             id=1,
             position=[
-                _R*np.cos(_theta+(4*np.pi/3)),
-                _R*np.sin(_theta+(4*np.pi/3)),
-                0
-            ]
+                _R * np.cos(_theta + (4 * np.pi / 3)),
+                _R * np.sin(_theta + (4 * np.pi / 3)),
+                0,
+            ],
         ),
         NonLinearVertex(
             id=2,
             position=[
-                _R*np.cos(_theta+(2*np.pi/3)),
-                _R*np.sin(_theta+(2*np.pi/3)),
-                0
-            ]
+                _R * np.cos(_theta + (2 * np.pi / 3)),
+                _R * np.sin(_theta + (2 * np.pi / 3)),
+                0,
+            ],
         ),
-
         LinearVertex(
             id=3,
             position=[
-                _R*np.cos((_theta+np.pi/4)),
-                _R*np.sin((_theta+np.pi/4)),
-                0.5
+                _R * np.cos((_theta + np.pi / 4)),
+                _R * np.sin((_theta + np.pi / 4)),
+                0.5,
             ],
-            use_neighbor_placement=False
+            use_neighbor_placement=False,
         ),
         LinearVertex(
             id=4,
             position=[
-                _R*np.cos((_theta+1*np.pi/3)),
-                _R*np.sin((_theta+1*np.pi/3)),
-                -0.5
+                _R * np.cos((_theta + 1 * np.pi / 3)),
+                _R * np.sin((_theta + 1 * np.pi / 3)),
+                -0.5,
             ],
-            use_neighbor_placement=False
+            use_neighbor_placement=False,
         ),
-
         LinearVertex(
             id=5,
             position=[
-                _R*np.cos((_theta+1*np.pi/3)+(4*np.pi/3)),
-                _R*np.sin((_theta+1*np.pi/3)+(4*np.pi/3)),
-                0.5
+                _R * np.cos((_theta + 1 * np.pi / 3) + (4 * np.pi / 3)),
+                _R * np.sin((_theta + 1 * np.pi / 3) + (4 * np.pi / 3)),
+                0.5,
             ],
-            use_neighbor_placement=False
+            use_neighbor_placement=False,
         ),
         LinearVertex(
             id=6,
             position=[
-                _R*np.cos((_theta+1*np.pi/3)+(4*np.pi/3)),
-                _R*np.sin((_theta+1*np.pi/3)+(4*np.pi/3)),
-                -0.5
+                _R * np.cos((_theta + 1 * np.pi / 3) + (4 * np.pi / 3)),
+                _R * np.sin((_theta + 1 * np.pi / 3) + (4 * np.pi / 3)),
+                -0.5,
             ],
-            use_neighbor_placement=False
+            use_neighbor_placement=False,
         ),
-
         LinearVertex(
             id=7,
             position=[
-                _R*np.cos((_theta+1*np.pi/3)+(2*np.pi/3)),
-                _R*np.sin((_theta+1*np.pi/3)+(2*np.pi/3)),
-                0.5
+                _R * np.cos((_theta + 1 * np.pi / 3) + (2 * np.pi / 3)),
+                _R * np.sin((_theta + 1 * np.pi / 3) + (2 * np.pi / 3)),
+                0.5,
             ],
-            use_neighbor_placement=False
+            use_neighbor_placement=False,
         ),
         LinearVertex(
             id=8,
             position=[
-                _R*np.cos((_theta+1*np.pi/3)+(2*np.pi/3)),
-                _R*np.sin((_theta+1*np.pi/3)+(2*np.pi/3)),
-                -0.5
+                _R * np.cos((_theta + 1 * np.pi / 3) + (2 * np.pi / 3)),
+                _R * np.sin((_theta + 1 * np.pi / 3) + (2 * np.pi / 3)),
+                -0.5,
             ],
-            use_neighbor_placement=False
+            use_neighbor_placement=False,
         ),
     )
 
     _edge_prototypes = (
         Edge(0, _vertex_prototypes[0], _vertex_prototypes[3]),
         Edge(1, _vertex_prototypes[0], _vertex_prototypes[4]),
         Edge(2, _vertex_prototypes[0], _vertex_prototypes[5]),
         Edge(3, _vertex_prototypes[0], _vertex_prototypes[6]),
-
         Edge(4, _vertex_prototypes[1], _vertex_prototypes[5]),
         Edge(5, _vertex_prototypes[1], _vertex_prototypes[6]),
         Edge(6, _vertex_prototypes[1], _vertex_prototypes[7]),
         Edge(7, _vertex_prototypes[1], _vertex_prototypes[8]),
-
         Edge(8, _vertex_prototypes[2], _vertex_prototypes[3]),
         Edge(9, _vertex_prototypes[2], _vertex_prototypes[4]),
         Edge(10, _vertex_prototypes[2], _vertex_prototypes[7]),
         Edge(11, _vertex_prototypes[2], _vertex_prototypes[8]),
     )
 
     _num_windows = 2
```

### Comparing `stk-2022.6.17.0/src/stk/molecular/topology_graphs/cage/metal_topologies/m4l4_square.py` & `stk-2023.7.5.0/src/stk/_internal/topology_graphs/cage/m4l4_square.py`

 * *Files 9% similar despite different names*

```diff
@@ -1,17 +1,21 @@
 """
 M4L4 Square
 ===========
 
 """
 
-from ....reactions import GenericReactionFactory
-from ...topology_graph import Edge, NullOptimizer
-from ..cage import Cage
-from ..vertices import AngledVertex, LinearVertex
+from stk._internal.optimizers.null import NullOptimizer
+from stk._internal.reaction_factories.generic_reaction_factory import (
+    GenericReactionFactory,
+)
+from stk._internal.topology_graphs.edge import Edge
+
+from .cage import Cage
+from .vertices import AngledVertex, LinearVertex
 
 
 class M4L4Square(Cage):
     """
     Represents a cage topology graph.
 
     Unoptimized construction
@@ -226,30 +230,26 @@
         )
 
     _vertex_prototypes = (
         AngledVertex(0, [1, 1, 0]),
         AngledVertex(1, [1, -1, 0]),
         AngledVertex(2, [-1, -1, 0]),
         AngledVertex(3, [-1, 1, 0]),
-
         LinearVertex(4, [1, 0, 0], False),
         LinearVertex(5, [0, -1, 0], False),
         LinearVertex(6, [-1, 0, 0], False),
         LinearVertex(7, [0, 1, 0], False),
     )
 
     _edge_prototypes = (
         Edge(0, _vertex_prototypes[0], _vertex_prototypes[4]),
         Edge(1, _vertex_prototypes[1], _vertex_prototypes[4]),
-
         Edge(2, _vertex_prototypes[1], _vertex_prototypes[5]),
         Edge(3, _vertex_prototypes[2], _vertex_prototypes[5]),
-
         Edge(4, _vertex_prototypes[2], _vertex_prototypes[6]),
         Edge(5, _vertex_prototypes[3], _vertex_prototypes[6]),
-
         Edge(6, _vertex_prototypes[3], _vertex_prototypes[7]),
         Edge(7, _vertex_prototypes[0], _vertex_prototypes[7]),
     )
 
     _num_windows = 1
     _num_window_types = 1
```

### Comparing `stk-2022.6.17.0/src/stk/molecular/topology_graphs/cage/metal_topologies/m4l4_tetrahedron.py` & `stk-2023.7.5.0/src/stk/_internal/topology_graphs/cage/m4l4_tetrahedron.py`

 * *Files 6% similar despite different names*

```diff
@@ -2,17 +2,18 @@
 M4L4 Tetrahedron
 ================
 
 """
 
 import numpy as np
 
-from ...topology_graph import Edge
-from ..cage import Cage
-from ..vertices import NonLinearVertex
+from stk._internal.topology_graphs.edge import Edge
+
+from .cage import Cage
+from .vertices import NonLinearVertex
 
 
 class M4L4Tetrahedron(Cage):
     """
     Represents a cage topology graph.
 
     Unoptimized construction
@@ -201,23 +202,22 @@
         | 3-functional groups (linker): 4 to 7
 
     See :class:`.Cage` for more details and examples.
 
     """
 
     _non_linears = (
-        NonLinearVertex(0, [0, 0, np.sqrt(6)/2]),
-        NonLinearVertex(1, [-1, -np.sqrt(3)/3, -np.sqrt(6)/6]),
-        NonLinearVertex(2, [1, -np.sqrt(3)/3, -np.sqrt(6)/6]),
-        NonLinearVertex(3, [0, 2*np.sqrt(3)/3, -np.sqrt(6)/6]),
+        NonLinearVertex(0, [0, 0, np.sqrt(6) / 2]),
+        NonLinearVertex(1, [-1, -np.sqrt(3) / 3, -np.sqrt(6) / 6]),
+        NonLinearVertex(2, [1, -np.sqrt(3) / 3, -np.sqrt(6) / 6]),
+        NonLinearVertex(3, [0, 2 * np.sqrt(3) / 3, -np.sqrt(6) / 6]),
     )
 
     _vertex_prototypes = (
         *_non_linears,
-
         NonLinearVertex.init_at_center(
             id=4,
             vertices=(
                 _non_linears[0],
                 _non_linears[1],
                 _non_linears[2],
             ),
```

### Comparing `stk-2022.6.17.0/src/stk/molecular/topology_graphs/cage/metal_topologies/m4l6_tetrahedron.py` & `stk-2023.7.5.0/src/stk/_internal/topology_graphs/cage/m4l6_tetrahedron.py`

 * *Files 2% similar despite different names*

```diff
@@ -2,17 +2,18 @@
 M4L6 Tetrahedron
 ================
 
 """
 
 import numpy as np
 
-from ...topology_graph import Edge
-from ..cage import Cage
-from ..vertices import NonLinearVertex
+from stk._internal.topology_graphs.edge import Edge
+
+from .cage import Cage
+from .vertices import NonLinearVertex
 
 
 class M4L6Tetrahedron(Cage):
     """
     Represents a cage topology graph.
 
     .. moldoc::
@@ -265,15 +266,15 @@
     vertex between the metal vertices on the tetrahedron. See
     :class:`.M4L6TetrahedronSpacer` for an example of its usage.
 
     See :class:`.Cage` for more details and examples.
 
     """
 
-    _x = 1/(2*np.sqrt(2))
+    _x = 1 / (2 * np.sqrt(2))
     _y = 0.5
     _vertex_prototypes = (
         NonLinearVertex(0, [_y, 0, -_x]),
         NonLinearVertex(1, [-_y, 0, -_x]),
         NonLinearVertex(2, [0, _y, _x]),
         NonLinearVertex(3, [0, -_y, _x]),
     )
```

### Comparing `stk-2022.6.17.0/src/stk/molecular/topology_graphs/cage/metal_topologies/m4l6_tetrahedron_spacer.py` & `stk-2023.7.5.0/src/stk/_internal/topology_graphs/cage/m4l6_tetrahedron_spacer.py`

 * *Files 5% similar despite different names*

```diff
@@ -2,17 +2,18 @@
 M4L6 Tetrahedron with Spacer
 ============================
 
 """
 
 import numpy as np
 
-from ...topology_graph import Edge
-from ..cage import Cage
-from ..vertices import LinearVertex, NonLinearVertex
+from stk._internal.topology_graphs.edge import Edge
+
+from .cage import Cage
+from .vertices import LinearVertex, NonLinearVertex
 
 
 class M4L6TetrahedronSpacer(Cage):
     """
     Represents a cage topology graph.
 
     Unoptimized construction
@@ -219,23 +220,22 @@
     in the case that the linker can be disconnected
     in a symmetrical fashion, the
     :class:`.M4L6Tetrahedron` topology can be used.
 
     """
 
     _non_linears = (
-        NonLinearVertex(0, [0, 0, np.sqrt(6)/2]),
-        NonLinearVertex(1, [-1, -np.sqrt(3)/3, -np.sqrt(6)/6]),
-        NonLinearVertex(2, [1, -np.sqrt(3)/3, -np.sqrt(6)/6]),
-        NonLinearVertex(3, [0, 2*np.sqrt(3)/3, -np.sqrt(6)/6]),
+        NonLinearVertex(0, [0, 0, np.sqrt(6) / 2]),
+        NonLinearVertex(1, [-1, -np.sqrt(3) / 3, -np.sqrt(6) / 6]),
+        NonLinearVertex(2, [1, -np.sqrt(3) / 3, -np.sqrt(6) / 6]),
+        NonLinearVertex(3, [0, 2 * np.sqrt(3) / 3, -np.sqrt(6) / 6]),
     )
 
     _vertex_prototypes = (
         *_non_linears,
-
         LinearVertex.init_at_center(
             id=4,
             vertices=(_non_linears[0], _non_linears[1]),
         ),
         LinearVertex.init_at_center(
             id=5,
             vertices=(_non_linears[0], _non_linears[2]),
```

### Comparing `stk-2022.6.17.0/src/stk/molecular/topology_graphs/cage/metal_topologies/m4l8.py` & `stk-2023.7.5.0/src/stk/_internal/topology_graphs/cage/m4l8.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,16 +1,17 @@
 """
 M4L8
 ====
 
 """
 
-from ...topology_graph import Edge
-from ..cage import Cage
-from ..vertices import LinearVertex, NonLinearVertex
+from stk._internal.topology_graphs.edge import Edge
+
+from .cage import Cage
+from .vertices import LinearVertex, NonLinearVertex
 
 
 class M4L8(Cage):
     """
     Represents a cage topology graph.
 
     Unoptimized construction
@@ -152,44 +153,37 @@
     """
 
     _vertex_prototypes = (
         NonLinearVertex(0, [1, 0, 0]),
         NonLinearVertex(1, [0, 1, 0]),
         NonLinearVertex(2, [-1, 0, 0]),
         NonLinearVertex(3, [0, -1, 0]),
-
         LinearVertex(4, [1, 1, 0.5], False),
         LinearVertex(5, [1, 1, -0.5], False),
-
         LinearVertex(6, [1, -1, 0.5], False),
         LinearVertex(7, [1, -1, -0.5], False),
-
         LinearVertex(8, [-1, -1, 0.5], False),
         LinearVertex(9, [-1, -1, -0.5], False),
-
         LinearVertex(10, [-1, 1, 0.5], False),
         LinearVertex(11, [-1, 1, -0.5], False),
     )
 
     _edge_prototypes = (
         Edge(0, _vertex_prototypes[0], _vertex_prototypes[4]),
         Edge(1, _vertex_prototypes[0], _vertex_prototypes[5]),
         Edge(2, _vertex_prototypes[0], _vertex_prototypes[6]),
         Edge(3, _vertex_prototypes[0], _vertex_prototypes[7]),
-
         Edge(4, _vertex_prototypes[1], _vertex_prototypes[4]),
         Edge(5, _vertex_prototypes[1], _vertex_prototypes[5]),
         Edge(6, _vertex_prototypes[1], _vertex_prototypes[10]),
         Edge(7, _vertex_prototypes[1], _vertex_prototypes[11]),
-
         Edge(8, _vertex_prototypes[2], _vertex_prototypes[10]),
         Edge(9, _vertex_prototypes[2], _vertex_prototypes[11]),
         Edge(10, _vertex_prototypes[2], _vertex_prototypes[8]),
         Edge(11, _vertex_prototypes[2], _vertex_prototypes[9]),
-
         Edge(12, _vertex_prototypes[3], _vertex_prototypes[8]),
         Edge(13, _vertex_prototypes[3], _vertex_prototypes[9]),
         Edge(14, _vertex_prototypes[3], _vertex_prototypes[6]),
         Edge(15, _vertex_prototypes[3], _vertex_prototypes[7]),
     )
 
     _num_windows = 2
```

### Comparing `stk-2022.6.17.0/src/stk/molecular/topology_graphs/cage/metal_topologies/m6l12_cube.py` & `stk-2023.7.5.0/src/stk/_internal/topology_graphs/cage/m6l12_cube.py`

 * *Files 2% similar despite different names*

```diff
@@ -2,17 +2,18 @@
 M6L12 Cube
 ==========
 
 """
 
 import numpy as np
 
-from ...topology_graph import Edge
-from ..cage import Cage
-from ..vertices import LinearVertex, NonLinearVertex
+from stk._internal.topology_graphs.edge import Edge
+
+from .cage import Cage
+from .vertices import LinearVertex, NonLinearVertex
 
 
 class M6L12Cube(Cage):
     """
     Represents a cage topology graph.
 
     Unoptimized construction
@@ -157,15 +158,14 @@
     _vertex_prototypes = (
         NonLinearVertex(0, [_x, 0, 0]),
         NonLinearVertex(1, [0, _x, 0]),
         NonLinearVertex(2, [-_x, 0, 0]),
         NonLinearVertex(3, [0, -_x, 0]),
         NonLinearVertex(4, [0, 0, _x]),
         NonLinearVertex(5, [0, 0, -_x]),
-
         LinearVertex(6, [1, 1, 0], False),
         LinearVertex(7, [1, -1, 0], False),
         LinearVertex(8, [1, 0, 1], False),
         LinearVertex(9, [1, 0, -1], False),
         LinearVertex(10, [-1, 1, 0], False),
         LinearVertex(11, [-1, -1, 0], False),
         LinearVertex(12, [-1, 0, 1], False),
@@ -177,35 +177,30 @@
     )
 
     _edge_prototypes = (
         Edge(0, _vertex_prototypes[0], _vertex_prototypes[6]),
         Edge(1, _vertex_prototypes[0], _vertex_prototypes[7]),
         Edge(2, _vertex_prototypes[0], _vertex_prototypes[8]),
         Edge(3, _vertex_prototypes[0], _vertex_prototypes[9]),
-
         Edge(4, _vertex_prototypes[1], _vertex_prototypes[6]),
         Edge(5, _vertex_prototypes[1], _vertex_prototypes[10]),
         Edge(6, _vertex_prototypes[1], _vertex_prototypes[14]),
         Edge(7, _vertex_prototypes[1], _vertex_prototypes[15]),
-
         Edge(8, _vertex_prototypes[2], _vertex_prototypes[10]),
         Edge(9, _vertex_prototypes[2], _vertex_prototypes[11]),
         Edge(10, _vertex_prototypes[2], _vertex_prototypes[12]),
         Edge(11, _vertex_prototypes[2], _vertex_prototypes[13]),
-
         Edge(12, _vertex_prototypes[3], _vertex_prototypes[7]),
         Edge(13, _vertex_prototypes[3], _vertex_prototypes[11]),
         Edge(14, _vertex_prototypes[3], _vertex_prototypes[16]),
         Edge(15, _vertex_prototypes[3], _vertex_prototypes[17]),
-
         Edge(16, _vertex_prototypes[4], _vertex_prototypes[8]),
         Edge(17, _vertex_prototypes[4], _vertex_prototypes[12]),
         Edge(18, _vertex_prototypes[4], _vertex_prototypes[14]),
         Edge(19, _vertex_prototypes[4], _vertex_prototypes[16]),
-
         Edge(20, _vertex_prototypes[5], _vertex_prototypes[9]),
         Edge(21, _vertex_prototypes[5], _vertex_prototypes[13]),
         Edge(22, _vertex_prototypes[5], _vertex_prototypes[15]),
         Edge(23, _vertex_prototypes[5], _vertex_prototypes[17]),
     )
 
     _num_windows = 8
```

### Comparing `stk-2022.6.17.0/src/stk/molecular/topology_graphs/cage/metal_topologies/m6l2l3_prism.py` & `stk-2023.7.5.0/src/stk/_internal/topology_graphs/cage/m6l2l3_prism.py`

 * *Files 3% similar despite different names*

```diff
@@ -2,17 +2,18 @@
 M6L2L3 Prism
 ============
 
 """
 
 import numpy as np
 
-from ...topology_graph import Edge
-from ..cage import Cage
-from ..vertices import NonLinearVertex
+from stk._internal.topology_graphs.edge import Edge
+
+from .cage import Cage
+from .vertices import NonLinearVertex
 
 
 class M6L2L3Prism(Cage):
     """
     Represents a cage topology graph.
 
     Unoptimized construction
@@ -221,26 +222,24 @@
         | 4-functional groups (ligand B): 8 to 10
 
     See :class:`.Cage` for more details and examples.
 
     """
 
     _non_linears = (
-        NonLinearVertex(0, [-1, -1/np.sqrt(3), 1]),
-        NonLinearVertex(1, [1, -1/np.sqrt(3), 1]),
-        NonLinearVertex(2, [0, 2/np.sqrt(3), 1]),
-
-        NonLinearVertex(3, [-1, -1/np.sqrt(3), -1]),
-        NonLinearVertex(4, [1, -1/np.sqrt(3), -1]),
-        NonLinearVertex(5, [0, 2/np.sqrt(3), -1]),
+        NonLinearVertex(0, [-1, -1 / np.sqrt(3), 1]),
+        NonLinearVertex(1, [1, -1 / np.sqrt(3), 1]),
+        NonLinearVertex(2, [0, 2 / np.sqrt(3), 1]),
+        NonLinearVertex(3, [-1, -1 / np.sqrt(3), -1]),
+        NonLinearVertex(4, [1, -1 / np.sqrt(3), -1]),
+        NonLinearVertex(5, [0, 2 / np.sqrt(3), -1]),
     )
 
     _vertex_prototypes = (
         *_non_linears,
-
         NonLinearVertex.init_at_center(
             id=6,
             vertices=(
                 _non_linears[0],
                 _non_linears[1],
                 _non_linears[2],
             ),
@@ -249,15 +248,14 @@
             id=7,
             vertices=(
                 _non_linears[3],
                 _non_linears[4],
                 _non_linears[5],
             ),
         ),
-
         NonLinearVertex.init_at_center(
             id=8,
             vertices=(
                 _non_linears[0],
                 _non_linears[1],
                 _non_linears[3],
                 _non_linears[4],
```

### Comparing `stk-2022.6.17.0/src/stk/molecular/topology_graphs/cage/metal_topologies/m8l6_cube.py` & `stk-2023.7.5.0/src/stk/_internal/topology_graphs/cage/m8l6_cube.py`

 * *Files 5% similar despite different names*

```diff
@@ -1,16 +1,17 @@
 """
 M8L6 Cube
 =========
 
 """
 
-from ...topology_graph import Edge
-from ..cage import Cage
-from ..vertices import NonLinearVertex
+from stk._internal.topology_graphs.edge import Edge
+
+from .cage import Cage
+from .vertices import NonLinearVertex
 
 
 class M8L6Cube(Cage):
     """
     Represents a cage topology graph.
 
     Unoptimized construction
@@ -242,15 +243,14 @@
             position=[-1, 1, -1],
             use_neighbor_placement=False,
         ),
     )
 
     _vertex_prototypes = (
         *_non_linears,
-
         NonLinearVertex(
             id=8,
             position=[0, 0, 1],
             use_neighbor_placement=False,
         ),
         NonLinearVertex(
             id=9,
@@ -280,35 +280,30 @@
     )
 
     _edge_prototypes = (
         Edge(0, _vertex_prototypes[0], _vertex_prototypes[8]),
         Edge(1, _vertex_prototypes[1], _vertex_prototypes[8]),
         Edge(2, _vertex_prototypes[2], _vertex_prototypes[8]),
         Edge(3, _vertex_prototypes[3], _vertex_prototypes[8]),
-
         Edge(4, _vertex_prototypes[4], _vertex_prototypes[9]),
         Edge(5, _vertex_prototypes[5], _vertex_prototypes[9]),
         Edge(6, _vertex_prototypes[1], _vertex_prototypes[9]),
         Edge(7, _vertex_prototypes[0], _vertex_prototypes[9]),
-
         Edge(8, _vertex_prototypes[4], _vertex_prototypes[10]),
         Edge(9, _vertex_prototypes[0], _vertex_prototypes[10]),
         Edge(10, _vertex_prototypes[3], _vertex_prototypes[10]),
         Edge(11, _vertex_prototypes[7], _vertex_prototypes[10]),
-
         Edge(12, _vertex_prototypes[3], _vertex_prototypes[11]),
         Edge(13, _vertex_prototypes[2], _vertex_prototypes[11]),
         Edge(14, _vertex_prototypes[6], _vertex_prototypes[11]),
         Edge(15, _vertex_prototypes[7], _vertex_prototypes[11]),
-
         Edge(16, _vertex_prototypes[5], _vertex_prototypes[12]),
         Edge(17, _vertex_prototypes[4], _vertex_prototypes[12]),
         Edge(18, _vertex_prototypes[7], _vertex_prototypes[12]),
         Edge(19, _vertex_prototypes[6], _vertex_prototypes[12]),
-
         Edge(20, _vertex_prototypes[1], _vertex_prototypes[13]),
         Edge(21, _vertex_prototypes[5], _vertex_prototypes[13]),
         Edge(22, _vertex_prototypes[6], _vertex_prototypes[13]),
         Edge(23, _vertex_prototypes[2], _vertex_prototypes[13]),
     )
 
     _num_windows = 4
```

### Comparing `stk-2022.6.17.0/src/stk/molecular/topology_graphs/cage/three_plus_four/six_plus_eight.py` & `stk-2023.7.5.0/src/stk/_internal/topology_graphs/cage/six_plus_eight.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,16 +1,17 @@
 """
 Six Plus Eight
 ==============
 
 """
 
-from ...topology_graph import Edge
-from ..cage import Cage
-from ..vertices import NonLinearVertex
+from stk._internal.topology_graphs.edge import Edge
+
+from .cage import Cage
+from .vertices import NonLinearVertex
 
 
 class SixPlusEight(Cage):
     """
     Represents a cage topology graph.
 
     Unoptimized construction
@@ -110,119 +111,108 @@
 
     _x = 1
     _non_linears = (
         NonLinearVertex(0, [-_x, _x, 0]),
         NonLinearVertex(1, [-_x, -_x, 0]),
         NonLinearVertex(2, [_x, _x, 0]),
         NonLinearVertex(3, [_x, -_x, 0]),
-
         NonLinearVertex(4, [0, 0, _x]),
         NonLinearVertex(5, [0, 0, -_x]),
     )
 
     _vertex_prototypes = (
         *_non_linears,
         NonLinearVertex.init_at_center(
             id=6,
             vertices=(
                 _non_linears[0],
                 _non_linears[4],
-                _non_linears[1]
+                _non_linears[1],
             ),
-
         ),
         NonLinearVertex.init_at_center(
             id=7,
             vertices=(
                 _non_linears[1],
                 _non_linears[4],
-                _non_linears[3]
+                _non_linears[3],
             ),
         ),
         NonLinearVertex.init_at_center(
             id=8,
             vertices=(
                 _non_linears[4],
                 _non_linears[3],
-                _non_linears[2]
+                _non_linears[2],
             ),
         ),
         NonLinearVertex.init_at_center(
             id=9,
             vertices=(
                 _non_linears[4],
                 _non_linears[2],
-                _non_linears[0]
+                _non_linears[0],
             ),
         ),
-
         NonLinearVertex.init_at_center(
             id=10,
             vertices=(
                 _non_linears[0],
                 _non_linears[5],
-                _non_linears[1]
+                _non_linears[1],
             ),
         ),
         NonLinearVertex.init_at_center(
             id=11,
             vertices=(
                 _non_linears[5],
                 _non_linears[1],
-                _non_linears[3]
+                _non_linears[3],
             ),
         ),
         NonLinearVertex.init_at_center(
             id=12,
             vertices=(
                 _non_linears[3],
                 _non_linears[5],
-                _non_linears[2]
+                _non_linears[2],
             ),
         ),
         NonLinearVertex.init_at_center(
             id=13,
             vertices=(
                 _non_linears[2],
                 _non_linears[5],
-                _non_linears[0]
+                _non_linears[0],
             ),
         ),
     )
 
     _edge_prototypes = (
         Edge(0, _vertex_prototypes[6], _vertex_prototypes[0]),
         Edge(1, _vertex_prototypes[6], _vertex_prototypes[4]),
         Edge(2, _vertex_prototypes[6], _vertex_prototypes[1]),
-
         Edge(3, _vertex_prototypes[7], _vertex_prototypes[1]),
         Edge(4, _vertex_prototypes[7], _vertex_prototypes[4]),
         Edge(5, _vertex_prototypes[7], _vertex_prototypes[3]),
-
         Edge(6, _vertex_prototypes[8], _vertex_prototypes[4]),
         Edge(7, _vertex_prototypes[8], _vertex_prototypes[3]),
         Edge(8, _vertex_prototypes[8], _vertex_prototypes[2]),
-
         Edge(9, _vertex_prototypes[9], _vertex_prototypes[4]),
         Edge(10, _vertex_prototypes[9], _vertex_prototypes[2]),
         Edge(11, _vertex_prototypes[9], _vertex_prototypes[0]),
-
         Edge(12, _vertex_prototypes[10], _vertex_prototypes[0]),
         Edge(13, _vertex_prototypes[10], _vertex_prototypes[5]),
         Edge(14, _vertex_prototypes[10], _vertex_prototypes[1]),
-
         Edge(15, _vertex_prototypes[11], _vertex_prototypes[5]),
         Edge(16, _vertex_prototypes[11], _vertex_prototypes[1]),
         Edge(17, _vertex_prototypes[11], _vertex_prototypes[3]),
-
         Edge(18, _vertex_prototypes[12], _vertex_prototypes[3]),
         Edge(19, _vertex_prototypes[12], _vertex_prototypes[5]),
         Edge(20, _vertex_prototypes[12], _vertex_prototypes[2]),
-
         Edge(21, _vertex_prototypes[13], _vertex_prototypes[2]),
         Edge(22, _vertex_prototypes[13], _vertex_prototypes[5]),
         Edge(23, _vertex_prototypes[13], _vertex_prototypes[0]),
-
     )
 
     _num_windows = 12
     _num_window_types = 1
```

### Comparing `stk-2022.6.17.0/src/stk/molecular/topology_graphs/cage/three_plus_three/four_plus_four.py` & `stk-2023.7.5.0/src/stk/_internal/topology_graphs/cage/four_plus_four.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,16 +1,17 @@
 """
 Four Plus Four
 ==============
 
 """
 
-from ...topology_graph import Edge
-from ..cage import Cage
-from ..vertices import NonLinearVertex
+from stk._internal.topology_graphs.edge import Edge
+
+from .cage import Cage
+from .vertices import NonLinearVertex
 
 
 class FourPlusFour(Cage):
     """
     Represents a cube cage topology graph.
 
     Unoptimized construction
@@ -101,31 +102,30 @@
 
     _x = 1
     _vertex_prototypes = (
         NonLinearVertex(0, [-_x, _x, -_x], False),
         NonLinearVertex(1, [-_x, -_x, -_x], False),
         NonLinearVertex(2, [_x, _x, -_x], False),
         NonLinearVertex(3, [_x, -_x, -_x], False),
-
         NonLinearVertex(4, [-_x, _x, _x], False),
         NonLinearVertex(5, [-_x, -_x, _x], False),
         NonLinearVertex(6, [_x, _x, _x], False),
-        NonLinearVertex(7, [_x, -_x, _x], False)
+        NonLinearVertex(7, [_x, -_x, _x], False),
     )
 
     _edge_prototypes = (
         Edge(0, _vertex_prototypes[0], _vertex_prototypes[1]),
         Edge(1, _vertex_prototypes[0], _vertex_prototypes[2]),
         Edge(2, _vertex_prototypes[0], _vertex_prototypes[4]),
         Edge(3, _vertex_prototypes[1], _vertex_prototypes[3]),
         Edge(4, _vertex_prototypes[1], _vertex_prototypes[5]),
         Edge(5, _vertex_prototypes[2], _vertex_prototypes[6]),
         Edge(6, _vertex_prototypes[2], _vertex_prototypes[3]),
         Edge(7, _vertex_prototypes[3], _vertex_prototypes[7]),
         Edge(8, _vertex_prototypes[4], _vertex_prototypes[6]),
         Edge(9, _vertex_prototypes[4], _vertex_prototypes[5]),
         Edge(10, _vertex_prototypes[5], _vertex_prototypes[7]),
-        Edge(11, _vertex_prototypes[6], _vertex_prototypes[7])
+        Edge(11, _vertex_prototypes[6], _vertex_prototypes[7]),
     )
 
     _num_windows = 6
     _num_window_types = 1
```

### Comparing `stk-2022.6.17.0/src/stk/molecular/topology_graphs/cage/three_plus_three/one_plus_one.py` & `stk-2023.7.5.0/src/stk/_internal/topology_graphs/cage/one_plus_one.py`

 * *Files 8% similar despite different names*

```diff
@@ -2,19 +2,19 @@
 One Plus One
 ============
 
 """
 
 import numpy as np
 
-from stk.utilities import get_acute_vector
+from stk._internal.topology_graphs.edge import Edge
+from stk._internal.utilities.utilities import get_acute_vector
 
-from ...topology_graph import Edge
-from ..cage import Cage
-from ..vertices import NonLinearVertex
+from .cage import Cage
+from .vertices import NonLinearVertex
 
 
 class OnePlusOneVertex(NonLinearVertex):
     def __init__(
         self,
         id,
         position,
@@ -36,17 +36,15 @@
         return clone
 
     def place_building_block(self, building_block, edges):
         building_block = building_block.with_centroid(
             position=self._position,
             atom_ids=building_block.get_placer_ids(),
         )
-        edge_centroid = (
-            sum(edge.get_position() for edge in edges) / len(edges)
-        )
+        edge_centroid = sum(edge.get_position() for edge in edges) / len(edges)
         core_centroid = building_block.get_centroid(
             atom_ids=building_block.get_core_atom_ids(),
         )
         placer_centroid = building_block.get_centroid(
             atom_ids=building_block.get_placer_ids(),
         )
         building_block = building_block.with_rotation_between_vectors(
@@ -62,21 +60,19 @@
         fg_bonder_centroid = building_block.get_centroid(
             atom_ids=next(
                 building_block.get_functional_groups()
             ).get_placer_ids(),
         )
         start = fg_bonder_centroid - self._position
         edge_coord = edges[self._aligner_edge].get_position()
-        building_block = (
-            building_block.with_rotation_to_minimize_angle(
-                start=start,
-                target=edge_coord - edge_centroid,
-                axis=self._edge_normal,
-                origin=self._position,
-            )
+        building_block = building_block.with_rotation_to_minimize_angle(
+            start=start,
+            target=edge_coord - edge_centroid,
+            axis=self._edge_normal,
+            origin=self._position,
         )
         return building_block.get_position_matrix()
 
 
 class OnePlusOne(Cage):
     """
     Represents a capsule cage topology graph.
@@ -173,34 +169,33 @@
 
     See :class:`.Cage` for more details and examples.
 
     """
 
     _x = 1
     _vertex_prototypes = (
-        OnePlusOneVertex(0, [_x, 0., 0.], [1, 0, 0], False),
-        OnePlusOneVertex(1, [-_x, 0., 0.], [-1, 0, 0], False),
-
+        OnePlusOneVertex(0, [_x, 0.0, 0.0], [1, 0, 0], False),
+        OnePlusOneVertex(1, [-_x, 0.0, 0.0], [-1, 0, 0], False),
     )
     _edge_prototypes = (
         Edge(
             id=0,
             vertex1=_vertex_prototypes[0],
             vertex2=_vertex_prototypes[1],
-            position=np.array([0., 1., 0.]),
+            position=np.array([0.0, 1.0, 0.0]),
         ),
         Edge(
             id=1,
             vertex1=_vertex_prototypes[0],
             vertex2=_vertex_prototypes[1],
-            position=np.array([0., -1., 1.]),
+            position=np.array([0.0, -1.0, 1.0]),
         ),
         Edge(
             id=2,
             vertex1=_vertex_prototypes[0],
             vertex2=_vertex_prototypes[1],
-            position=np.array([0., -1., -1.]),
+            position=np.array([0.0, -1.0, -1.0]),
         ),
     )
 
     _num_windows = 3
     _num_window_types = 1
```

### Comparing `stk-2022.6.17.0/src/stk/molecular/topology_graphs/cage/three_plus_three/two_plus_two.py` & `stk-2023.7.5.0/src/stk/_internal/topology_graphs/cage/two_plus_two.py`

 * *Files 6% similar despite different names*

```diff
@@ -2,17 +2,18 @@
 Two Plus Two
 ============
 
 """
 
 import numpy as np
 
-from ...topology_graph import Edge
-from ..cage import Cage
-from ..vertices import NonLinearVertex
+from stk._internal.topology_graphs.cage.cage import Cage
+from stk._internal.topology_graphs.edge import Edge
+
+from .vertices import NonLinearVertex
 
 
 class TwoPlusTwo(Cage):
     """
     Represents a tetrahedron cage topology graph.
 
     Unoptimized construction
@@ -99,26 +100,24 @@
 
     See :class:`.Cage` for more details and examples.
 
     """
 
     _x = 1
     _vertex_prototypes = (
-        NonLinearVertex(0, [_x, 0, -_x/np.sqrt(2)], False),
-        NonLinearVertex(1, [-_x, 0, -_x/np.sqrt(2)], False),
-        NonLinearVertex(2, [0, _x, _x/np.sqrt(2)], False),
-        NonLinearVertex(3, [0, -_x, _x/np.sqrt(2)], False)
+        NonLinearVertex(0, [_x, 0, -_x / np.sqrt(2)], False),
+        NonLinearVertex(1, [-_x, 0, -_x / np.sqrt(2)], False),
+        NonLinearVertex(2, [0, _x, _x / np.sqrt(2)], False),
+        NonLinearVertex(3, [0, -_x, _x / np.sqrt(2)], False),
     )
 
     _edge_prototypes = (
         Edge(0, _vertex_prototypes[0], _vertex_prototypes[1]),
         Edge(1, _vertex_prototypes[0], _vertex_prototypes[2]),
         Edge(2, _vertex_prototypes[0], _vertex_prototypes[3]),
-
         Edge(3, _vertex_prototypes[1], _vertex_prototypes[2]),
         Edge(4, _vertex_prototypes[1], _vertex_prototypes[3]),
-
-        Edge(5, _vertex_prototypes[2], _vertex_prototypes[3])
+        Edge(5, _vertex_prototypes[2], _vertex_prototypes[3]),
     )
 
     _num_windows = 4
     _num_window_types = 1
```

### Comparing `stk-2022.6.17.0/src/stk/molecular/topology_graphs/cage/two_plus_five/twelve_plus_thirty.py` & `stk-2023.7.5.0/src/stk/_internal/topology_graphs/cage/twelve_plus_thirty.py`

 * *Files 1% similar despite different names*

```diff
@@ -2,17 +2,18 @@
 Twelve Plus Thirty
 ==================
 
 """
 
 from scipy.constants import golden
 
-from ...topology_graph import Edge
-from ..cage import Cage
-from ..vertices import LinearVertex, NonLinearVertex
+from stk._internal.topology_graphs.edge import Edge
+
+from .cage import Cage
+from .vertices import LinearVertex, NonLinearVertex
 
 
 class TwelvePlusThirty(Cage):
     """
     Represents a icosahedron cage topology graph.
 
     Unoptimized construction
@@ -123,15 +124,15 @@
         NonLinearVertex(4, [1, golden, 0]),
         NonLinearVertex(5, [-1, golden, 0]),
         NonLinearVertex(6, [1, -golden, 0]),
         NonLinearVertex(7, [-1, -golden, 0]),
         NonLinearVertex(8, [golden, 0, 1]),
         NonLinearVertex(9, [-golden, 0, 1]),
         NonLinearVertex(10, [golden, 0, -1]),
-        NonLinearVertex(11, [-golden, 0, -1])
+        NonLinearVertex(11, [-golden, 0, -1]),
     )
 
     _vertex_prototypes = (
         *_non_linears,
         LinearVertex.init_at_center(
             id=12,
             vertices=(_non_linears[0], _non_linears[1]),
@@ -150,15 +151,16 @@
         ),
         LinearVertex.init_at_center(
             id=16,
             vertices=(_non_linears[0], _non_linears[8]),
         ),
         LinearVertex.init_at_center(
             id=17,
-            vertices=(_non_linears[8], _non_linears[1]),),
+            vertices=(_non_linears[8], _non_linears[1]),
+        ),
         LinearVertex.init_at_center(
             id=18,
             vertices=(_non_linears[1], _non_linears[9]),
         ),
         LinearVertex.init_at_center(
             id=19,
             vertices=(_non_linears[9], _non_linears[5]),
@@ -246,88 +248,74 @@
         LinearVertex.init_at_center(
             id=40,
             vertices=(_non_linears[6], _non_linears[3]),
         ),
         LinearVertex.init_at_center(
             id=41,
             vertices=(_non_linears[10], _non_linears[3]),
-        )
+        ),
     )
 
     _edge_prototypes = (
         Edge(0, _vertex_prototypes[12], _vertex_prototypes[0]),
         Edge(1, _vertex_prototypes[12], _vertex_prototypes[1]),
         Edge(2, _vertex_prototypes[13], _vertex_prototypes[0]),
         Edge(3, _vertex_prototypes[13], _vertex_prototypes[9]),
-
         Edge(4, _vertex_prototypes[14], _vertex_prototypes[0]),
         Edge(5, _vertex_prototypes[14], _vertex_prototypes[5]),
         Edge(6, _vertex_prototypes[15], _vertex_prototypes[0]),
         Edge(7, _vertex_prototypes[15], _vertex_prototypes[4]),
-
         Edge(8, _vertex_prototypes[16], _vertex_prototypes[0]),
         Edge(9, _vertex_prototypes[16], _vertex_prototypes[8]),
         Edge(10, _vertex_prototypes[17], _vertex_prototypes[8]),
         Edge(11, _vertex_prototypes[17], _vertex_prototypes[1]),
-
         Edge(12, _vertex_prototypes[18], _vertex_prototypes[1]),
         Edge(13, _vertex_prototypes[18], _vertex_prototypes[9]),
         Edge(14, _vertex_prototypes[19], _vertex_prototypes[9]),
         Edge(15, _vertex_prototypes[19], _vertex_prototypes[5]),
-
         Edge(16, _vertex_prototypes[20], _vertex_prototypes[5]),
         Edge(17, _vertex_prototypes[20], _vertex_prototypes[4]),
         Edge(18, _vertex_prototypes[21], _vertex_prototypes[4]),
         Edge(19, _vertex_prototypes[21], _vertex_prototypes[8]),
-
         Edge(20, _vertex_prototypes[22], _vertex_prototypes[5]),
         Edge(21, _vertex_prototypes[22], _vertex_prototypes[2]),
         Edge(22, _vertex_prototypes[23], _vertex_prototypes[5]),
         Edge(23, _vertex_prototypes[23], _vertex_prototypes[11]),
-
         Edge(24, _vertex_prototypes[24], _vertex_prototypes[9]),
         Edge(25, _vertex_prototypes[24], _vertex_prototypes[11]),
         Edge(26, _vertex_prototypes[25], _vertex_prototypes[9]),
         Edge(27, _vertex_prototypes[25], _vertex_prototypes[7]),
-
         Edge(28, _vertex_prototypes[26], _vertex_prototypes[1]),
         Edge(29, _vertex_prototypes[26], _vertex_prototypes[7]),
         Edge(30, _vertex_prototypes[27], _vertex_prototypes[1]),
         Edge(31, _vertex_prototypes[27], _vertex_prototypes[6]),
-
         Edge(32, _vertex_prototypes[28], _vertex_prototypes[8]),
         Edge(33, _vertex_prototypes[28], _vertex_prototypes[6]),
         Edge(34, _vertex_prototypes[29], _vertex_prototypes[8]),
         Edge(35, _vertex_prototypes[29], _vertex_prototypes[10]),
-
         Edge(36, _vertex_prototypes[30], _vertex_prototypes[4]),
         Edge(37, _vertex_prototypes[30], _vertex_prototypes[10]),
         Edge(38, _vertex_prototypes[31], _vertex_prototypes[4]),
         Edge(39, _vertex_prototypes[31], _vertex_prototypes[2]),
-
         Edge(40, _vertex_prototypes[32], _vertex_prototypes[2]),
         Edge(41, _vertex_prototypes[32], _vertex_prototypes[11]),
         Edge(42, _vertex_prototypes[33], _vertex_prototypes[11]),
         Edge(43, _vertex_prototypes[33], _vertex_prototypes[7]),
-
         Edge(44, _vertex_prototypes[34], _vertex_prototypes[7]),
         Edge(45, _vertex_prototypes[34], _vertex_prototypes[6]),
         Edge(46, _vertex_prototypes[35], _vertex_prototypes[6]),
         Edge(47, _vertex_prototypes[35], _vertex_prototypes[10]),
-
         Edge(48, _vertex_prototypes[36], _vertex_prototypes[10]),
         Edge(49, _vertex_prototypes[36], _vertex_prototypes[2]),
         Edge(50, _vertex_prototypes[37], _vertex_prototypes[2]),
         Edge(51, _vertex_prototypes[37], _vertex_prototypes[3]),
-
         Edge(52, _vertex_prototypes[38], _vertex_prototypes[11]),
         Edge(53, _vertex_prototypes[38], _vertex_prototypes[3]),
         Edge(54, _vertex_prototypes[39], _vertex_prototypes[7]),
         Edge(55, _vertex_prototypes[39], _vertex_prototypes[3]),
-
         Edge(56, _vertex_prototypes[40], _vertex_prototypes[6]),
         Edge(57, _vertex_prototypes[40], _vertex_prototypes[3]),
         Edge(58, _vertex_prototypes[41], _vertex_prototypes[10]),
         Edge(59, _vertex_prototypes[41], _vertex_prototypes[3]),
     )
 
     _num_windows = 20
```

### Comparing `stk-2022.6.17.0/src/stk/molecular/topology_graphs/cage/two_plus_four/eight_plus_sixteen.py` & `stk-2023.7.5.0/src/stk/_internal/topology_graphs/cage/eight_plus_sixteen.py`

 * *Files 3% similar despite different names*

```diff
@@ -2,17 +2,18 @@
 Eight Plus Sixteen
 ==================
 
 """
 
 import numpy as np
 
-from ...topology_graph import Edge
-from ..cage import Cage
-from ..vertices import LinearVertex, NonLinearVertex
+from stk._internal.topology_graphs.cage.cage import Cage
+from stk._internal.topology_graphs.edge import Edge
+
+from .vertices import LinearVertex, NonLinearVertex
 
 
 class EightPlusSixteen(Cage):
     """
     Represents a cage topology graph.
 
     Unoptimized construction
@@ -111,28 +112,26 @@
 
     See :class:`.Cage` for more details and examples.
 
     """
 
     _x = 2
     _non_linears = (
-        NonLinearVertex(0, [-0.5*_x, 0.5*_x, -0.35*_x]),
-        NonLinearVertex(1, [-0.5*_x, -0.5*_x, -0.35*_x]),
-        NonLinearVertex(2, [0.5*_x, -0.5*_x, -0.35*_x]),
-        NonLinearVertex(3, [0.5*_x, 0.5*_x, -0.35*_x]),
-
-        NonLinearVertex(4, [-_x*np.sqrt(2)/2, 0, _x*0.35]),
-        NonLinearVertex(5, [0, -_x*np.sqrt(2)/2, _x*0.35]),
-        NonLinearVertex(6, [_x*np.sqrt(2)/2, 0, _x*0.35]),
-        NonLinearVertex(7, [0, _x*np.sqrt(2)/2, _x*0.35]),
+        NonLinearVertex(0, [-0.5 * _x, 0.5 * _x, -0.35 * _x]),
+        NonLinearVertex(1, [-0.5 * _x, -0.5 * _x, -0.35 * _x]),
+        NonLinearVertex(2, [0.5 * _x, -0.5 * _x, -0.35 * _x]),
+        NonLinearVertex(3, [0.5 * _x, 0.5 * _x, -0.35 * _x]),
+        NonLinearVertex(4, [-_x * np.sqrt(2) / 2, 0, _x * 0.35]),
+        NonLinearVertex(5, [0, -_x * np.sqrt(2) / 2, _x * 0.35]),
+        NonLinearVertex(6, [_x * np.sqrt(2) / 2, 0, _x * 0.35]),
+        NonLinearVertex(7, [0, _x * np.sqrt(2) / 2, _x * 0.35]),
     )
 
     _vertex_prototypes = (
         *_non_linears,
-
         LinearVertex.init_at_center(
             id=8,
             vertices=(_non_linears[1], _non_linears[5]),
         ),
         LinearVertex.init_at_center(
             id=9,
             vertices=(_non_linears[2], _non_linears[5]),
@@ -141,15 +140,14 @@
             id=10,
             vertices=(_non_linears[0], _non_linears[4]),
         ),
         LinearVertex.init_at_center(
             id=11,
             vertices=(_non_linears[1], _non_linears[4]),
         ),
-
         LinearVertex.init_at_center(
             id=12,
             vertices=(_non_linears[2], _non_linears[6]),
         ),
         LinearVertex.init_at_center(
             id=13,
             vertices=(_non_linears[3], _non_linears[6]),
@@ -158,15 +156,14 @@
             id=14,
             vertices=(_non_linears[0], _non_linears[7]),
         ),
         LinearVertex.init_at_center(
             id=15,
             vertices=(_non_linears[3], _non_linears[7]),
         ),
-
         LinearVertex.init_at_center(
             id=16,
             vertices=(_non_linears[0], _non_linears[1]),
         ),
         LinearVertex.init_at_center(
             id=17,
             vertices=(_non_linears[1], _non_linears[2]),
@@ -175,15 +172,14 @@
             id=18,
             vertices=(_non_linears[2], _non_linears[3]),
         ),
         LinearVertex.init_at_center(
             id=19,
             vertices=(_non_linears[3], _non_linears[0]),
         ),
-
         LinearVertex.init_at_center(
             id=20,
             vertices=(_non_linears[4], _non_linears[5]),
         ),
         LinearVertex.init_at_center(
             id=21,
             vertices=(_non_linears[5], _non_linears[6]),
@@ -192,62 +188,46 @@
             id=22,
             vertices=(_non_linears[6], _non_linears[7]),
         ),
         LinearVertex.init_at_center(
             id=23,
             vertices=(_non_linears[7], _non_linears[4]),
         ),
-
     )
 
     _edge_prototypes = (
         Edge(0, _vertex_prototypes[8], _vertex_prototypes[1]),
         Edge(1, _vertex_prototypes[8], _vertex_prototypes[5]),
-
         Edge(2, _vertex_prototypes[9], _vertex_prototypes[2]),
         Edge(3, _vertex_prototypes[9], _vertex_prototypes[5]),
-
         Edge(4, _vertex_prototypes[10], _vertex_prototypes[0]),
         Edge(5, _vertex_prototypes[10], _vertex_prototypes[4]),
-
         Edge(6, _vertex_prototypes[11], _vertex_prototypes[1]),
         Edge(7, _vertex_prototypes[11], _vertex_prototypes[4]),
-
         Edge(8, _vertex_prototypes[12], _vertex_prototypes[2]),
         Edge(9, _vertex_prototypes[12], _vertex_prototypes[6]),
-
         Edge(10, _vertex_prototypes[13], _vertex_prototypes[3]),
         Edge(11, _vertex_prototypes[13], _vertex_prototypes[6]),
-
         Edge(12, _vertex_prototypes[14], _vertex_prototypes[0]),
         Edge(13, _vertex_prototypes[14], _vertex_prototypes[7]),
-
         Edge(14, _vertex_prototypes[15], _vertex_prototypes[3]),
         Edge(15, _vertex_prototypes[15], _vertex_prototypes[7]),
-
         Edge(16, _vertex_prototypes[16], _vertex_prototypes[0]),
         Edge(17, _vertex_prototypes[16], _vertex_prototypes[1]),
-
         Edge(18, _vertex_prototypes[17], _vertex_prototypes[1]),
         Edge(19, _vertex_prototypes[17], _vertex_prototypes[2]),
-
         Edge(20, _vertex_prototypes[18], _vertex_prototypes[2]),
         Edge(21, _vertex_prototypes[18], _vertex_prototypes[3]),
-
         Edge(22, _vertex_prototypes[19], _vertex_prototypes[3]),
         Edge(23, _vertex_prototypes[19], _vertex_prototypes[0]),
-
         Edge(24, _vertex_prototypes[20], _vertex_prototypes[4]),
         Edge(25, _vertex_prototypes[20], _vertex_prototypes[5]),
-
         Edge(26, _vertex_prototypes[21], _vertex_prototypes[5]),
         Edge(27, _vertex_prototypes[21], _vertex_prototypes[6]),
-
         Edge(28, _vertex_prototypes[22], _vertex_prototypes[6]),
         Edge(29, _vertex_prototypes[22], _vertex_prototypes[7]),
-
         Edge(30, _vertex_prototypes[23], _vertex_prototypes[7]),
         Edge(31, _vertex_prototypes[23], _vertex_prototypes[4]),
     )
 
     _num_windows = 10
     _num_window_types = 2
```

### Comparing `stk-2022.6.17.0/src/stk/molecular/topology_graphs/cage/two_plus_four/five_plus_ten.py` & `stk-2023.7.5.0/src/stk/_internal/topology_graphs/cage/five_plus_ten.py`

 * *Files 6% similar despite different names*

```diff
@@ -2,17 +2,18 @@
 Five Plus Ten
 =============
 
 """
 
 import numpy as np
 
-from ...topology_graph import Edge
-from ..cage import Cage
-from ..vertices import LinearVertex, NonLinearVertex
+from stk._internal.topology_graphs.edge import Edge
+
+from .cage import Cage
+from .vertices import LinearVertex, NonLinearVertex
 
 
 class FivePlusTen(Cage):
     """
     Represents a cage topology graph.
 
     Unoptimized construction
@@ -109,67 +110,55 @@
         | 4-functional groups: 0 to 4
         | 2-functional groups: 5 to 14
 
     See :class:`.Cage` for more details and examples.
 
     """
 
-    _c1 = np.cos(2*np.pi/5)
-    _c2 = np.cos(np.pi/5)
-    _s1 = np.sin(2*np.pi/5)
-    _s2 = np.sin(4*np.pi/5)
+    _c1 = np.cos(2 * np.pi / 5)
+    _c2 = np.cos(np.pi / 5)
+    _s1 = np.sin(2 * np.pi / 5)
+    _s2 = np.sin(4 * np.pi / 5)
 
     _vertex_prototypes = (
         NonLinearVertex(0, [0, 1, 0], False),
         NonLinearVertex(1, [_s1, _c1, 0], False),
         NonLinearVertex(2, [_s2, -_c2, 0], False),
-
         NonLinearVertex(3, [-_s2, -_c2, 0], False),
         NonLinearVertex(4, [-_s1, _c1, 0], False),
-
-        LinearVertex(5, [_s1, 1+_c1, 0.5], False),
-        LinearVertex(6, [_s1, 1+_c1, -0.5], False),
-
-        LinearVertex(7, [_s1+_s2, _c1-_c2, 0.5], False),
-        LinearVertex(8, [_s1+_s2, _c1-_c2, -0.5], False),
-
-        LinearVertex(9, [0, -2*_c2, 0.5], False),
-        LinearVertex(10, [0, -2*_c2, -0.5], False),
-
-        LinearVertex(11, [-_s2-_s1, -_c2+_c1, 0.5], False),
-        LinearVertex(12, [-_s2-_s1, -_c2+_c1, -0.5], False),
-
-        LinearVertex(13, [-_s1, 1+_c1, 0.5], False),
-        LinearVertex(14, [-_s1, 1+_c1, -0.5], False),
-
+        LinearVertex(5, [_s1, 1 + _c1, 0.5], False),
+        LinearVertex(6, [_s1, 1 + _c1, -0.5], False),
+        LinearVertex(7, [_s1 + _s2, _c1 - _c2, 0.5], False),
+        LinearVertex(8, [_s1 + _s2, _c1 - _c2, -0.5], False),
+        LinearVertex(9, [0, -2 * _c2, 0.5], False),
+        LinearVertex(10, [0, -2 * _c2, -0.5], False),
+        LinearVertex(11, [-_s2 - _s1, -_c2 + _c1, 0.5], False),
+        LinearVertex(12, [-_s2 - _s1, -_c2 + _c1, -0.5], False),
+        LinearVertex(13, [-_s1, 1 + _c1, 0.5], False),
+        LinearVertex(14, [-_s1, 1 + _c1, -0.5], False),
     )
 
     _edge_prototypes = (
         Edge(0, _vertex_prototypes[5], _vertex_prototypes[0]),
         Edge(1, _vertex_prototypes[5], _vertex_prototypes[1]),
         Edge(2, _vertex_prototypes[6], _vertex_prototypes[0]),
         Edge(3, _vertex_prototypes[6], _vertex_prototypes[1]),
-
         Edge(4, _vertex_prototypes[7], _vertex_prototypes[1]),
         Edge(5, _vertex_prototypes[7], _vertex_prototypes[2]),
         Edge(6, _vertex_prototypes[8], _vertex_prototypes[1]),
         Edge(7, _vertex_prototypes[8], _vertex_prototypes[2]),
-
         Edge(8, _vertex_prototypes[9], _vertex_prototypes[2]),
         Edge(9, _vertex_prototypes[9], _vertex_prototypes[3]),
         Edge(10, _vertex_prototypes[10], _vertex_prototypes[2]),
         Edge(11, _vertex_prototypes[10], _vertex_prototypes[3]),
-
         Edge(12, _vertex_prototypes[11], _vertex_prototypes[3]),
         Edge(13, _vertex_prototypes[11], _vertex_prototypes[4]),
         Edge(14, _vertex_prototypes[12], _vertex_prototypes[3]),
         Edge(15, _vertex_prototypes[12], _vertex_prototypes[4]),
-
         Edge(16, _vertex_prototypes[13], _vertex_prototypes[4]),
         Edge(17, _vertex_prototypes[13], _vertex_prototypes[0]),
         Edge(18, _vertex_prototypes[14], _vertex_prototypes[4]),
         Edge(19, _vertex_prototypes[14], _vertex_prototypes[0]),
-
     )
 
     _num_windows = 7
     _num_window_types = 2
```

### Comparing `stk-2022.6.17.0/src/stk/molecular/topology_graphs/cage/two_plus_four/four_plus_eight.py` & `stk-2023.7.5.0/src/stk/_internal/topology_graphs/cage/four_plus_eight.py`

 * *Files 12% similar despite different names*

```diff
@@ -1,16 +1,19 @@
 """
 Four Plus Eight
 ===============
 
 """
 
-from ...topology_graph import Edge
-from ..cage import Cage
-from ..vertices import LinearVertex, NonLinearVertex
+from stk._internal.topology_graphs.cage.cage import Cage
+from stk._internal.topology_graphs.cage.vertices import (
+    LinearVertex,
+    NonLinearVertex,
+)
+from stk._internal.topology_graphs.edge import Edge
 
 
 class FourPlusEight(Cage):
     """
     Represents a cage topology graph.
 
     Unoptimized construction
@@ -110,54 +113,40 @@
     See :class:`.Cage` for more details and examples.
 
     """
 
     _vertex_prototypes = (
         NonLinearVertex(0, [-1, -1, 0], False),
         NonLinearVertex(1, [-1, 1, 0], False),
-
         NonLinearVertex(2, [1, -1, 0], False),
         NonLinearVertex(3, [1, 1, 0], False),
-
         LinearVertex(4, [-2, 0, 1], False),
         LinearVertex(5, [-2, 0, -1], False),
-
         LinearVertex(6, [0, 2, 1], False),
         LinearVertex(7, [0, 2, -1], False),
-
         LinearVertex(8, [0, -2, 1], False),
         LinearVertex(9, [0, -2, -1], False),
-
         LinearVertex(10, [2, 0, 1], False),
         LinearVertex(11, [2, 0, -1], False),
-
     )
 
     _edge_prototypes = (
         Edge(0, _vertex_prototypes[4], _vertex_prototypes[0]),
         Edge(1, _vertex_prototypes[4], _vertex_prototypes[1]),
-
         Edge(2, _vertex_prototypes[5], _vertex_prototypes[0]),
         Edge(3, _vertex_prototypes[5], _vertex_prototypes[1]),
-
         Edge(4, _vertex_prototypes[6], _vertex_prototypes[1]),
         Edge(5, _vertex_prototypes[6], _vertex_prototypes[3]),
-
         Edge(6, _vertex_prototypes[7], _vertex_prototypes[1]),
         Edge(7, _vertex_prototypes[7], _vertex_prototypes[3]),
-
         Edge(8, _vertex_prototypes[8], _vertex_prototypes[0]),
         Edge(9, _vertex_prototypes[8], _vertex_prototypes[2]),
-
         Edge(10, _vertex_prototypes[9], _vertex_prototypes[0]),
         Edge(11, _vertex_prototypes[9], _vertex_prototypes[2]),
-
         Edge(12, _vertex_prototypes[10], _vertex_prototypes[2]),
         Edge(13, _vertex_prototypes[10], _vertex_prototypes[3]),
-
         Edge(14, _vertex_prototypes[11], _vertex_prototypes[2]),
         Edge(15, _vertex_prototypes[11], _vertex_prototypes[3]),
-
     )
 
     _num_windows = 6
     _num_window_types = 2
```

### Comparing `stk-2022.6.17.0/src/stk/molecular/topology_graphs/cage/two_plus_four/six_plus_twelve.py` & `stk-2023.7.5.0/src/stk/_internal/topology_graphs/cage/eight_plus_twelve.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,39 +1,40 @@
 """
-Six Plus Twelve
-===============
+Eight Plus Twelve
+=================
 
 """
 
-from ...topology_graph import Edge
-from ..cage import Cage
-from ..vertices import LinearVertex, NonLinearVertex
+from stk._internal.topology_graphs.edge import Edge
 
+from .cage import Cage
+from .vertices import LinearVertex, NonLinearVertex
 
-class SixPlusTwelve(Cage):
+
+class EightPlusTwelve(Cage):
     """
     Represents a cage topology graph.
 
     Unoptimized construction
 
     .. moldoc::
 
         import moldoc.molecule as molecule
         import stk
 
         bb1 = stk.BuildingBlock(
-            smiles='BrCCBr',
-            functional_groups=[stk.BromoFactory()],
+            smiles='NC1CCCCC1N',
+            functional_groups=[stk.PrimaryAminoFactory()],
         )
         bb2 = stk.BuildingBlock(
-            smiles='Brc1c(Br)cc(Br)c(Br)c1',
-            functional_groups=[stk.BromoFactory()],
+            smiles='O=Cc1cc(C=O)cc(C=O)c1',
+            functional_groups=[stk.AldehydeFactory()],
         )
         cage = stk.ConstructedMolecule(
-            topology_graph=stk.cage.SixPlusTwelve((bb1, bb2)),
+            topology_graph=stk.cage.EightPlusTwelve((bb1, bb2)),
         )
 
         moldoc_display_molecule = molecule.Molecule(
             atoms=(
                 molecule.Atom(
                     atomic_number=atom.get_atomic_number(),
                     position=position,
@@ -47,33 +48,33 @@
                     atom1_id=bond.get_atom1().get_id(),
                     atom2_id=bond.get_atom2().get_id(),
                     order=bond.get_order(),
                 ) for bond in cage.get_bonds()
             ),
         )
 
-    :class:`.Collapser` optimized construction
+    :class:`.MCHammer` optimized construction
 
     .. moldoc::
 
         import moldoc.molecule as molecule
         import stk
 
         bb1 = stk.BuildingBlock(
-            smiles='BrCCBr',
-            functional_groups=[stk.BromoFactory()],
+            smiles='NC1CCCCC1N',
+            functional_groups=[stk.PrimaryAminoFactory()],
         )
         bb2 = stk.BuildingBlock(
-            smiles='Brc1c(Br)cc(Br)c(Br)c1',
-            functional_groups=[stk.BromoFactory()],
+            smiles='O=Cc1cc(C=O)cc(C=O)c1',
+            functional_groups=[stk.AldehydeFactory()],
         )
         cage = stk.ConstructedMolecule(
-            topology_graph=stk.cage.SixPlusTwelve(
+            topology_graph=stk.cage.EightPlusTwelve(
                 building_blocks=(bb1, bb2),
-                optimizer=stk.Collapser(),
+                optimizer=stk.MCHammer(num_steps=1000),
             ),
         )
 
         moldoc_display_molecule = molecule.Molecule(
             atoms=(
                 molecule.Atom(
                     atomic_number=atom.get_atomic_number(),
@@ -88,122 +89,118 @@
                     atom1_id=bond.get_atom1().get_id(),
                     atom2_id=bond.get_atom2().get_id(),
                     order=bond.get_order(),
                 ) for bond in cage.get_bonds()
             ),
         )
 
-    Nonlinear building blocks with four functional groups are
+    Nonlinear building blocks with three functional groups are
     required for this topology.
 
     Linear building blocks with two functional groups are required for
     this topology.
 
     When using a :class:`dict` for the `building_blocks` parameter,
     as in :ref:`cage-topology-graph-examples`:
     *Multi-Building Block Cage Construction*, a
     :class:`.BuildingBlock`, with the following number of functional
     groups, needs to be assigned to each of the following vertex ids:
 
-        | 4-functional groups: 0 to 5
-        | 2-functional groups: 6 to 17
+        | 3-functional groups: 0 to 7
+        | 2-functional groups: 8 to 19
 
     See :class:`.Cage` for more details and examples.
 
     """
 
     _non_linears = (
-        NonLinearVertex(0, [-1, -1, 0]),
-        NonLinearVertex(1, [-1, 1, 0]),
-        NonLinearVertex(2, [1, -1, 0]),
-        NonLinearVertex(3, [1, 1, 0]),
-        NonLinearVertex(4, [0, 0, 1]),
-        NonLinearVertex(5, [0, 0, -1]),
+        NonLinearVertex(0, [-1, 1, -1]),
+        NonLinearVertex(1, [-1, -1, -1]),
+        NonLinearVertex(2, [1, 1, -1]),
+        NonLinearVertex(3, [1, -1, -1]),
+        NonLinearVertex(4, [-1, 1, 1]),
+        NonLinearVertex(5, [-1, -1, 1]),
+        NonLinearVertex(6, [1, 1, 1]),
+        NonLinearVertex(7, [1, -1, 1]),
     )
 
     _vertex_prototypes = (
         *_non_linears,
         LinearVertex.init_at_center(
-            id=6,
-            vertices=(_non_linears[0], _non_linears[1]),
-        ),
-        LinearVertex.init_at_center(
-            id=7,
-            vertices=(_non_linears[1], _non_linears[3]),
-        ),
-        LinearVertex.init_at_center(
             id=8,
-            vertices=(_non_linears[3], _non_linears[2]),
+            vertices=(_non_linears[0], _non_linears[2]),
         ),
-
         LinearVertex.init_at_center(
             id=9,
-            vertices=(_non_linears[0], _non_linears[2]),
+            vertices=(_non_linears[0], _non_linears[1]),
         ),
         LinearVertex.init_at_center(
             id=10,
-            vertices=(_non_linears[4], _non_linears[0]),
+            vertices=(_non_linears[1], _non_linears[3]),
         ),
         LinearVertex.init_at_center(
             id=11,
-            vertices=(_non_linears[4], _non_linears[1]),
+            vertices=(_non_linears[2], _non_linears[3]),
         ),
-
         LinearVertex.init_at_center(
             id=12,
-            vertices=(_non_linears[4], _non_linears[2]),
+            vertices=(_non_linears[4], _non_linears[6]),
         ),
         LinearVertex.init_at_center(
             id=13,
-            vertices=(_non_linears[4], _non_linears[3]),
+            vertices=(_non_linears[4], _non_linears[5]),
         ),
         LinearVertex.init_at_center(
             id=14,
-            vertices=(_non_linears[5], _non_linears[0]),
+            vertices=(_non_linears[5], _non_linears[7]),
         ),
-
         LinearVertex.init_at_center(
             id=15,
-            vertices=(_non_linears[5], _non_linears[1]),
+            vertices=(_non_linears[6], _non_linears[7]),
         ),
         LinearVertex.init_at_center(
             id=16,
-            vertices=(_non_linears[5], _non_linears[2]),
+            vertices=(_non_linears[0], _non_linears[4]),
         ),
         LinearVertex.init_at_center(
             id=17,
-            vertices=(_non_linears[5], _non_linears[3]),
-        )
+            vertices=(_non_linears[1], _non_linears[5]),
+        ),
+        LinearVertex.init_at_center(
+            id=18,
+            vertices=(_non_linears[2], _non_linears[6]),
+        ),
+        LinearVertex.init_at_center(
+            id=19,
+            vertices=(_non_linears[3], _non_linears[7]),
+        ),
     )
 
     _edge_prototypes = (
-        Edge(0, _vertex_prototypes[6], _vertex_prototypes[0]),
-        Edge(1, _vertex_prototypes[6], _vertex_prototypes[1]),
-        Edge(2, _vertex_prototypes[7], _vertex_prototypes[1]),
-        Edge(3, _vertex_prototypes[7], _vertex_prototypes[3]),
-        Edge(4, _vertex_prototypes[8], _vertex_prototypes[3]),
-        Edge(5, _vertex_prototypes[8], _vertex_prototypes[2]),
-
-        Edge(6, _vertex_prototypes[9], _vertex_prototypes[0]),
-        Edge(7, _vertex_prototypes[9], _vertex_prototypes[2]),
-        Edge(8, _vertex_prototypes[10], _vertex_prototypes[4]),
-        Edge(9, _vertex_prototypes[10], _vertex_prototypes[0]),
-        Edge(10, _vertex_prototypes[11], _vertex_prototypes[4]),
-        Edge(11, _vertex_prototypes[11], _vertex_prototypes[1]),
-
-        Edge(12, _vertex_prototypes[12], _vertex_prototypes[4]),
-        Edge(13, _vertex_prototypes[12], _vertex_prototypes[2]),
-        Edge(14, _vertex_prototypes[13], _vertex_prototypes[4]),
-        Edge(15, _vertex_prototypes[13], _vertex_prototypes[3]),
-        Edge(16, _vertex_prototypes[14], _vertex_prototypes[5]),
-        Edge(17, _vertex_prototypes[14], _vertex_prototypes[0]),
-
-        Edge(18, _vertex_prototypes[15], _vertex_prototypes[5]),
-        Edge(19, _vertex_prototypes[15], _vertex_prototypes[1]),
-        Edge(20, _vertex_prototypes[16], _vertex_prototypes[5]),
-        Edge(21, _vertex_prototypes[16], _vertex_prototypes[2]),
-        Edge(22, _vertex_prototypes[17], _vertex_prototypes[5]),
-        Edge(23, _vertex_prototypes[17], _vertex_prototypes[3]),
+        Edge(0, _vertex_prototypes[8], _vertex_prototypes[0]),
+        Edge(1, _vertex_prototypes[8], _vertex_prototypes[2]),
+        Edge(2, _vertex_prototypes[9], _vertex_prototypes[0]),
+        Edge(3, _vertex_prototypes[9], _vertex_prototypes[1]),
+        Edge(4, _vertex_prototypes[10], _vertex_prototypes[1]),
+        Edge(5, _vertex_prototypes[10], _vertex_prototypes[3]),
+        Edge(6, _vertex_prototypes[11], _vertex_prototypes[2]),
+        Edge(7, _vertex_prototypes[11], _vertex_prototypes[3]),
+        Edge(8, _vertex_prototypes[12], _vertex_prototypes[4]),
+        Edge(9, _vertex_prototypes[12], _vertex_prototypes[6]),
+        Edge(10, _vertex_prototypes[13], _vertex_prototypes[4]),
+        Edge(11, _vertex_prototypes[13], _vertex_prototypes[5]),
+        Edge(12, _vertex_prototypes[14], _vertex_prototypes[5]),
+        Edge(13, _vertex_prototypes[14], _vertex_prototypes[7]),
+        Edge(14, _vertex_prototypes[15], _vertex_prototypes[6]),
+        Edge(15, _vertex_prototypes[15], _vertex_prototypes[7]),
+        Edge(16, _vertex_prototypes[16], _vertex_prototypes[0]),
+        Edge(17, _vertex_prototypes[16], _vertex_prototypes[4]),
+        Edge(18, _vertex_prototypes[17], _vertex_prototypes[1]),
+        Edge(19, _vertex_prototypes[17], _vertex_prototypes[5]),
+        Edge(20, _vertex_prototypes[18], _vertex_prototypes[2]),
+        Edge(21, _vertex_prototypes[18], _vertex_prototypes[6]),
+        Edge(22, _vertex_prototypes[19], _vertex_prototypes[3]),
+        Edge(23, _vertex_prototypes[19], _vertex_prototypes[7]),
     )
 
-    _num_windows = 8
+    _num_windows = 6
     _num_window_types = 1
```

### Comparing `stk-2022.6.17.0/src/stk/molecular/topology_graphs/cage/two_plus_four/ten_plus_twenty.py` & `stk-2023.7.5.0/src/stk/_internal/topology_graphs/cage/ten_plus_twenty.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,16 +1,17 @@
 """
 Ten Plus Twenty
 ===============
 
 """
 
-from ...topology_graph import Edge
-from ..cage import Cage
-from ..vertices import LinearVertex, NonLinearVertex
+from stk._internal.topology_graphs.edge import Edge
+
+from .cage import Cage
+from .vertices import LinearVertex, NonLinearVertex
 
 
 class TenPlusTwenty(Cage):
     """
     Represents a cage topology graph.
 
     Unoptimized construction
@@ -114,27 +115,24 @@
     _x = 1.5
     _z = _x / 2
     _non_linears = (
         NonLinearVertex(0, [-_x, _x, -_z]),
         NonLinearVertex(1, [-_x, -_x, -_z]),
         NonLinearVertex(2, [_x, _x, -_z]),
         NonLinearVertex(3, [_x, -_x, -_z]),
-
         NonLinearVertex(4, [-_x, _x, _z]),
         NonLinearVertex(5, [-_x, -_x, _z]),
         NonLinearVertex(6, [_x, _x, _z]),
         NonLinearVertex(7, [_x, -_x, _z]),
-
         NonLinearVertex(8, [0, 0, _x]),
         NonLinearVertex(9, [0, 0, -_x]),
     )
 
     _vertex_prototypes = (
         *_non_linears,
-
         LinearVertex.init_at_center(
             id=10,
             vertices=(_non_linears[0], _non_linears[2]),
         ),
         LinearVertex.init_at_center(
             id=11,
             vertices=(_non_linears[0], _non_linears[1]),
@@ -143,15 +141,14 @@
             id=12,
             vertices=(_non_linears[1], _non_linears[3]),
         ),
         LinearVertex.init_at_center(
             id=13,
             vertices=(_non_linears[2], _non_linears[3]),
         ),
-
         LinearVertex.init_at_center(
             id=14,
             vertices=(_non_linears[4], _non_linears[6]),
         ),
         LinearVertex.init_at_center(
             id=15,
             vertices=(_non_linears[4], _non_linears[5]),
@@ -160,15 +157,14 @@
             id=16,
             vertices=(_non_linears[5], _non_linears[7]),
         ),
         LinearVertex.init_at_center(
             id=17,
             vertices=(_non_linears[6], _non_linears[7]),
         ),
-
         LinearVertex.init_at_center(
             id=18,
             vertices=(_non_linears[0], _non_linears[4]),
         ),
         LinearVertex.init_at_center(
             id=19,
             vertices=(_non_linears[1], _non_linears[5]),
@@ -177,15 +173,14 @@
             id=20,
             vertices=(_non_linears[2], _non_linears[6]),
         ),
         LinearVertex.init_at_center(
             id=21,
             vertices=(_non_linears[3], _non_linears[7]),
         ),
-
         LinearVertex.init_at_center(
             id=22,
             vertices=(_non_linears[8], _non_linears[4]),
         ),
         LinearVertex.init_at_center(
             id=23,
             vertices=(_non_linears[8], _non_linears[5]),
@@ -194,15 +189,14 @@
             id=24,
             vertices=(_non_linears[8], _non_linears[6]),
         ),
         LinearVertex.init_at_center(
             id=25,
             vertices=(_non_linears[8], _non_linears[7]),
         ),
-
         LinearVertex.init_at_center(
             id=26,
             vertices=(_non_linears[9], _non_linears[0]),
         ),
         LinearVertex.init_at_center(
             id=27,
             vertices=(_non_linears[9], _non_linears[1]),
@@ -210,63 +204,54 @@
         LinearVertex.init_at_center(
             id=28,
             vertices=(_non_linears[9], _non_linears[2]),
         ),
         LinearVertex.init_at_center(
             id=29,
             vertices=(_non_linears[9], _non_linears[3]),
-        )
+        ),
     )
 
     _edge_prototypes = (
         Edge(0, _vertex_prototypes[10], _vertex_prototypes[0]),
         Edge(1, _vertex_prototypes[10], _vertex_prototypes[2]),
         Edge(2, _vertex_prototypes[11], _vertex_prototypes[0]),
         Edge(3, _vertex_prototypes[11], _vertex_prototypes[1]),
-
         Edge(4, _vertex_prototypes[12], _vertex_prototypes[1]),
         Edge(5, _vertex_prototypes[12], _vertex_prototypes[3]),
         Edge(6, _vertex_prototypes[13], _vertex_prototypes[2]),
         Edge(7, _vertex_prototypes[13], _vertex_prototypes[3]),
-
         Edge(8, _vertex_prototypes[14], _vertex_prototypes[4]),
         Edge(9, _vertex_prototypes[14], _vertex_prototypes[6]),
         Edge(10, _vertex_prototypes[15], _vertex_prototypes[4]),
         Edge(11, _vertex_prototypes[15], _vertex_prototypes[5]),
-
         Edge(12, _vertex_prototypes[16], _vertex_prototypes[5]),
         Edge(13, _vertex_prototypes[16], _vertex_prototypes[7]),
         Edge(14, _vertex_prototypes[17], _vertex_prototypes[6]),
         Edge(15, _vertex_prototypes[17], _vertex_prototypes[7]),
-
         Edge(16, _vertex_prototypes[18], _vertex_prototypes[0]),
         Edge(17, _vertex_prototypes[18], _vertex_prototypes[4]),
         Edge(18, _vertex_prototypes[19], _vertex_prototypes[1]),
         Edge(19, _vertex_prototypes[19], _vertex_prototypes[5]),
-
         Edge(20, _vertex_prototypes[20], _vertex_prototypes[2]),
         Edge(21, _vertex_prototypes[20], _vertex_prototypes[6]),
         Edge(22, _vertex_prototypes[21], _vertex_prototypes[3]),
         Edge(23, _vertex_prototypes[21], _vertex_prototypes[7]),
-
         Edge(24, _vertex_prototypes[22], _vertex_prototypes[8]),
         Edge(25, _vertex_prototypes[22], _vertex_prototypes[4]),
         Edge(26, _vertex_prototypes[23], _vertex_prototypes[8]),
         Edge(27, _vertex_prototypes[23], _vertex_prototypes[5]),
-
         Edge(28, _vertex_prototypes[24], _vertex_prototypes[8]),
         Edge(29, _vertex_prototypes[24], _vertex_prototypes[6]),
         Edge(30, _vertex_prototypes[25], _vertex_prototypes[8]),
         Edge(31, _vertex_prototypes[25], _vertex_prototypes[7]),
-
         Edge(32, _vertex_prototypes[26], _vertex_prototypes[9]),
         Edge(33, _vertex_prototypes[26], _vertex_prototypes[0]),
         Edge(34, _vertex_prototypes[27], _vertex_prototypes[9]),
         Edge(35, _vertex_prototypes[27], _vertex_prototypes[1]),
-
         Edge(36, _vertex_prototypes[28], _vertex_prototypes[9]),
         Edge(37, _vertex_prototypes[28], _vertex_prototypes[2]),
         Edge(38, _vertex_prototypes[29], _vertex_prototypes[9]),
         Edge(39, _vertex_prototypes[29], _vertex_prototypes[3]),
     )
 
     _num_windows = 12
```

### Comparing `stk-2022.6.17.0/src/stk/molecular/topology_graphs/cage/two_plus_four/three_plus_six.py` & `stk-2023.7.5.0/src/stk/_internal/topology_graphs/cage/three_plus_six.py`

 * *Files 10% similar despite different names*

```diff
@@ -2,17 +2,18 @@
 Three Plus Six
 ==============
 
 """
 
 import numpy as np
 
-from ...topology_graph import Edge
-from ..cage import Cage
-from ..vertices import LinearVertex, NonLinearVertex
+from stk._internal.topology_graphs.edge import Edge
+
+from .cage import Cage
+from .vertices import LinearVertex, NonLinearVertex
 
 
 class ThreePlusSix(Cage):
     """
     Represents a cage topology graph.
 
     Unoptimized construction
@@ -111,44 +112,35 @@
 
     See :class:`.Cage` for more details and examples.
 
     """
 
     _x = 1
     _vertex_prototypes = (
-        NonLinearVertex(0, [-2*_x, -_x*np.sqrt(3), 0], False),
-        NonLinearVertex(1, [2*_x, -_x*np.sqrt(3), 0], False),
-        NonLinearVertex(2, [0, _x*np.sqrt(3), 0], False),
-
-        LinearVertex(3, [0, -2*_x*np.sqrt(3), _x], False),
-        LinearVertex(4, [0, -2*_x*np.sqrt(3), -_x], False),
-
-        LinearVertex(5, [2*_x, 0, _x], False),
-        LinearVertex(6, [2*_x, 0, -_x], False),
-
-        LinearVertex(7, [-2*_x, 0, _x], False),
-        LinearVertex(8, [-2*_x, 0, -_x], False),
+        NonLinearVertex(0, [-2 * _x, -_x * np.sqrt(3), 0], False),
+        NonLinearVertex(1, [2 * _x, -_x * np.sqrt(3), 0], False),
+        NonLinearVertex(2, [0, _x * np.sqrt(3), 0], False),
+        LinearVertex(3, [0, -2 * _x * np.sqrt(3), _x], False),
+        LinearVertex(4, [0, -2 * _x * np.sqrt(3), -_x], False),
+        LinearVertex(5, [2 * _x, 0, _x], False),
+        LinearVertex(6, [2 * _x, 0, -_x], False),
+        LinearVertex(7, [-2 * _x, 0, _x], False),
+        LinearVertex(8, [-2 * _x, 0, -_x], False),
     )
 
     _edge_prototypes = (
         Edge(0, _vertex_prototypes[3], _vertex_prototypes[0]),
         Edge(1, _vertex_prototypes[3], _vertex_prototypes[1]),
-
         Edge(2, _vertex_prototypes[4], _vertex_prototypes[0]),
         Edge(3, _vertex_prototypes[4], _vertex_prototypes[1]),
-
         Edge(4, _vertex_prototypes[5], _vertex_prototypes[1]),
         Edge(5, _vertex_prototypes[5], _vertex_prototypes[2]),
-
         Edge(6, _vertex_prototypes[6], _vertex_prototypes[1]),
         Edge(7, _vertex_prototypes[6], _vertex_prototypes[2]),
-
         Edge(8, _vertex_prototypes[7], _vertex_prototypes[0]),
         Edge(9, _vertex_prototypes[7], _vertex_prototypes[2]),
-
         Edge(10, _vertex_prototypes[8], _vertex_prototypes[0]),
         Edge(11, _vertex_prototypes[8], _vertex_prototypes[2]),
-
     )
 
     _num_windows = 5
     _num_window_types = 2
```

### Comparing `stk-2022.6.17.0/src/stk/molecular/topology_graphs/cage/two_plus_four/two_plus_four.py` & `stk-2023.7.5.0/src/stk/_internal/topology_graphs/cage/two_plus_three.py`

 * *Files 10% similar despite different names*

```diff
@@ -1,39 +1,42 @@
 """
-Two Plus Four
-=============
+Two Plus Three
+==============
 
 """
 
-from ...topology_graph import Edge
-from ..cage import Cage
-from ..vertices import LinearVertex, NonLinearVertex
+import numpy as np
 
+from stk._internal.topology_graphs.edge import Edge
 
-class TwoPlusFour(Cage):
+from .cage import Cage
+from .vertices import LinearVertex, NonLinearVertex
+
+
+class TwoPlusThree(Cage):
     """
-    Represents a capsule cage topology graph.
+    Represents a cage topology graph.
 
     Unoptimized construction
 
     .. moldoc::
 
         import moldoc.molecule as molecule
         import stk
 
         bb1 = stk.BuildingBlock(
-            smiles='C1=CC=C(C(=C1)Br)Br',
-            functional_groups=[stk.BromoFactory()],
+            smiles='NC1CCCCC1N',
+            functional_groups=[stk.PrimaryAminoFactory()],
         )
         bb2 = stk.BuildingBlock(
-            smiles='C1(=C(C(=C1Br)Br)Br)Br',
-            functional_groups=[stk.BromoFactory()],
+            smiles='O=Cc1cc(C=O)cc(C=O)c1',
+            functional_groups=[stk.AldehydeFactory()],
         )
         cage = stk.ConstructedMolecule(
-            topology_graph=stk.cage.TwoPlusFour((bb1, bb2)),
+            topology_graph=stk.cage.TwoPlusThree((bb1, bb2)),
         )
 
         moldoc_display_molecule = molecule.Molecule(
             atoms=(
                 molecule.Atom(
                     atomic_number=atom.get_atomic_number(),
                     position=position,
@@ -47,33 +50,33 @@
                     atom1_id=bond.get_atom1().get_id(),
                     atom2_id=bond.get_atom2().get_id(),
                     order=bond.get_order(),
                 ) for bond in cage.get_bonds()
             ),
         )
 
-    :class:`.Collapser` optimized construction
+    :class:`.MCHammer` optimized construction
 
     .. moldoc::
 
         import moldoc.molecule as molecule
         import stk
 
         bb1 = stk.BuildingBlock(
-            smiles='C1=CC=C(C(=C1)Br)Br',
-            functional_groups=[stk.BromoFactory()],
+            smiles='NC1CCCCC1N',
+            functional_groups=[stk.PrimaryAminoFactory()],
         )
         bb2 = stk.BuildingBlock(
-            smiles='C1(=C(C(=C1Br)Br)Br)Br',
-            functional_groups=[stk.BromoFactory()],
+            smiles='O=Cc1cc(C=O)cc(C=O)c1',
+            functional_groups=[stk.AldehydeFactory()],
         )
         cage = stk.ConstructedMolecule(
-            topology_graph=stk.cage.TwoPlusFour(
+            topology_graph=stk.cage.TwoPlusThree(
                 building_blocks=(bb1, bb2),
-                optimizer=stk.Collapser(),
+                optimizer=stk.MCHammer(),
             ),
         )
 
         moldoc_display_molecule = molecule.Molecule(
             atoms=(
                 molecule.Atom(
                     atomic_number=atom.get_atomic_number(),
@@ -88,49 +91,45 @@
                     atom1_id=bond.get_atom1().get_id(),
                     atom2_id=bond.get_atom2().get_id(),
                     order=bond.get_order(),
                 ) for bond in cage.get_bonds()
             ),
         )
 
-    Nonlinear building blocks with four functional groups are
+    Nonlinear building blocks with three functional groups are
     required for this topology.
 
     Linear building blocks with two functional groups are required for
     this topology.
 
     When using a :class:`dict` for the `building_blocks` parameter,
     as in :ref:`cage-topology-graph-examples`:
     *Multi-Building Block Cage Construction*, a
     :class:`.BuildingBlock`, with the following number of functional
     groups, needs to be assigned to each of the following vertex ids:
 
-        | 4-functional groups: (0, 1)
-        | 2-functional groups: (2, 3, 4, 5)
+        | 3-functional groups: (0, 1)
+        | 2-functional groups: (2, 3, 4)
 
     See :class:`.Cage` for more details and examples.
 
     """
 
     _vertex_prototypes = (
-        NonLinearVertex(0, [0, 0, -1]),
-        NonLinearVertex(1, [0, 0, 1]),
-
-        LinearVertex(2, [2, 0, 0], False),
-        LinearVertex(3, [-2, 0, 0], False),
-        LinearVertex(4, [0, 2, 0], False),
-        LinearVertex(5, [0, -2, 0], False),
+        NonLinearVertex(0, [0, 0, 1]),
+        NonLinearVertex(1, [0, 0, -1]),
+        LinearVertex(2, [-1, -0.5 * np.sqrt(3), 0], False),
+        LinearVertex(3, [1, -0.5 * np.sqrt(3), 0], False),
+        LinearVertex(4, [0, 0.5 * np.sqrt(3), 0], False),
     )
 
     _edge_prototypes = (
-        Edge(0, _vertex_prototypes[2], _vertex_prototypes[0]),
-        Edge(1, _vertex_prototypes[2], _vertex_prototypes[1]),
-        Edge(2, _vertex_prototypes[3], _vertex_prototypes[0]),
-        Edge(3, _vertex_prototypes[3], _vertex_prototypes[1]),
-        Edge(4, _vertex_prototypes[4], _vertex_prototypes[0]),
-        Edge(5, _vertex_prototypes[4], _vertex_prototypes[1]),
-        Edge(6, _vertex_prototypes[5], _vertex_prototypes[0]),
-        Edge(7, _vertex_prototypes[5], _vertex_prototypes[1])
+        Edge(0, _vertex_prototypes[0], _vertex_prototypes[2]),
+        Edge(1, _vertex_prototypes[0], _vertex_prototypes[3]),
+        Edge(2, _vertex_prototypes[0], _vertex_prototypes[4]),
+        Edge(3, _vertex_prototypes[1], _vertex_prototypes[2]),
+        Edge(4, _vertex_prototypes[1], _vertex_prototypes[3]),
+        Edge(5, _vertex_prototypes[1], _vertex_prototypes[4]),
     )
 
-    _num_windows = 4
+    _num_windows = 3
     _num_window_types = 1
```

### Comparing `stk-2022.6.17.0/src/stk/molecular/topology_graphs/cage/two_plus_three/eight_plus_twelve.py` & `stk-2023.7.5.0/src/stk/_internal/topology_graphs/cage/six_plus_nine.py`

 * *Files 12% similar despite different names*

```diff
@@ -1,19 +1,22 @@
 """
-Eight Plus Twelve
-=================
+Six Plus Nine
+=============
 
 """
 
-from ...topology_graph import Edge
-from ..cage import Cage
-from ..vertices import LinearVertex, NonLinearVertex
+import numpy as np
 
+from stk._internal.topology_graphs.edge import Edge
 
-class EightPlusTwelve(Cage):
+from .cage import Cage
+from .vertices import LinearVertex, NonLinearVertex
+
+
+class SixPlusNine(Cage):
     """
     Represents a cage topology graph.
 
     Unoptimized construction
 
     .. moldoc::
 
@@ -25,15 +28,15 @@
             functional_groups=[stk.PrimaryAminoFactory()],
         )
         bb2 = stk.BuildingBlock(
             smiles='O=Cc1cc(C=O)cc(C=O)c1',
             functional_groups=[stk.AldehydeFactory()],
         )
         cage = stk.ConstructedMolecule(
-            topology_graph=stk.cage.EightPlusTwelve((bb1, bb2)),
+            topology_graph=stk.cage.SixPlusNine((bb1, bb2)),
         )
 
         moldoc_display_molecule = molecule.Molecule(
             atoms=(
                 molecule.Atom(
                     atomic_number=atom.get_atomic_number(),
                     position=position,
@@ -63,17 +66,17 @@
             functional_groups=[stk.PrimaryAminoFactory()],
         )
         bb2 = stk.BuildingBlock(
             smiles='O=Cc1cc(C=O)cc(C=O)c1',
             functional_groups=[stk.AldehydeFactory()],
         )
         cage = stk.ConstructedMolecule(
-            topology_graph=stk.cage.EightPlusTwelve(
+            topology_graph=stk.cage.SixPlusNine(
                 building_blocks=(bb1, bb2),
-                optimizer=stk.MCHammer(num_steps=1000),
+                optimizer=stk.MCHammer(),
             ),
         )
 
         moldoc_display_molecule = molecule.Molecule(
             atoms=(
                 molecule.Atom(
                     atomic_number=atom.get_atomic_number(),
@@ -100,122 +103,86 @@
 
     When using a :class:`dict` for the `building_blocks` parameter,
     as in :ref:`cage-topology-graph-examples`:
     *Multi-Building Block Cage Construction*, a
     :class:`.BuildingBlock`, with the following number of functional
     groups, needs to be assigned to each of the following vertex ids:
 
-        | 3-functional groups: 0 to 7
-        | 2-functional groups: 8 to 19
+        | 3-functional groups: 0 to 5
+        | 2-functional groups: 5 to 14
 
     See :class:`.Cage` for more details and examples.
 
     """
 
+    # source: http://eusebeia.dyndns.org/4d/prism3
     _non_linears = (
-        NonLinearVertex(0, [-1, 1, -1]),
-        NonLinearVertex(1, [-1, -1, -1]),
-        NonLinearVertex(2, [1, 1, -1]),
-        NonLinearVertex(3, [1, -1, -1]),
-
-        NonLinearVertex(4, [-1, 1, 1]),
-        NonLinearVertex(5, [-1, -1, 1]),
-        NonLinearVertex(6, [1, 1, 1]),
-        NonLinearVertex(7, [1, -1, 1])
+        NonLinearVertex(0, [-1, -1 / np.sqrt(3), -1]),
+        NonLinearVertex(1, [-1, -1 / np.sqrt(3), 1]),
+        NonLinearVertex(2, [1, -1 / np.sqrt(3), -1]),
+        NonLinearVertex(3, [1, -1 / np.sqrt(3), 1]),
+        NonLinearVertex(4, [0, 2 / np.sqrt(3), -1]),
+        NonLinearVertex(5, [0, 2 / np.sqrt(3), 1]),
     )
-
     _vertex_prototypes = (
         *_non_linears,
-
-        LinearVertex.init_at_center(
-            id=8,
-            vertices=(_non_linears[0], _non_linears[2]),
-        ),
         LinearVertex.init_at_center(
-            id=9,
+            id=6,
             vertices=(_non_linears[0], _non_linears[1]),
         ),
         LinearVertex.init_at_center(
-            id=10,
-            vertices=(_non_linears[1], _non_linears[3]),
+            id=7,
+            vertices=(_non_linears[0], _non_linears[2]),
         ),
         LinearVertex.init_at_center(
-            id=11,
+            id=8,
             vertices=(_non_linears[2], _non_linears[3]),
         ),
-
-        LinearVertex.init_at_center(
-            id=12,
-            vertices=(_non_linears[4], _non_linears[6]),
-        ),
         LinearVertex.init_at_center(
-            id=13,
-            vertices=(_non_linears[4], _non_linears[5]),
-        ),
-        LinearVertex.init_at_center(
-            id=14,
-            vertices=(_non_linears[5], _non_linears[7]),
+            id=9,
+            vertices=(_non_linears[1], _non_linears[3]),
         ),
         LinearVertex.init_at_center(
-            id=15,
-            vertices=(_non_linears[6], _non_linears[7]),
+            id=10,
+            vertices=(_non_linears[0], _non_linears[4]),
         ),
-
         LinearVertex.init_at_center(
-            id=16,
-            vertices=(_non_linears[0], _non_linears[4]),
+            id=11,
+            vertices=(_non_linears[2], _non_linears[4]),
         ),
         LinearVertex.init_at_center(
-            id=17,
+            id=12,
             vertices=(_non_linears[1], _non_linears[5]),
         ),
         LinearVertex.init_at_center(
-            id=18,
-            vertices=(_non_linears[2], _non_linears[6]),
+            id=13,
+            vertices=(_non_linears[3], _non_linears[5]),
         ),
         LinearVertex.init_at_center(
-            id=19,
-            vertices=(_non_linears[3], _non_linears[7]),
+            id=14,
+            vertices=(_non_linears[4], _non_linears[5]),
         ),
     )
 
     _edge_prototypes = (
-        Edge(0, _vertex_prototypes[8], _vertex_prototypes[0]),
-        Edge(1, _vertex_prototypes[8], _vertex_prototypes[2]),
-
-        Edge(2, _vertex_prototypes[9], _vertex_prototypes[0]),
-        Edge(3, _vertex_prototypes[9], _vertex_prototypes[1]),
-
-        Edge(4, _vertex_prototypes[10], _vertex_prototypes[1]),
-        Edge(5, _vertex_prototypes[10], _vertex_prototypes[3]),
-
-        Edge(6, _vertex_prototypes[11], _vertex_prototypes[2]),
-        Edge(7, _vertex_prototypes[11], _vertex_prototypes[3]),
-
-        Edge(8, _vertex_prototypes[12], _vertex_prototypes[4]),
-        Edge(9, _vertex_prototypes[12], _vertex_prototypes[6]),
-
-        Edge(10, _vertex_prototypes[13], _vertex_prototypes[4]),
-        Edge(11, _vertex_prototypes[13], _vertex_prototypes[5]),
-
-        Edge(12, _vertex_prototypes[14], _vertex_prototypes[5]),
-        Edge(13, _vertex_prototypes[14], _vertex_prototypes[7]),
-
-        Edge(14, _vertex_prototypes[15], _vertex_prototypes[6]),
-        Edge(15, _vertex_prototypes[15], _vertex_prototypes[7]),
-
-        Edge(16, _vertex_prototypes[16], _vertex_prototypes[0]),
-        Edge(17, _vertex_prototypes[16], _vertex_prototypes[4]),
-
-        Edge(18, _vertex_prototypes[17], _vertex_prototypes[1]),
-        Edge(19, _vertex_prototypes[17], _vertex_prototypes[5]),
-
-        Edge(20, _vertex_prototypes[18], _vertex_prototypes[2]),
-        Edge(21, _vertex_prototypes[18], _vertex_prototypes[6]),
-
-        Edge(22, _vertex_prototypes[19], _vertex_prototypes[3]),
-        Edge(23, _vertex_prototypes[19], _vertex_prototypes[7]),
-
+        Edge(0, _vertex_prototypes[6], _vertex_prototypes[0]),
+        Edge(1, _vertex_prototypes[6], _vertex_prototypes[1]),
+        Edge(2, _vertex_prototypes[7], _vertex_prototypes[0]),
+        Edge(3, _vertex_prototypes[7], _vertex_prototypes[2]),
+        Edge(4, _vertex_prototypes[8], _vertex_prototypes[2]),
+        Edge(5, _vertex_prototypes[8], _vertex_prototypes[3]),
+        Edge(6, _vertex_prototypes[9], _vertex_prototypes[1]),
+        Edge(7, _vertex_prototypes[9], _vertex_prototypes[3]),
+        Edge(8, _vertex_prototypes[10], _vertex_prototypes[0]),
+        Edge(9, _vertex_prototypes[10], _vertex_prototypes[4]),
+        Edge(10, _vertex_prototypes[11], _vertex_prototypes[2]),
+        Edge(11, _vertex_prototypes[11], _vertex_prototypes[4]),
+        Edge(12, _vertex_prototypes[12], _vertex_prototypes[1]),
+        Edge(13, _vertex_prototypes[12], _vertex_prototypes[5]),
+        Edge(14, _vertex_prototypes[13], _vertex_prototypes[3]),
+        Edge(15, _vertex_prototypes[13], _vertex_prototypes[5]),
+        Edge(16, _vertex_prototypes[14], _vertex_prototypes[4]),
+        Edge(17, _vertex_prototypes[14], _vertex_prototypes[5]),
     )
 
-    _num_windows = 6
+    _num_windows = 5
     _num_window_types = 1
```

### Comparing `stk-2022.6.17.0/src/stk/molecular/topology_graphs/cage/two_plus_three/four_plus_six.py` & `stk-2023.7.5.0/src/stk/_internal/topology_graphs/cage/four_plus_six.py`

 * *Files 2% similar despite different names*

```diff
@@ -2,17 +2,18 @@
 Four Plus Six
 =============
 
 """
 
 import numpy as np
 
-from ...topology_graph import Edge
-from ..cage import Cage
-from ..vertices import LinearVertex, NonLinearVertex
+from stk._internal.topology_graphs.edge import Edge
+
+from .cage import Cage
+from .vertices import LinearVertex, NonLinearVertex
 
 
 class FourPlusSix(Cage):
     """
     Represents a cage topology graph.
 
     Unoptimized construction
@@ -112,18 +113,18 @@
     See :class:`.Cage` for more details and examples.
 
     """
 
     # Vertices of a tetrahdron so that origin is at the origin. Source:
     # http://tinyurl.com/lc262h8.
     _v0, _v1, _v2, _v3 = _non_linears = (
-        NonLinearVertex(0, [0, 0, np.sqrt(6)/2]),
-        NonLinearVertex(1, [-1, -np.sqrt(3)/3, -np.sqrt(6)/6]),
-        NonLinearVertex(2, [1, -np.sqrt(3)/3, -np.sqrt(6)/6]),
-        NonLinearVertex(3, [0, 2*np.sqrt(3)/3, -np.sqrt(6)/6]),
+        NonLinearVertex(0, [0, 0, np.sqrt(6) / 2]),
+        NonLinearVertex(1, [-1, -np.sqrt(3) / 3, -np.sqrt(6) / 6]),
+        NonLinearVertex(2, [1, -np.sqrt(3) / 3, -np.sqrt(6) / 6]),
+        NonLinearVertex(3, [0, 2 * np.sqrt(3) / 3, -np.sqrt(6) / 6]),
     )
 
     _vertex_prototypes = (
         *_non_linears,
         LinearVertex.init_at_center(4, (_v0, _v1)),
         LinearVertex.init_at_center(5, (_v0, _v2)),
         LinearVertex.init_at_center(6, (_v0, _v3)),
@@ -140,12 +141,12 @@
         Edge(4, _vertex_prototypes[6], _vertex_prototypes[0]),
         Edge(5, _vertex_prototypes[6], _vertex_prototypes[3]),
         Edge(6, _vertex_prototypes[7], _vertex_prototypes[1]),
         Edge(7, _vertex_prototypes[7], _vertex_prototypes[2]),
         Edge(8, _vertex_prototypes[8], _vertex_prototypes[1]),
         Edge(9, _vertex_prototypes[8], _vertex_prototypes[3]),
         Edge(10, _vertex_prototypes[9], _vertex_prototypes[2]),
-        Edge(11, _vertex_prototypes[9], _vertex_prototypes[3])
+        Edge(11, _vertex_prototypes[9], _vertex_prototypes[3]),
     )
 
     _num_windows = 4
     _num_window_types = 1
```

### Comparing `stk-2022.6.17.0/src/stk/molecular/topology_graphs/cage/two_plus_three/four_plus_six_2.py` & `stk-2023.7.5.0/src/stk/_internal/topology_graphs/cage/four_plus_six_2.py`

 * *Files 1% similar despite different names*

```diff
@@ -1,16 +1,17 @@
 """
 Four Plus Six 2
 ===============
 
 """
 
-from ...topology_graph import Edge
-from ..cage import Cage
-from ..vertices import LinearVertex, NonLinearVertex
+from stk._internal.topology_graphs.edge import Edge
+
+from .cage import Cage
+from .vertices import LinearVertex, NonLinearVertex
 
 
 class FourPlusSix2(Cage):
     """
     Represents a cage topology graph.
 
     Unoptimized construction
@@ -112,15 +113,14 @@
     """
 
     _non_linears = (
         NonLinearVertex(0, [1, 0, 1]),
         NonLinearVertex(1, [-1, 0, 1]),
         NonLinearVertex(2, [1, 0, -1]),
         NonLinearVertex(3, [-1, 0, -1]),
-
         LinearVertex(4, [0, -1, 1], False),
         LinearVertex(5, [0, 1, 1], False),
         LinearVertex(6, [0, -1, -1], False),
         LinearVertex(7, [0, 1, -1], False),
     )
 
     _vertex_prototypes = (
@@ -128,15 +128,15 @@
         LinearVertex.init_at_center(
             id=8,
             vertices=(_non_linears[0], _non_linears[2]),
         ),
         LinearVertex.init_at_center(
             id=9,
             vertices=(_non_linears[1], _non_linears[3]),
-        )
+        ),
     )
 
     _edge_prototypes = (
         Edge(0, _vertex_prototypes[4], _vertex_prototypes[0]),
         Edge(1, _vertex_prototypes[4], _vertex_prototypes[1]),
         Edge(2, _vertex_prototypes[5], _vertex_prototypes[0]),
         Edge(3, _vertex_prototypes[5], _vertex_prototypes[1]),
```

### Comparing `stk-2022.6.17.0/src/stk/molecular/topology_graphs/cage/two_plus_three/six_plus_nine.py` & `stk-2023.7.5.0/src/stk/_internal/topology_graphs/cage/six_plus_twelve.py`

 * *Files 20% similar despite different names*

```diff
@@ -1,41 +1,40 @@
 """
-Six Plus Nine
-=============
+Six Plus Twelve
+===============
 
 """
 
-import numpy as np
+from stk._internal.topology_graphs.edge import Edge
 
-from ...topology_graph import Edge
-from ..cage import Cage
-from ..vertices import LinearVertex, NonLinearVertex
+from .cage import Cage
+from .vertices import LinearVertex, NonLinearVertex
 
 
-class SixPlusNine(Cage):
+class SixPlusTwelve(Cage):
     """
     Represents a cage topology graph.
 
     Unoptimized construction
 
     .. moldoc::
 
         import moldoc.molecule as molecule
         import stk
 
         bb1 = stk.BuildingBlock(
-            smiles='NC1CCCCC1N',
-            functional_groups=[stk.PrimaryAminoFactory()],
+            smiles='BrCCBr',
+            functional_groups=[stk.BromoFactory()],
         )
         bb2 = stk.BuildingBlock(
-            smiles='O=Cc1cc(C=O)cc(C=O)c1',
-            functional_groups=[stk.AldehydeFactory()],
+            smiles='Brc1c(Br)cc(Br)c(Br)c1',
+            functional_groups=[stk.BromoFactory()],
         )
         cage = stk.ConstructedMolecule(
-            topology_graph=stk.cage.SixPlusNine((bb1, bb2)),
+            topology_graph=stk.cage.SixPlusTwelve((bb1, bb2)),
         )
 
         moldoc_display_molecule = molecule.Molecule(
             atoms=(
                 molecule.Atom(
                     atomic_number=atom.get_atomic_number(),
                     position=position,
@@ -49,33 +48,33 @@
                     atom1_id=bond.get_atom1().get_id(),
                     atom2_id=bond.get_atom2().get_id(),
                     order=bond.get_order(),
                 ) for bond in cage.get_bonds()
             ),
         )
 
-    :class:`.MCHammer` optimized construction
+    :class:`.Collapser` optimized construction
 
     .. moldoc::
 
         import moldoc.molecule as molecule
         import stk
 
         bb1 = stk.BuildingBlock(
-            smiles='NC1CCCCC1N',
-            functional_groups=[stk.PrimaryAminoFactory()],
+            smiles='BrCCBr',
+            functional_groups=[stk.BromoFactory()],
         )
         bb2 = stk.BuildingBlock(
-            smiles='O=Cc1cc(C=O)cc(C=O)c1',
-            functional_groups=[stk.AldehydeFactory()],
+            smiles='Brc1c(Br)cc(Br)c(Br)c1',
+            functional_groups=[stk.BromoFactory()],
         )
         cage = stk.ConstructedMolecule(
-            topology_graph=stk.cage.SixPlusNine(
+            topology_graph=stk.cage.SixPlusTwelve(
                 building_blocks=(bb1, bb2),
-                optimizer=stk.MCHammer(),
+                optimizer=stk.Collapser(),
             ),
         )
 
         moldoc_display_molecule = molecule.Molecule(
             atoms=(
                 molecule.Atom(
                     atomic_number=atom.get_atomic_number(),
@@ -90,98 +89,116 @@
                     atom1_id=bond.get_atom1().get_id(),
                     atom2_id=bond.get_atom2().get_id(),
                     order=bond.get_order(),
                 ) for bond in cage.get_bonds()
             ),
         )
 
-    Nonlinear building blocks with three functional groups are
+    Nonlinear building blocks with four functional groups are
     required for this topology.
 
     Linear building blocks with two functional groups are required for
     this topology.
 
     When using a :class:`dict` for the `building_blocks` parameter,
     as in :ref:`cage-topology-graph-examples`:
     *Multi-Building Block Cage Construction*, a
     :class:`.BuildingBlock`, with the following number of functional
     groups, needs to be assigned to each of the following vertex ids:
 
-        | 3-functional groups: 0 to 5
-        | 2-functional groups: 5 to 14
+        | 4-functional groups: 0 to 5
+        | 2-functional groups: 6 to 17
 
     See :class:`.Cage` for more details and examples.
 
     """
 
-    # source: http://eusebeia.dyndns.org/4d/prism3
     _non_linears = (
-        NonLinearVertex(0, [-1, -1/np.sqrt(3), -1]),
-        NonLinearVertex(1, [-1, -1/np.sqrt(3), 1]),
-        NonLinearVertex(2, [1, -1/np.sqrt(3), -1]),
-        NonLinearVertex(3, [1, -1/np.sqrt(3), 1]),
-        NonLinearVertex(4, [0, 2/np.sqrt(3), -1]),
-        NonLinearVertex(5, [0, 2/np.sqrt(3), 1])
+        NonLinearVertex(0, [-1, -1, 0]),
+        NonLinearVertex(1, [-1, 1, 0]),
+        NonLinearVertex(2, [1, -1, 0]),
+        NonLinearVertex(3, [1, 1, 0]),
+        NonLinearVertex(4, [0, 0, 1]),
+        NonLinearVertex(5, [0, 0, -1]),
     )
+
     _vertex_prototypes = (
         *_non_linears,
         LinearVertex.init_at_center(
             id=6,
             vertices=(_non_linears[0], _non_linears[1]),
         ),
         LinearVertex.init_at_center(
             id=7,
-            vertices=(_non_linears[0], _non_linears[2]),
+            vertices=(_non_linears[1], _non_linears[3]),
         ),
         LinearVertex.init_at_center(
             id=8,
-            vertices=(_non_linears[2], _non_linears[3]),
+            vertices=(_non_linears[3], _non_linears[2]),
         ),
         LinearVertex.init_at_center(
             id=9,
-            vertices=(_non_linears[1], _non_linears[3]),
+            vertices=(_non_linears[0], _non_linears[2]),
         ),
         LinearVertex.init_at_center(
             id=10,
-            vertices=(_non_linears[0], _non_linears[4]),
+            vertices=(_non_linears[4], _non_linears[0]),
         ),
         LinearVertex.init_at_center(
             id=11,
-            vertices=(_non_linears[2], _non_linears[4]),
+            vertices=(_non_linears[4], _non_linears[1]),
         ),
         LinearVertex.init_at_center(
             id=12,
-            vertices=(_non_linears[1], _non_linears[5]),
+            vertices=(_non_linears[4], _non_linears[2]),
         ),
         LinearVertex.init_at_center(
             id=13,
-            vertices=(_non_linears[3], _non_linears[5]),
+            vertices=(_non_linears[4], _non_linears[3]),
         ),
         LinearVertex.init_at_center(
             id=14,
-            vertices=(_non_linears[4], _non_linears[5]),
+            vertices=(_non_linears[5], _non_linears[0]),
+        ),
+        LinearVertex.init_at_center(
+            id=15,
+            vertices=(_non_linears[5], _non_linears[1]),
+        ),
+        LinearVertex.init_at_center(
+            id=16,
+            vertices=(_non_linears[5], _non_linears[2]),
+        ),
+        LinearVertex.init_at_center(
+            id=17,
+            vertices=(_non_linears[5], _non_linears[3]),
         ),
     )
 
     _edge_prototypes = (
         Edge(0, _vertex_prototypes[6], _vertex_prototypes[0]),
         Edge(1, _vertex_prototypes[6], _vertex_prototypes[1]),
-        Edge(2, _vertex_prototypes[7], _vertex_prototypes[0]),
-        Edge(3, _vertex_prototypes[7], _vertex_prototypes[2]),
-        Edge(4, _vertex_prototypes[8], _vertex_prototypes[2]),
-        Edge(5, _vertex_prototypes[8], _vertex_prototypes[3]),
-        Edge(6, _vertex_prototypes[9], _vertex_prototypes[1]),
-        Edge(7, _vertex_prototypes[9], _vertex_prototypes[3]),
-        Edge(8, _vertex_prototypes[10], _vertex_prototypes[0]),
-        Edge(9, _vertex_prototypes[10], _vertex_prototypes[4]),
-        Edge(10, _vertex_prototypes[11], _vertex_prototypes[2]),
-        Edge(11, _vertex_prototypes[11], _vertex_prototypes[4]),
-        Edge(12, _vertex_prototypes[12], _vertex_prototypes[1]),
-        Edge(13, _vertex_prototypes[12], _vertex_prototypes[5]),
-        Edge(14, _vertex_prototypes[13], _vertex_prototypes[3]),
-        Edge(15, _vertex_prototypes[13], _vertex_prototypes[5]),
-        Edge(16, _vertex_prototypes[14], _vertex_prototypes[4]),
-        Edge(17, _vertex_prototypes[14], _vertex_prototypes[5]),
+        Edge(2, _vertex_prototypes[7], _vertex_prototypes[1]),
+        Edge(3, _vertex_prototypes[7], _vertex_prototypes[3]),
+        Edge(4, _vertex_prototypes[8], _vertex_prototypes[3]),
+        Edge(5, _vertex_prototypes[8], _vertex_prototypes[2]),
+        Edge(6, _vertex_prototypes[9], _vertex_prototypes[0]),
+        Edge(7, _vertex_prototypes[9], _vertex_prototypes[2]),
+        Edge(8, _vertex_prototypes[10], _vertex_prototypes[4]),
+        Edge(9, _vertex_prototypes[10], _vertex_prototypes[0]),
+        Edge(10, _vertex_prototypes[11], _vertex_prototypes[4]),
+        Edge(11, _vertex_prototypes[11], _vertex_prototypes[1]),
+        Edge(12, _vertex_prototypes[12], _vertex_prototypes[4]),
+        Edge(13, _vertex_prototypes[12], _vertex_prototypes[2]),
+        Edge(14, _vertex_prototypes[13], _vertex_prototypes[4]),
+        Edge(15, _vertex_prototypes[13], _vertex_prototypes[3]),
+        Edge(16, _vertex_prototypes[14], _vertex_prototypes[5]),
+        Edge(17, _vertex_prototypes[14], _vertex_prototypes[0]),
+        Edge(18, _vertex_prototypes[15], _vertex_prototypes[5]),
+        Edge(19, _vertex_prototypes[15], _vertex_prototypes[1]),
+        Edge(20, _vertex_prototypes[16], _vertex_prototypes[5]),
+        Edge(21, _vertex_prototypes[16], _vertex_prototypes[2]),
+        Edge(22, _vertex_prototypes[17], _vertex_prototypes[5]),
+        Edge(23, _vertex_prototypes[17], _vertex_prototypes[3]),
     )
 
-    _num_windows = 5
+    _num_windows = 8
     _num_window_types = 1
```

### Comparing `stk-2022.6.17.0/src/stk/molecular/topology_graphs/cage/two_plus_three/twenty_plus_thirty.py` & `stk-2023.7.5.0/src/stk/_internal/topology_graphs/cage/twenty_plus_thirty.py`

 * *Files 8% similar despite different names*

```diff
@@ -2,17 +2,18 @@
 Twenty Plus Thirty
 ==================
 
 """
 
 import numpy as np
 
-from ...topology_graph import Edge
-from ..cage import Cage
-from ..vertices import LinearVertex, NonLinearVertex
+from stk._internal.topology_graphs.edge import Edge
+
+from .cage import Cage
+from .vertices import LinearVertex, NonLinearVertex
 
 
 class TwentyPlusThirty(Cage):
     """
     Represents a cage topology graph.
 
     .. moldoc::
@@ -67,31 +68,29 @@
         | 2-functional groups: 20 to 49
 
     See :class:`.Cage` for more details and examples.
 
     """
 
     # Source: http://tinyurl.com/h2dl949
-    _phi = (1 + np.sqrt(5))/2
+    _phi = (1 + np.sqrt(5)) / 2
     _x = 1.5
     _non_linears = (
-        NonLinearVertex(0, [_x*_phi, 0.0, _x/_phi]),
-        NonLinearVertex(1, [_x*-_phi, 0.0, _x/_phi]),
-        NonLinearVertex(2, [_x*-_phi, 0.0, _x/-_phi]),
-        NonLinearVertex(3, [_x*_phi, 0.0, _x/-_phi]),
-
-        NonLinearVertex(4, [_x/_phi, _x*_phi, 0.0]),
-        NonLinearVertex(5, [_x/_phi, _x*-_phi, 0.0]),
-        NonLinearVertex(6, [_x/-_phi, _x*-_phi, 0.0]),
-        NonLinearVertex(7, [_x/-_phi, _x*_phi, 0.0]),
-        NonLinearVertex(8, [0.0, _x/_phi, _x*_phi]),
-        NonLinearVertex(9, [0.0, _x/_phi, _x*-_phi]),
-        NonLinearVertex(10, [0.0, _x/-_phi, _x*-_phi]),
-        NonLinearVertex(11, [0.0, _x/-_phi, _x*_phi]),
-
+        NonLinearVertex(0, [_x * _phi, 0.0, _x / _phi]),
+        NonLinearVertex(1, [_x * -_phi, 0.0, _x / _phi]),
+        NonLinearVertex(2, [_x * -_phi, 0.0, _x / -_phi]),
+        NonLinearVertex(3, [_x * _phi, 0.0, _x / -_phi]),
+        NonLinearVertex(4, [_x / _phi, _x * _phi, 0.0]),
+        NonLinearVertex(5, [_x / _phi, _x * -_phi, 0.0]),
+        NonLinearVertex(6, [_x / -_phi, _x * -_phi, 0.0]),
+        NonLinearVertex(7, [_x / -_phi, _x * _phi, 0.0]),
+        NonLinearVertex(8, [0.0, _x / _phi, _x * _phi]),
+        NonLinearVertex(9, [0.0, _x / _phi, _x * -_phi]),
+        NonLinearVertex(10, [0.0, _x / -_phi, _x * -_phi]),
+        NonLinearVertex(11, [0.0, _x / -_phi, _x * _phi]),
         NonLinearVertex(12, [_x, _x, _x]),
         NonLinearVertex(13, [_x, -_x, _x]),
         NonLinearVertex(14, [-_x, -_x, _x]),
         NonLinearVertex(15, [-_x, _x, _x]),
         NonLinearVertex(16, [-_x, _x, -_x]),
         NonLinearVertex(17, [_x, _x, -_x]),
         NonLinearVertex(18, [_x, -_x, -_x]),
@@ -108,202 +107,180 @@
             id=21,
             vertices=(_non_linears[0], _non_linears[12]),
         ),
         LinearVertex.init_at_center(
             id=22,
             vertices=(_non_linears[0], _non_linears[3]),
         ),
-
         LinearVertex.init_at_center(
             id=23,
             vertices=(_non_linears[1], _non_linears[14]),
         ),
         LinearVertex.init_at_center(
             id=24,
             vertices=(_non_linears[1], _non_linears[15]),
         ),
         LinearVertex.init_at_center(
             id=25,
             vertices=(_non_linears[1], _non_linears[2]),
         ),
-
         LinearVertex.init_at_center(
             id=26,
             vertices=(_non_linears[2], _non_linears[19]),
         ),
         LinearVertex.init_at_center(
             id=27,
             vertices=(_non_linears[2], _non_linears[16]),
         ),
-
         LinearVertex.init_at_center(
             id=28,
             vertices=(_non_linears[3], _non_linears[18]),
         ),
         LinearVertex.init_at_center(
             id=29,
             vertices=(_non_linears[3], _non_linears[17]),
         ),
-
         LinearVertex.init_at_center(
             id=30,
             vertices=(_non_linears[4], _non_linears[12]),
         ),
         LinearVertex.init_at_center(
             id=31,
             vertices=(_non_linears[4], _non_linears[7]),
         ),
         LinearVertex.init_at_center(
             id=32,
             vertices=(_non_linears[4], _non_linears[17]),
         ),
-
         LinearVertex.init_at_center(
             id=33,
             vertices=(_non_linears[5], _non_linears[6]),
         ),
         LinearVertex.init_at_center(
             id=34,
             vertices=(_non_linears[5], _non_linears[18]),
         ),
         LinearVertex.init_at_center(
             id=35,
             vertices=(_non_linears[5], _non_linears[13]),
         ),
-
         LinearVertex.init_at_center(
             id=36,
             vertices=(_non_linears[6], _non_linears[14]),
         ),
         LinearVertex.init_at_center(
             id=37,
             vertices=(_non_linears[6], _non_linears[19]),
         ),
-
         LinearVertex.init_at_center(
             id=38,
             vertices=(_non_linears[7], _non_linears[15]),
         ),
         LinearVertex.init_at_center(
             id=39,
             vertices=(_non_linears[7], _non_linears[16]),
         ),
-
         LinearVertex.init_at_center(
             id=40,
             vertices=(_non_linears[8], _non_linears[11]),
         ),
         LinearVertex.init_at_center(
             id=41,
             vertices=(_non_linears[8], _non_linears[12]),
         ),
         LinearVertex.init_at_center(
             id=42,
             vertices=(_non_linears[8], _non_linears[15]),
         ),
-
         LinearVertex.init_at_center(
             id=43,
             vertices=(_non_linears[9], _non_linears[10]),
         ),
         LinearVertex.init_at_center(
             id=44,
             vertices=(_non_linears[9], _non_linears[17]),
         ),
         LinearVertex.init_at_center(
             id=45,
             vertices=(_non_linears[9], _non_linears[16]),
         ),
-
         LinearVertex.init_at_center(
             id=46,
             vertices=(_non_linears[10], _non_linears[18]),
         ),
         LinearVertex.init_at_center(
             id=47,
             vertices=(_non_linears[10], _non_linears[19]),
         ),
-
         LinearVertex.init_at_center(
             id=48,
             vertices=(_non_linears[11], _non_linears[14]),
         ),
         LinearVertex.init_at_center(
-            id=49,
-            vertices=(_non_linears[11], _non_linears[13])),
+            id=49, vertices=(_non_linears[11], _non_linears[13])
+        ),
     )
 
     _edge_prototypes = (
         Edge(0, _vertex_prototypes[20], _vertex_prototypes[0]),
         Edge(1, _vertex_prototypes[20], _vertex_prototypes[13]),
         Edge(2, _vertex_prototypes[21], _vertex_prototypes[0]),
         Edge(3, _vertex_prototypes[21], _vertex_prototypes[12]),
         Edge(4, _vertex_prototypes[22], _vertex_prototypes[0]),
         Edge(5, _vertex_prototypes[22], _vertex_prototypes[3]),
-
         Edge(6, _vertex_prototypes[23], _vertex_prototypes[1]),
         Edge(7, _vertex_prototypes[23], _vertex_prototypes[14]),
         Edge(8, _vertex_prototypes[24], _vertex_prototypes[1]),
         Edge(9, _vertex_prototypes[24], _vertex_prototypes[15]),
         Edge(10, _vertex_prototypes[25], _vertex_prototypes[1]),
         Edge(11, _vertex_prototypes[25], _vertex_prototypes[2]),
-
         Edge(12, _vertex_prototypes[26], _vertex_prototypes[2]),
         Edge(13, _vertex_prototypes[26], _vertex_prototypes[19]),
         Edge(14, _vertex_prototypes[27], _vertex_prototypes[2]),
         Edge(15, _vertex_prototypes[27], _vertex_prototypes[16]),
-
         Edge(16, _vertex_prototypes[28], _vertex_prototypes[3]),
         Edge(17, _vertex_prototypes[28], _vertex_prototypes[18]),
         Edge(18, _vertex_prototypes[29], _vertex_prototypes[3]),
         Edge(19, _vertex_prototypes[29], _vertex_prototypes[17]),
-
         Edge(20, _vertex_prototypes[30], _vertex_prototypes[4]),
         Edge(21, _vertex_prototypes[30], _vertex_prototypes[12]),
         Edge(22, _vertex_prototypes[31], _vertex_prototypes[4]),
         Edge(23, _vertex_prototypes[31], _vertex_prototypes[7]),
         Edge(24, _vertex_prototypes[32], _vertex_prototypes[4]),
         Edge(25, _vertex_prototypes[32], _vertex_prototypes[17]),
-
         Edge(26, _vertex_prototypes[33], _vertex_prototypes[5]),
         Edge(27, _vertex_prototypes[33], _vertex_prototypes[6]),
         Edge(28, _vertex_prototypes[34], _vertex_prototypes[5]),
         Edge(29, _vertex_prototypes[34], _vertex_prototypes[18]),
         Edge(30, _vertex_prototypes[35], _vertex_prototypes[5]),
         Edge(31, _vertex_prototypes[35], _vertex_prototypes[13]),
-
         Edge(32, _vertex_prototypes[36], _vertex_prototypes[6]),
         Edge(33, _vertex_prototypes[36], _vertex_prototypes[14]),
         Edge(34, _vertex_prototypes[37], _vertex_prototypes[6]),
         Edge(35, _vertex_prototypes[37], _vertex_prototypes[19]),
-
         Edge(36, _vertex_prototypes[38], _vertex_prototypes[7]),
         Edge(37, _vertex_prototypes[38], _vertex_prototypes[15]),
         Edge(38, _vertex_prototypes[39], _vertex_prototypes[7]),
         Edge(39, _vertex_prototypes[39], _vertex_prototypes[16]),
-
         Edge(40, _vertex_prototypes[40], _vertex_prototypes[8]),
         Edge(41, _vertex_prototypes[40], _vertex_prototypes[11]),
         Edge(42, _vertex_prototypes[41], _vertex_prototypes[8]),
         Edge(43, _vertex_prototypes[41], _vertex_prototypes[12]),
         Edge(44, _vertex_prototypes[42], _vertex_prototypes[8]),
         Edge(45, _vertex_prototypes[42], _vertex_prototypes[15]),
-
         Edge(46, _vertex_prototypes[43], _vertex_prototypes[9]),
         Edge(47, _vertex_prototypes[43], _vertex_prototypes[10]),
         Edge(48, _vertex_prototypes[44], _vertex_prototypes[9]),
         Edge(49, _vertex_prototypes[44], _vertex_prototypes[17]),
         Edge(50, _vertex_prototypes[45], _vertex_prototypes[9]),
         Edge(51, _vertex_prototypes[45], _vertex_prototypes[16]),
-
         Edge(52, _vertex_prototypes[46], _vertex_prototypes[10]),
         Edge(53, _vertex_prototypes[46], _vertex_prototypes[18]),
         Edge(54, _vertex_prototypes[47], _vertex_prototypes[10]),
         Edge(55, _vertex_prototypes[47], _vertex_prototypes[19]),
-
         Edge(56, _vertex_prototypes[48], _vertex_prototypes[11]),
         Edge(57, _vertex_prototypes[48], _vertex_prototypes[14]),
         Edge(58, _vertex_prototypes[49], _vertex_prototypes[11]),
         Edge(59, _vertex_prototypes[49], _vertex_prototypes[13]),
     )
 
     _num_windows = 12
```

### Comparing `stk-2022.6.17.0/src/stk/molecular/topology_graphs/cage/two_plus_three/two_plus_three.py` & `stk-2023.7.5.0/src/stk/_internal/topology_graphs/cage/two_plus_four.py`

 * *Files 13% similar despite different names*

```diff
@@ -1,41 +1,42 @@
 """
-Two Plus Three
-==============
+Two Plus Four
+=============
 
 """
 
-import numpy as np
+from stk._internal.topology_graphs.cage.cage import Cage
+from stk._internal.topology_graphs.cage.vertices import (
+    LinearVertex,
+    NonLinearVertex,
+)
+from stk._internal.topology_graphs.edge import Edge
 
-from ...topology_graph import Edge
-from ..cage import Cage
-from ..vertices import LinearVertex, NonLinearVertex
 
-
-class TwoPlusThree(Cage):
+class TwoPlusFour(Cage):
     """
-    Represents a cage topology graph.
+    Represents a capsule cage topology graph.
 
     Unoptimized construction
 
     .. moldoc::
 
         import moldoc.molecule as molecule
         import stk
 
         bb1 = stk.BuildingBlock(
-            smiles='NC1CCCCC1N',
-            functional_groups=[stk.PrimaryAminoFactory()],
+            smiles='C1=CC=C(C(=C1)Br)Br',
+            functional_groups=[stk.BromoFactory()],
         )
         bb2 = stk.BuildingBlock(
-            smiles='O=Cc1cc(C=O)cc(C=O)c1',
-            functional_groups=[stk.AldehydeFactory()],
+            smiles='C1(=C(C(=C1Br)Br)Br)Br',
+            functional_groups=[stk.BromoFactory()],
         )
         cage = stk.ConstructedMolecule(
-            topology_graph=stk.cage.TwoPlusThree((bb1, bb2)),
+            topology_graph=stk.cage.TwoPlusFour((bb1, bb2)),
         )
 
         moldoc_display_molecule = molecule.Molecule(
             atoms=(
                 molecule.Atom(
                     atomic_number=atom.get_atomic_number(),
                     position=position,
@@ -49,33 +50,33 @@
                     atom1_id=bond.get_atom1().get_id(),
                     atom2_id=bond.get_atom2().get_id(),
                     order=bond.get_order(),
                 ) for bond in cage.get_bonds()
             ),
         )
 
-    :class:`.MCHammer` optimized construction
+    :class:`.Collapser` optimized construction
 
     .. moldoc::
 
         import moldoc.molecule as molecule
         import stk
 
         bb1 = stk.BuildingBlock(
-            smiles='NC1CCCCC1N',
-            functional_groups=[stk.PrimaryAminoFactory()],
+            smiles='C1=CC=C(C(=C1)Br)Br',
+            functional_groups=[stk.BromoFactory()],
         )
         bb2 = stk.BuildingBlock(
-            smiles='O=Cc1cc(C=O)cc(C=O)c1',
-            functional_groups=[stk.AldehydeFactory()],
+            smiles='C1(=C(C(=C1Br)Br)Br)Br',
+            functional_groups=[stk.BromoFactory()],
         )
         cage = stk.ConstructedMolecule(
-            topology_graph=stk.cage.TwoPlusThree(
+            topology_graph=stk.cage.TwoPlusFour(
                 building_blocks=(bb1, bb2),
-                optimizer=stk.MCHammer(),
+                optimizer=stk.Collapser(),
             ),
         )
 
         moldoc_display_molecule = molecule.Molecule(
             atoms=(
                 molecule.Atom(
                     atomic_number=atom.get_atomic_number(),
@@ -90,47 +91,48 @@
                     atom1_id=bond.get_atom1().get_id(),
                     atom2_id=bond.get_atom2().get_id(),
                     order=bond.get_order(),
                 ) for bond in cage.get_bonds()
             ),
         )
 
-    Nonlinear building blocks with three functional groups are
+    Nonlinear building blocks with four functional groups are
     required for this topology.
 
     Linear building blocks with two functional groups are required for
     this topology.
 
     When using a :class:`dict` for the `building_blocks` parameter,
     as in :ref:`cage-topology-graph-examples`:
     *Multi-Building Block Cage Construction*, a
     :class:`.BuildingBlock`, with the following number of functional
     groups, needs to be assigned to each of the following vertex ids:
 
-        | 3-functional groups: (0, 1)
-        | 2-functional groups: (2, 3, 4)
+        | 4-functional groups: (0, 1)
+        | 2-functional groups: (2, 3, 4, 5)
 
     See :class:`.Cage` for more details and examples.
 
     """
 
     _vertex_prototypes = (
-        NonLinearVertex(0, [0, 0, 1]),
-        NonLinearVertex(1, [0, 0, -1]),
-
-        LinearVertex(2, [-1, -0.5*np.sqrt(3), 0], False),
-        LinearVertex(3, [1, -0.5*np.sqrt(3), 0], False),
-        LinearVertex(4, [0, 0.5*np.sqrt(3), 0], False),
-
+        NonLinearVertex(0, [0, 0, -1]),
+        NonLinearVertex(1, [0, 0, 1]),
+        LinearVertex(2, [2, 0, 0], False),
+        LinearVertex(3, [-2, 0, 0], False),
+        LinearVertex(4, [0, 2, 0], False),
+        LinearVertex(5, [0, -2, 0], False),
     )
 
     _edge_prototypes = (
-        Edge(0, _vertex_prototypes[0], _vertex_prototypes[2]),
-        Edge(1, _vertex_prototypes[0], _vertex_prototypes[3]),
-        Edge(2, _vertex_prototypes[0], _vertex_prototypes[4]),
-        Edge(3, _vertex_prototypes[1], _vertex_prototypes[2]),
-        Edge(4, _vertex_prototypes[1], _vertex_prototypes[3]),
-        Edge(5, _vertex_prototypes[1], _vertex_prototypes[4]),
+        Edge(0, _vertex_prototypes[2], _vertex_prototypes[0]),
+        Edge(1, _vertex_prototypes[2], _vertex_prototypes[1]),
+        Edge(2, _vertex_prototypes[3], _vertex_prototypes[0]),
+        Edge(3, _vertex_prototypes[3], _vertex_prototypes[1]),
+        Edge(4, _vertex_prototypes[4], _vertex_prototypes[0]),
+        Edge(5, _vertex_prototypes[4], _vertex_prototypes[1]),
+        Edge(6, _vertex_prototypes[5], _vertex_prototypes[0]),
+        Edge(7, _vertex_prototypes[5], _vertex_prototypes[1]),
     )
 
-    _num_windows = 3
+    _num_windows = 4
     _num_window_types = 1
```

### Comparing `stk-2022.6.17.0/src/stk/molecular/topology_graphs/cage/vertices.py` & `stk-2023.7.5.0/src/stk/_internal/topology_graphs/cage/vertices.py`

 * *Files 3% similar despite different names*

```diff
@@ -3,21 +3,21 @@
 =============
 
 """
 
 import numpy as np
 from scipy.spatial.distance import euclidean
 
-from stk.utilities import (
+from stk._internal.topology_graphs.vertex import Vertex
+from stk._internal.utilities.utilities import (
     get_acute_vector,
     get_plane_normal,
     normalize_vector,
 )
 
-from ..topology_graph import Vertex
 from ..utilities import _EdgeSorter, _FunctionalGroupSorter
 
 
 class _CageVertex(Vertex):
     """
     Represents a vertex of a :class:`.Cage`.
 
@@ -145,42 +145,38 @@
 
         """
 
         return self._aligner_edge
 
     def __str__(self):
         return (
-            f'Vertex(id={self._id}, '
-            f'position={self._position.tolist()}, '
-            f'aligner_edge={self._aligner_edge})'
+            f"Vertex(id={self._id}, "
+            f"position={self._position.tolist()}, "
+            f"aligner_edge={self._aligner_edge})"
         )
 
 
 class LinearVertex(_CageVertex):
     def place_building_block(self, building_block, edges):
-        assert (
-            building_block.get_num_functional_groups() == 2
-        ), (
-            f'{building_block} needs to have exactly 2 functional '
-            'groups but has '
-            f'{building_block.get_num_functional_groups()}.'
+        assert building_block.get_num_functional_groups() == 2, (
+            f"{building_block} needs to have exactly 2 functional "
+            "groups but has "
+            f"{building_block.get_num_functional_groups()}."
         )
         building_block = building_block.with_centroid(
             position=self._position,
             atom_ids=building_block.get_placer_ids(),
         )
         fg_centroid = building_block.get_centroid(
             atom_ids=next(
                 building_block.get_functional_groups()
             ).get_placer_ids(),
         )
         edge_position = edges[self._aligner_edge].get_position()
-        edge_centroid = (
-            sum(edge.get_position() for edge in edges) / len(edges)
-        )
+        edge_centroid = sum(edge.get_position() for edge in edges) / len(edges)
         building_block = building_block.with_rotation_between_vectors(
             start=fg_centroid - self._position,
             target=edge_position - edge_centroid,
             origin=self._position,
         )
         core_centroid = building_block.get_centroid(
             atom_ids=building_block.get_core_atom_ids(),
@@ -191,48 +187,40 @@
             axis=normalize_vector(
                 edges[0].get_position() - edges[1].get_position()
             ),
             origin=self._position,
         ).get_position_matrix()
 
     def map_functional_groups_to_edges(self, building_block, edges):
-        fg, = building_block.get_functional_groups(0)
+        (fg,) = building_block.get_functional_groups(0)
         fg_position = building_block.get_centroid(fg.get_placer_ids())
 
         def fg_distance(edge):
             return euclidean(edge.get_position(), fg_position)
 
         edges = sorted(edges, key=fg_distance)
-        return {
-            fg_id: edge.get_id() for fg_id, edge in enumerate(edges)
-        }
+        return {fg_id: edge.get_id() for fg_id, edge in enumerate(edges)}
 
 
 class NonLinearVertex(_CageVertex):
     def place_building_block(self, building_block, edges):
-        assert (
-            building_block.get_num_functional_groups() > 2
-        ), (
-            f'{building_block} needs to have more than 2 functional '
-            'groups but has '
-            f'{building_block.get_num_functional_groups()}.'
+        assert building_block.get_num_functional_groups() > 2, (
+            f"{building_block} needs to have more than 2 functional "
+            "groups but has "
+            f"{building_block.get_num_functional_groups()}."
         )
         building_block = building_block.with_centroid(
             position=self._position,
             atom_ids=building_block.get_placer_ids(),
         )
-        edge_centroid = (
-            sum(edge.get_position() for edge in edges) / len(edges)
-        )
+        edge_centroid = sum(edge.get_position() for edge in edges) / len(edges)
         edge_normal = get_acute_vector(
             reference=edge_centroid,
             vector=get_plane_normal(
-                points=np.array([
-                    edge.get_position() for edge in edges
-                ]),
+                points=np.array([edge.get_position() for edge in edges]),
             ),
         )
         core_centroid = building_block.get_centroid(
             atom_ids=building_block.get_core_atom_ids(),
         )
         placer_centroid = building_block.get_centroid(
             atom_ids=building_block.get_placer_ids(),
@@ -294,83 +282,70 @@
     def place_building_block(self, building_block, edges):
         return building_block.with_centroid(
             position=self._position,
             atom_ids=building_block.get_placer_ids(),
         ).get_position_matrix()
 
     def map_functional_groups_to_edges(self, building_block, edges):
-
-        return {
-            fg_id: edge.get_id() for fg_id, edge in enumerate(edges)
-        }
+        return {fg_id: edge.get_id() for fg_id, edge in enumerate(edges)}
 
     @classmethod
     def init_at_center(cls, id, vertices):
         vertex = cls.__new__(cls)
         vertex._id = id
-        vertex._position = (
-            sum(vertex.get_position() for vertex in vertices)
-            / len(vertices)
-        )
+        vertex._position = sum(
+            vertex.get_position() for vertex in vertices
+        ) / len(vertices)
         vertex._use_neighbor_placement = True
         vertex._aligner_edge = 0
         return vertex
 
 
 class AngledVertex(_CageVertex):
-
     def place_building_block(self, building_block, edges):
-        assert (
-            building_block.get_num_functional_groups() == 2
-        ), (
-            f'{building_block} needs to have exactly 2 functional '
-            'groups but has '
-            f'{building_block.get_num_functional_groups()}.'
+        assert building_block.get_num_functional_groups() == 2, (
+            f"{building_block} needs to have exactly 2 functional "
+            "groups but has "
+            f"{building_block.get_num_functional_groups()}."
         )
         building_block = building_block.with_centroid(
             position=self._position,
             atom_ids=building_block.get_placer_ids(),
         )
 
         fg_centroid = building_block.get_centroid(
             atom_ids=next(
                 building_block.get_functional_groups()
             ).get_placer_ids(),
         )
         edge_position = edges[self._aligner_edge].get_position()
-        edge_centroid = (
-            sum(edge.get_position() for edge in edges) / len(edges)
-        )
+        edge_centroid = sum(edge.get_position() for edge in edges) / len(edges)
         building_block = building_block.with_rotation_between_vectors(
             start=fg_centroid - self._position,
             target=edge_position - edge_centroid,
             origin=self._position,
         )
 
         placer_centroid = building_block.get_centroid(
             atom_ids=building_block.get_placer_ids(),
         )
         core_centroid = building_block.get_centroid(
             atom_ids=building_block.get_core_atom_ids(),
         )
         core_to_placer = placer_centroid - core_centroid
-        edge_centroid = (
-            sum(edge.get_position() for edge in edges) / len(edges)
-        )
+        edge_centroid = sum(edge.get_position() for edge in edges) / len(edges)
 
         return building_block.with_rotation_between_vectors(
             start=core_to_placer,
             target=edge_centroid - self._position,
             origin=self._position,
         ).get_position_matrix()
 
     def map_functional_groups_to_edges(self, building_block, edges):
-        fg, = building_block.get_functional_groups(0)
+        (fg,) = building_block.get_functional_groups(0)
         fg_position = building_block.get_centroid(fg.get_placer_ids())
 
         def fg_distance(edge):
             return euclidean(edge.get_position(), fg_position)
 
         edges = sorted(edges, key=fg_distance)
-        return {
-            fg_id: edge.get_id() for fg_id, edge in enumerate(edges)
-        }
+        return {fg_id: edge.get_id() for fg_id, edge in enumerate(edges)}
```

### Comparing `stk-2022.6.17.0/src/stk/molecular/topology_graphs/cof/cof.py` & `stk-2023.7.5.0/src/stk/_internal/topology_graphs/cof/cof.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,49 +1,30 @@
-"""
-Covalent Organic Framework
-==========================
-
-.. toctree::
-    :maxdepth: 2
-
-    Hexagonal <stk.molecular.topology_graphs.cof.hexagonal>
-    Honeycomb <stk.molecular.topology_graphs.cof.honeycomb>
-    Kagome <stk.molecular.topology_graphs.cof.kagome>
-    Linkerless Honeycomb <\
-stk.molecular.topology_graphs.cof.linkerless_honeycomb\
->
-    Square <stk.molecular.topology_graphs.cof.square>
-    Periodic Hexagonal <\
-stk.molecular.topology_graphs.cof.periodic_hexagonal\
->
-    Periodic Honeycomb <\
-stk.molecular.topology_graphs.cof.periodic_honeycomb\
->
-    Periodic Kagome <stk.molecular.topology_graphs.cof.periodic_kagome>
-    Periodic Linkerless Honeycomb <\
-stk.molecular.topology_graphs.cof.periodic_linkerless_honeycomb\
->
-    Periodic Square <stk.molecular.topology_graphs.cof.periodic_square>
-
-"""
-
 import itertools as it
 from collections import Counter
 from functools import partial
 from operator import getitem
 
 import numpy as np
 
-from ...reactions import GenericReactionFactory
-from ..topology_graph import (
-    EdgeGroup,
-    NullOptimizer,
+from stk._internal.construction_result.periodic import (
     PeriodicConstructionResult,
+)
+from stk._internal.optimizers.null import (
+    NullOptimizer,
+)
+from stk._internal.reaction_factories.generic_reaction_factory import (
+    GenericReactionFactory,
+)
+from stk._internal.topology_graphs.edge_group import (
+    EdgeGroup,
+)
+from stk._internal.topology_graphs.topology_graph.topology_graph import (
     TopologyGraph,
 )
+
 from .edge import CofEdge
 from .vertices import UnaligningVertex
 
 
 class UnoccupiedVertexError(Exception):
     """
     When a COF vertex is not occupied by a building block.
@@ -415,63 +396,61 @@
         :class:`~.cof.OverlyOccupiedVertexError`
             If a vertex of the COF topology graph has more than one
             building block placed on it.
 
         """
 
         self._vertex_alignments = (
-            dict(vertex_alignments)
-            if vertex_alignments is not None
-            else {}
+            dict(vertex_alignments) if vertex_alignments is not None else {}
         )
         self._lattice_size = lattice_size
         self._periodic = periodic
 
         lattice = self._get_lattice(self._vertex_alignments)
         edges = self._get_edges(lattice)
         vertices = self._get_vertices(lattice)
 
         if isinstance(building_blocks, dict):
             for building_block in building_blocks:
                 assert (
                     building_block.get_num_functional_groups()
                     in self._allowed_degrees
                 ), (
-                    'The number of functional groups in '
-                    f'{building_block} needs to be one of '
-                    f'{tuple(self._allowed_degrees)}, but is '
-                    'currently '
-                    f'{building_block.get_num_functional_groups()}.'
+                    "The number of functional groups in "
+                    f"{building_block} needs to be one of "
+                    f"{tuple(self._allowed_degrees)}, but is "
+                    "currently "
+                    f"{building_block.get_num_functional_groups()}."
                 )
             get_vertex = partial(getitem, vertices)
             building_block_vertices = {
-                building_block: tuple(map(
-                    get_vertex,
-                    # Account for the fact that a building block can
-                    # be mapped to a single int.
-                    (ids, ) if isinstance(ids, int) else ids
-                ))
+                building_block: tuple(
+                    map(
+                        get_vertex,
+                        # Account for the fact that a building block can
+                        # be mapped to a single int.
+                        (ids,) if isinstance(ids, int) else ids,
+                    )
+                )
                 for building_block, ids in building_blocks.items()
             }
         else:
-            building_block_vertices = (
-                self._get_building_block_vertices(
-                    building_blocks=building_blocks,
-                    vertices=vertices,
-                    edges=edges,
-                )
+            building_block_vertices = self._get_building_block_vertices(
+                building_blocks=building_blocks,
+                vertices=vertices,
+                edges=edges,
             )
 
         building_block_vertices = self._with_unaligning_vertices(
             building_block_vertices=building_block_vertices,
         )
 
         self._check_building_block_vertices(
             num_vertices=(
-                np.product(lattice_size)*len(self._vertex_prototypes)
+                np.prod(lattice_size) * len(self._vertex_prototypes)
             ),
             building_block_vertices=building_block_vertices,
         )
         super().__init__(
             building_block_vertices=building_block_vertices,
             edges=edges,
             reaction_factory=reaction_factory,
@@ -512,24 +491,23 @@
             vertex
             for vertices_ in building_block_vertices.values()
             for vertex in vertices_
         )
         for vertex in vertices:
             if vertex.get_id() in assigned_ids:
                 raise OverlyOccupiedVertexError(
-                    f'Vertex {vertex.get_id()} has multiple building '
-                    'blocks placed on it.'
+                    f"Vertex {vertex.get_id()} has multiple building "
+                    "blocks placed on it."
                 )
             assigned_ids.add(vertex.get_id())
             unassigned_ids.remove(vertex.get_id())
 
         if unassigned_ids:
             raise UnoccupiedVertexError(
-                'The following vertices are unoccupied '
-                f'{unassigned_ids}.'
+                "The following vertices are unoccupied " f"{unassigned_ids}."
             )
 
     def clone(self):
         clone = super().clone()
         clone._vertex_alignments = dict(self._vertex_alignments)
         clone._lattice_size = self._lattice_size
         clone._periodic = self._periodic
@@ -557,16 +535,15 @@
 
         """
 
         if self._periodic:
             return None
 
         return tuple(
-            EdgeGroup((edge,)) for edge in edges
-            if not edge.is_periodic()
+            EdgeGroup((edge,)) for edge in edges if not edge.is_periodic()
         )
 
     def _get_vertices(self, lattice):
         """
         Get the vertices in the `lattice`.
 
         Parameters
@@ -580,15 +557,15 @@
         -------
         :class:`tuple` of :class:`.Vertex`
             All the vertices extracted from `lattice`.
 
         """
 
         xdim, ydim, zdim = self._lattice_size
-        num_vertices = xdim*ydim*zdim*len(self._vertex_prototypes)
+        num_vertices = xdim * ydim * zdim * len(self._vertex_prototypes)
         vertices = [None for i in range(num_vertices)]
         for x, y, z in it.product(
             range(xdim),
             range(ydim),
             range(zdim),
         ):
             for vertex in lattice[x][y][z].values():
@@ -624,31 +601,22 @@
             the vertices in :attr:`_vertex_prototypes` to its clone for
             that unit cell.
 
         """
 
         xdim, ydim, zdim = (range(dim) for dim in self._lattice_size)
         # vertex_clones is indexed as vertex_clones[x][y][z]
-        lattice = [
-            [
-                [
-                    {} for _ in zdim
-                ]
-                for _ in ydim
-            ]
-            for _ in xdim
-        ]
+        lattice = [[[{} for _ in zdim] for _ in ydim] for _ in xdim]
         # Make a clone of each vertex for each unit cell.
         cells = it.product(xdim, ydim, zdim)
         vertices = it.product(cells, self._vertex_prototypes)
         for id_, (cell, vertex) in enumerate(vertices):
             x, y, z = cell
             shift = sum(
-                axis * dim
-                for axis, dim in zip(cell, self._lattice_constants)
+                axis * dim for axis, dim in zip(cell, self._lattice_constants)
             )
             lattice[x][y][z][vertex.get_id()] = vertex.__class__(
                 id=id_,
                 position=vertex.get_position() + shift,
                 aligner_edge=vertex_alignments.get(id_, 0),
                 cell=cell,
             )
@@ -682,36 +650,36 @@
         for id_, (cell, edge) in enumerate(edges):
             x, y, z = cell
             # The cell in which the second vertex of the edge is found.
             periodic_cell = np.array(cell) + edge.get_periodicity()
             # Wrap around periodic cells, ie those that are less than 0
             # or greater than the lattice size along any dimension.
             dims = zip(periodic_cell, self._lattice_size)
-            x2, y2, z2 = np.array([
-                (dim+max_dim) % max_dim
-                for dim, max_dim in dims
-            ])
+            x2, y2, z2 = np.array(
+                [(dim + max_dim) % max_dim for dim, max_dim in dims]
+            )
             # The edge is not periodic if periodic_cell did not
             # have to wrap around.
             dims = zip(periodic_cell, self._lattice_size)
             edge_is_not_periodic = all(
-                dim >= 0 and dim < max_dim
-                for dim, max_dim in dims
+                dim >= 0 and dim < max_dim for dim, max_dim in dims
+            )
+            edge_clones.append(
+                CofEdge(
+                    parent_id=edge.get_id(),
+                    id=id_,
+                    vertex1=lattice[x][y][z][edge.get_vertex1_id()],
+                    vertex2=lattice[x2][y2][z2][edge.get_vertex2_id()],
+                    periodicity=(
+                        (0, 0, 0)
+                        if edge_is_not_periodic
+                        else edge.get_periodicity()
+                    ),
+                )
             )
-            edge_clones.append(CofEdge(
-                parent_id=edge.get_id(),
-                id=id_,
-                vertex1=lattice[x][y][z][edge.get_vertex1_id()],
-                vertex2=lattice[x2][y2][z2][edge.get_vertex2_id()],
-                periodicity=(
-                    (0, 0, 0)
-                    if edge_is_not_periodic
-                    else edge.get_periodicity()
-                ),
-            ))
 
         return tuple(edge_clones)
 
     @classmethod
     def _get_building_block_vertices(
         cls,
         building_blocks,
@@ -751,44 +719,40 @@
             of functional groups.
 
         """
 
         building_blocks_by_degree = {}
         for building_block in building_blocks:
             num_fgs = building_block.get_num_functional_groups()
-            assert (
-                num_fgs in cls._allowed_degrees
-            ), (
-                'The number of functional groups in '
-                f'{building_block} needs to be one of '
-                f'{tuple(cls._allowed_degrees)}, but is '
-                'currently '
-                f'{building_block.get_num_functional_groups()}.'
+            assert num_fgs in cls._allowed_degrees, (
+                "The number of functional groups in "
+                f"{building_block} needs to be one of "
+                f"{tuple(cls._allowed_degrees)}, but is "
+                "currently "
+                f"{building_block.get_num_functional_groups()}."
             )
             if num_fgs in building_blocks_by_degree:
                 raise ValueError(
-                    'If there are multiple building blocks with the '
-                    'same number of functional groups, '
-                    'building_block_vertices must be set explicitly.'
+                    "If there are multiple building blocks with the "
+                    "same number of functional groups, "
+                    "building_block_vertices must be set explicitly."
                 )
             building_blocks_by_degree[num_fgs] = building_block
 
         vertex_degrees = Counter(
-            vertex_id
-            for edge in edges
-            for vertex_id in edge.get_vertex_ids()
+            vertex_id for edge in edges for vertex_id in edge.get_vertex_ids()
         )
 
         building_block_vertices = {}
         for vertex in vertices:
             vertex_degree = vertex_degrees[vertex.get_id()]
             building_block = building_blocks_by_degree[vertex_degree]
-            building_block_vertices[building_block] = (
-                building_block_vertices.get(building_block, [])
-            )
+            building_block_vertices[
+                building_block
+            ] = building_block_vertices.get(building_block, [])
             building_block_vertices[building_block].append(vertex)
         return building_block_vertices
 
     def _get_lattice_constants(self):
         return self._lattice_constants
 
     def construct(self):
@@ -804,26 +768,25 @@
 
         return super().construct()
 
     def _get_construction_result(self, state):
         return PeriodicConstructionResult(state, self._lattice_size)
 
     def _get_scale(self, building_block_vertices):
-        return 5*max(
-            bb.get_maximum_diameter()
-            for bb in building_block_vertices
+        return 5 * max(
+            bb.get_maximum_diameter() for bb in building_block_vertices
         )
 
     def __repr__(self):
         x, y, z = self._lattice_size
-        periodic = ', periodic=True' if self._periodic else ''
+        periodic = ", periodic=True" if self._periodic else ""
         vertex_alignments = (
-            f', vertex_alignments={self._vertex_alignments}'
+            f", vertex_alignments={self._vertex_alignments}"
             if self._vertex_alignments
-            else ''
+            else ""
         )
         return (
-            f'cof.{self.__class__.__name__}('
-            f'({x}, {y}, {z})'
-            f'{vertex_alignments}'
-            f'{periodic})'
+            f"cof.{self.__class__.__name__}("
+            f"({x}, {y}, {z})"
+            f"{vertex_alignments}"
+            f"{periodic})"
         )
```

### Comparing `stk-2022.6.17.0/src/stk/molecular/topology_graphs/cof/edge.py` & `stk-2023.7.5.0/src/stk/_internal/topology_graphs/cof/edge.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,14 +1,14 @@
 """
 COF Edge
 ========
 
 """
 
-from ..topology_graph import Edge
+from stk._internal.topology_graphs.edge import Edge
 
 
 class CofEdge(Edge):
     """
     A :class:`.Cof` edge.
 
     """
```

### Comparing `stk-2022.6.17.0/src/stk/molecular/topology_graphs/cof/hexagonal.py` & `stk-2023.7.5.0/src/stk/_internal/topology_graphs/cof/hexagonal.py`

 * *Files 7% similar despite different names*

```diff
@@ -2,15 +2,16 @@
 Hexagonal
 =========
 
 """
 
 import numpy as np
 
-from ..topology_graph import Edge
+from stk._internal.topology_graphs.edge import Edge
+
 from .cof import Cof
 from .vertices import LinearVertex, NonLinearVertex
 
 
 class Hexagonal(Cof):
     """
     Represents a hexagonal COF topology graph.
@@ -105,24 +106,24 @@
         | 2-functional groups: 4 to 15
 
     See :class:`.Cof` for more details and examples.
 
     """
 
     _lattice_constants = _a, _b, _c = (
-        np.array([1., 0., 0.]),
+        np.array([1.0, 0.0, 0.0]),
         np.array([0.5, 0.866, 0]),
-        np.array([0, 0, 5/1.7321])
+        np.array([0, 0, 5 / 1.7321]),
     )
 
     _non_linears = (
-        NonLinearVertex(0, (1/4)*_a + (1/4)*_b + (1/2)*_c),
-        NonLinearVertex(1, (1/4)*_a + (3/4)*_b + (1/2)*_c),
-        NonLinearVertex(2, (3/4)*_a + (1/4)*_b + (1/2)*_c),
-        NonLinearVertex(3, (3/4)*_a + (3/4)*_b + (1/2)*_c),
+        NonLinearVertex(0, (1 / 4) * _a + (1 / 4) * _b + (1 / 2) * _c),
+        NonLinearVertex(1, (1 / 4) * _a + (3 / 4) * _b + (1 / 2) * _c),
+        NonLinearVertex(2, (3 / 4) * _a + (1 / 4) * _b + (1 / 2) * _c),
+        NonLinearVertex(3, (3 / 4) * _a + (3 / 4) * _b + (1 / 2) * _c),
     )
 
     _vertex_prototypes = (
         *_non_linears,
         LinearVertex.init_at_center(
             id=4,
             vertices=(_non_linears[0], _non_linears[1]),
@@ -180,81 +181,70 @@
             lattice_constants=_lattice_constants,
         ),
         LinearVertex.init_at_shifted_center(
             id=15,
             vertices=(_non_linears[3], _non_linears[0]),
             cell_shifts=((0, 0, 0), (1, 0, 0)),
             lattice_constants=_lattice_constants,
-        )
+        ),
     )
 
     _edge_prototypes = (
         Edge(0, _vertex_prototypes[4], _vertex_prototypes[0]),
         Edge(1, _vertex_prototypes[4], _vertex_prototypes[1]),
-
         Edge(2, _vertex_prototypes[5], _vertex_prototypes[0]),
         Edge(3, _vertex_prototypes[5], _vertex_prototypes[2]),
-
         Edge(4, _vertex_prototypes[6], _vertex_prototypes[1]),
         Edge(5, _vertex_prototypes[6], _vertex_prototypes[2]),
-
         Edge(6, _vertex_prototypes[7], _vertex_prototypes[1]),
         Edge(7, _vertex_prototypes[7], _vertex_prototypes[3]),
-
         Edge(8, _vertex_prototypes[8], _vertex_prototypes[2]),
         Edge(9, _vertex_prototypes[8], _vertex_prototypes[3]),
-
         Edge(10, _vertex_prototypes[9], _vertex_prototypes[0]),
         Edge(
             id=11,
             vertex1=_vertex_prototypes[9],
             vertex2=_vertex_prototypes[2],
             periodicity=(-1, 0, 0),
         ),
-
         Edge(12, _vertex_prototypes[10], _vertex_prototypes[0]),
         Edge(
             id=13,
             vertex1=_vertex_prototypes[10],
             vertex2=_vertex_prototypes[1],
             periodicity=(0, -1, 0),
         ),
-
         Edge(14, _vertex_prototypes[11], _vertex_prototypes[0]),
         Edge(
             id=15,
             vertex1=_vertex_prototypes[11],
             vertex2=_vertex_prototypes[3],
             periodicity=(0, -1, 0),
         ),
-
         Edge(16, _vertex_prototypes[12], _vertex_prototypes[2]),
         Edge(
             id=17,
             vertex1=_vertex_prototypes[12],
             vertex2=_vertex_prototypes[1],
             periodicity=(1, -1, 0),
         ),
-
         Edge(18, _vertex_prototypes[13], _vertex_prototypes[2]),
         Edge(
             id=19,
             vertex1=_vertex_prototypes[13],
             vertex2=_vertex_prototypes[3],
             periodicity=(0, -1, 0),
         ),
-
         Edge(20, _vertex_prototypes[14], _vertex_prototypes[1]),
         Edge(
             id=21,
             vertex1=_vertex_prototypes[14],
             vertex2=_vertex_prototypes[3],
             periodicity=(-1, 0, 0),
         ),
-
         Edge(22, _vertex_prototypes[15], _vertex_prototypes[3]),
         Edge(
             id=23,
             vertex1=_vertex_prototypes[15],
             vertex2=_vertex_prototypes[0],
             periodicity=(1, 0, 0),
         ),
```

### Comparing `stk-2022.6.17.0/src/stk/molecular/topology_graphs/cof/honeycomb.py` & `stk-2023.7.5.0/src/stk/_internal/topology_graphs/cof/honeycomb.py`

 * *Files 8% similar despite different names*

```diff
@@ -2,15 +2,16 @@
 Honeycomb
 =========
 
 """
 
 import numpy as np
 
-from ..topology_graph import Edge
+from stk._internal.topology_graphs.edge import Edge
+
 from .cof import Cof
 from .vertices import LinearVertex, NonLinearVertex
 
 
 class Honeycomb(Cof):
     """
     Represents a honeycomb COF topology graph.
@@ -107,22 +108,22 @@
         | 2-functional groups: 2 to 4
 
     See :class:`.Cof` for more details and examples.
 
     """
 
     _lattice_constants = _a, _b, _c = (
-        np.array([1., 0., 0.]),
+        np.array([1.0, 0.0, 0.0]),
         np.array([0.5, 0.866, 0]),
-        np.array([0, 0, 5/1.7321])
+        np.array([0, 0, 5 / 1.7321]),
     )
 
     _non_linears = (
-        NonLinearVertex(0, (1/3)*_a + (1/3)*_b + (1/2)*_c),
-        NonLinearVertex(1, (2/3)*_a + (2/3)*_b + (1/2)*_c),
+        NonLinearVertex(0, (1 / 3) * _a + (1 / 3) * _b + (1 / 2) * _c),
+        NonLinearVertex(1, (2 / 3) * _a + (2 / 3) * _b + (1 / 2) * _c),
     )
 
     _vertex_prototypes = (
         *_non_linears,
         LinearVertex.init_at_center(
             id=2,
             vertices=(_non_linears[0], _non_linears[1]),
@@ -134,30 +135,28 @@
             lattice_constants=_lattice_constants,
         ),
         LinearVertex.init_at_shifted_center(
             id=4,
             vertices=(_non_linears[0], _non_linears[1]),
             cell_shifts=((0, 0, 0), (-1, 0, 0)),
             lattice_constants=_lattice_constants,
-        )
+        ),
     )
 
     _edge_prototypes = (
         Edge(0, _vertex_prototypes[2], _vertex_prototypes[0]),
         Edge(1, _vertex_prototypes[2], _vertex_prototypes[1]),
-
         Edge(2, _vertex_prototypes[3], _vertex_prototypes[0]),
         Edge(
             id=3,
             vertex1=_vertex_prototypes[3],
             vertex2=_vertex_prototypes[1],
             periodicity=(0, -1, 0),
         ),
-
         Edge(4, _vertex_prototypes[4], _vertex_prototypes[0]),
         Edge(
             id=5,
             vertex1=_vertex_prototypes[4],
             vertex2=_vertex_prototypes[1],
             periodicity=(-1, 0, 0),
-        )
+        ),
     )
```

### Comparing `stk-2022.6.17.0/src/stk/molecular/topology_graphs/cof/kagome.py` & `stk-2023.7.5.0/src/stk/_internal/topology_graphs/cof/kagome.py`

 * *Files 8% similar despite different names*

```diff
@@ -2,15 +2,16 @@
 Kagome
 ======
 
 """
 
 import numpy as np
 
-from ..topology_graph import Edge
+from stk._internal.topology_graphs.edge import Edge
+
 from .cof import Cof
 from .vertices import LinearVertex, NonLinearVertex
 
 
 class Kagome(Cof):
     """
     Represents a kagome COF topology graph.
@@ -112,23 +113,23 @@
         | 2-functional groups: 3 to 8
 
     See :class:`.Cof` for more details and examples.
 
     """
 
     _lattice_constants = _a, _b, _c = (
-        np.array([1., 0., 0.]),
-        np.array([0.5, 0.866, 0.]),
-        np.array([0., 0., 5/1.7321])
+        np.array([1.0, 0.0, 0.0]),
+        np.array([0.5, 0.866, 0.0]),
+        np.array([0.0, 0.0, 5 / 1.7321]),
     )
 
     _non_linears = (
-        NonLinearVertex(0, (1/4)*_a + (3/4)*_b + (0.5)*_c),
-        NonLinearVertex(1, (3/4)*_a + (3/4)*_b + (1/2)*_c),
-        NonLinearVertex(2, (3/4)*_a + (1/4)*_b + (1/2)*_c),
+        NonLinearVertex(0, (1 / 4) * _a + (3 / 4) * _b + (0.5) * _c),
+        NonLinearVertex(1, (3 / 4) * _a + (3 / 4) * _b + (1 / 2) * _c),
+        NonLinearVertex(2, (3 / 4) * _a + (1 / 4) * _b + (1 / 2) * _c),
     )
 
     _vertex_prototypes = (
         *_non_linears,
         LinearVertex.init_at_center(
             id=3,
             vertices=(_non_linears[0], _non_linears[1]),
@@ -141,57 +142,51 @@
             id=5,
             vertices=(_non_linears[1], _non_linears[2]),
         ),
         LinearVertex.init_at_shifted_center(
             id=6,
             vertices=(_non_linears[0], _non_linears[1]),
             cell_shifts=((0, 0, 0), (-1, 0, 0)),
-            lattice_constants=_lattice_constants
+            lattice_constants=_lattice_constants,
         ),
         LinearVertex.init_at_shifted_center(
             id=7,
             vertices=(_non_linears[0], _non_linears[2]),
             cell_shifts=((0, 0, 0), (-1, 1, 0)),
-            lattice_constants=_lattice_constants
+            lattice_constants=_lattice_constants,
         ),
         LinearVertex.init_at_shifted_center(
             id=8,
             vertices=(_non_linears[1], _non_linears[2]),
             cell_shifts=((0, 0, 0), (0, 1, 0)),
-            lattice_constants=_lattice_constants
+            lattice_constants=_lattice_constants,
         ),
-
     )
 
     _edge_prototypes = (
         Edge(0, _vertex_prototypes[3], _vertex_prototypes[0]),
         Edge(1, _vertex_prototypes[3], _vertex_prototypes[1]),
-
         Edge(2, _vertex_prototypes[4], _vertex_prototypes[0]),
         Edge(3, _vertex_prototypes[4], _vertex_prototypes[2]),
-
         Edge(4, _vertex_prototypes[5], _vertex_prototypes[1]),
         Edge(5, _vertex_prototypes[5], _vertex_prototypes[2]),
-
         Edge(6, _vertex_prototypes[6], _vertex_prototypes[0]),
         Edge(
             id=7,
             vertex1=_vertex_prototypes[6],
             vertex2=_vertex_prototypes[1],
             periodicity=(-1, 0, 0),
         ),
-
         Edge(8, _vertex_prototypes[7], _vertex_prototypes[0]),
         Edge(
             id=9,
             vertex1=_vertex_prototypes[7],
             vertex2=_vertex_prototypes[2],
             periodicity=(-1, 1, 0),
         ),
-
         Edge(10, _vertex_prototypes[8], _vertex_prototypes[1]),
         Edge(
             id=11,
             vertex1=_vertex_prototypes[8],
             vertex2=_vertex_prototypes[2],
             periodicity=(0, 1, 0),
         ),
```

### Comparing `stk-2022.6.17.0/src/stk/molecular/topology_graphs/cof/linkerless_honeycomb.py` & `stk-2023.7.5.0/src/stk/_internal/topology_graphs/cof/linkerless_honeycomb.py`

 * *Files 5% similar despite different names*

```diff
@@ -2,15 +2,16 @@
 Linkerless Honeycomb
 ====================
 
 """
 
 import numpy as np
 
-from ..topology_graph import Edge
+from stk._internal.topology_graphs.edge import Edge
+
 from .cof import Cof
 from .vertices import NonLinearVertex
 
 
 class LinkerlessHoneycomb(Cof):
     """
     Represents a honeycomb COF topology graph.
@@ -103,22 +104,22 @@
         | 3-functional groups: 0 to 1
 
     See :class:`.Cof` for more details and examples.
 
     """
 
     _lattice_constants = _a, _b, _c = (
-        np.array([1., 0., 0.]),
-        np.array([0.5, 0.866, 0.]),
-        np.array([0., 0., 5/1.7321]),
+        np.array([1.0, 0.0, 0.0]),
+        np.array([0.5, 0.866, 0.0]),
+        np.array([0.0, 0.0, 5 / 1.7321]),
     )
 
     _vertex_prototypes = (
-        NonLinearVertex(0, (1/3)*_a + (1/3)*_b + (1/2)*_c),
-        NonLinearVertex(1, (2/3)*_a + (2/3)*_b + (1/2)*_c),
+        NonLinearVertex(0, (1 / 3) * _a + (1 / 3) * _b + (1 / 2) * _c),
+        NonLinearVertex(1, (2 / 3) * _a + (2 / 3) * _b + (1 / 2) * _c),
     )
 
     _edge_prototypes = (
         Edge(0, _vertex_prototypes[0], _vertex_prototypes[1]),
         Edge(
             id=1,
             vertex1=_vertex_prototypes[0],
```

### Comparing `stk-2022.6.17.0/src/stk/molecular/topology_graphs/cof/periodic_hexagonal.py` & `stk-2023.7.5.0/src/stk/_internal/topology_graphs/cof/periodic_hexagonal.py`

 * *Files 2% similar despite different names*

```diff
@@ -3,16 +3,20 @@
 ==================
 
 """
 
 
 import numpy as np
 
-from ...reactions import GenericReactionFactory
-from ..topology_graph import Edge, NullOptimizer
+from stk._internal.optimizers.null import NullOptimizer
+from stk._internal.reaction_factories.generic_reaction_factory import (
+    GenericReactionFactory,
+)
+from stk._internal.topology_graphs.edge import Edge
+
 from .cof import Cof
 from .vertices import LinearVertex, NonLinearVertex
 
 
 class PeriodicHexagonal(Cof):
     """
     Represents a periodic hexagonal COF topology graph.
@@ -199,24 +203,24 @@
             vertex_alignments=vertex_alignments,
             reaction_factory=reaction_factory,
             num_processes=num_processes,
             optimizer=optimizer,
         )
 
     _lattice_constants = _a, _b, _c = (
-        np.array([1., 0., 0.]),
+        np.array([1.0, 0.0, 0.0]),
         np.array([0.5, 0.866, 0]),
-        np.array([0, 0, 5/1.7321])
+        np.array([0, 0, 5 / 1.7321]),
     )
 
     _non_linears = (
-        NonLinearVertex(0, (1/4)*_a + (1/4)*_b + (1/2)*_c),
-        NonLinearVertex(1, (1/4)*_a + (3/4)*_b + (1/2)*_c),
-        NonLinearVertex(2, (3/4)*_a + (1/4)*_b + (1/2)*_c),
-        NonLinearVertex(3, (3/4)*_a + (3/4)*_b + (1/2)*_c),
+        NonLinearVertex(0, (1 / 4) * _a + (1 / 4) * _b + (1 / 2) * _c),
+        NonLinearVertex(1, (1 / 4) * _a + (3 / 4) * _b + (1 / 2) * _c),
+        NonLinearVertex(2, (3 / 4) * _a + (1 / 4) * _b + (1 / 2) * _c),
+        NonLinearVertex(3, (3 / 4) * _a + (3 / 4) * _b + (1 / 2) * _c),
     )
 
     _vertex_prototypes = (
         *_non_linears,
         LinearVertex.init_at_center(
             id=4,
             vertices=(_non_linears[0], _non_linears[1]),
@@ -274,81 +278,70 @@
             lattice_constants=_lattice_constants,
         ),
         LinearVertex.init_at_shifted_center(
             id=15,
             vertices=(_non_linears[3], _non_linears[0]),
             cell_shifts=((0, 0, 0), (1, 0, 0)),
             lattice_constants=_lattice_constants,
-        )
+        ),
     )
 
     _edge_prototypes = (
         Edge(0, _vertex_prototypes[4], _vertex_prototypes[0]),
         Edge(1, _vertex_prototypes[4], _vertex_prototypes[1]),
-
         Edge(2, _vertex_prototypes[5], _vertex_prototypes[0]),
         Edge(3, _vertex_prototypes[5], _vertex_prototypes[2]),
-
         Edge(4, _vertex_prototypes[6], _vertex_prototypes[1]),
         Edge(5, _vertex_prototypes[6], _vertex_prototypes[2]),
-
         Edge(6, _vertex_prototypes[7], _vertex_prototypes[1]),
         Edge(7, _vertex_prototypes[7], _vertex_prototypes[3]),
-
         Edge(8, _vertex_prototypes[8], _vertex_prototypes[2]),
         Edge(9, _vertex_prototypes[8], _vertex_prototypes[3]),
-
         Edge(10, _vertex_prototypes[9], _vertex_prototypes[0]),
         Edge(
             id=11,
             vertex1=_vertex_prototypes[9],
             vertex2=_vertex_prototypes[2],
             periodicity=(-1, 0, 0),
         ),
-
         Edge(12, _vertex_prototypes[10], _vertex_prototypes[0]),
         Edge(
             id=13,
             vertex1=_vertex_prototypes[10],
             vertex2=_vertex_prototypes[1],
             periodicity=(0, -1, 0),
         ),
-
         Edge(14, _vertex_prototypes[11], _vertex_prototypes[0]),
         Edge(
             id=15,
             vertex1=_vertex_prototypes[11],
             vertex2=_vertex_prototypes[3],
             periodicity=(0, -1, 0),
         ),
-
         Edge(16, _vertex_prototypes[12], _vertex_prototypes[2]),
         Edge(
             id=17,
             vertex1=_vertex_prototypes[12],
             vertex2=_vertex_prototypes[1],
             periodicity=(1, -1, 0),
         ),
-
         Edge(18, _vertex_prototypes[13], _vertex_prototypes[2]),
         Edge(
             id=19,
             vertex1=_vertex_prototypes[13],
             vertex2=_vertex_prototypes[3],
             periodicity=(0, -1, 0),
         ),
-
         Edge(20, _vertex_prototypes[14], _vertex_prototypes[1]),
         Edge(
             id=21,
             vertex1=_vertex_prototypes[14],
             vertex2=_vertex_prototypes[3],
             periodicity=(-1, 0, 0),
         ),
-
         Edge(22, _vertex_prototypes[15], _vertex_prototypes[3]),
         Edge(
             id=23,
             vertex1=_vertex_prototypes[15],
             vertex2=_vertex_prototypes[0],
             periodicity=(1, 0, 0),
         ),
```

### Comparing `stk-2022.6.17.0/src/stk/molecular/topology_graphs/cof/periodic_honeycomb.py` & `stk-2023.7.5.0/src/stk/_internal/topology_graphs/cof/periodic_honeycomb.py`

 * *Files 5% similar despite different names*

```diff
@@ -3,16 +3,20 @@
 ==================
 
 """
 
 
 import numpy as np
 
-from ...reactions import GenericReactionFactory
-from ..topology_graph import Edge, NullOptimizer
+from stk._internal.optimizers.null import NullOptimizer
+from stk._internal.reaction_factories.generic_reaction_factory import (
+    GenericReactionFactory,
+)
+from stk._internal.topology_graphs.edge import Edge
+
 from .cof import Cof
 from .vertices import LinearVertex, NonLinearVertex
 
 
 class PeriodicHoneycomb(Cof):
     """
     Represents a periodic honeycomb COF topology graph.
@@ -201,22 +205,22 @@
             vertex_alignments=vertex_alignments,
             reaction_factory=reaction_factory,
             num_processes=num_processes,
             optimizer=optimizer,
         )
 
     _lattice_constants = _a, _b, _c = (
-        np.array([1., 0., 0.]),
+        np.array([1.0, 0.0, 0.0]),
         np.array([0.5, 0.866, 0]),
-        np.array([0, 0, 5/1.7321])
+        np.array([0, 0, 5 / 1.7321]),
     )
 
     _non_linears = (
-        NonLinearVertex(0, (1/3)*_a + (1/3)*_b + (1/2)*_c),
-        NonLinearVertex(1, (2/3)*_a + (2/3)*_b + (1/2)*_c),
+        NonLinearVertex(0, (1 / 3) * _a + (1 / 3) * _b + (1 / 2) * _c),
+        NonLinearVertex(1, (2 / 3) * _a + (2 / 3) * _b + (1 / 2) * _c),
     )
 
     _vertex_prototypes = (
         *_non_linears,
         LinearVertex.init_at_center(
             id=2,
             vertices=(_non_linears[0], _non_linears[1]),
@@ -228,30 +232,28 @@
             lattice_constants=_lattice_constants,
         ),
         LinearVertex.init_at_shifted_center(
             id=4,
             vertices=(_non_linears[0], _non_linears[1]),
             cell_shifts=((0, 0, 0), (-1, 0, 0)),
             lattice_constants=_lattice_constants,
-        )
+        ),
     )
 
     _edge_prototypes = (
         Edge(0, _vertex_prototypes[2], _vertex_prototypes[0]),
         Edge(1, _vertex_prototypes[2], _vertex_prototypes[1]),
-
         Edge(2, _vertex_prototypes[3], _vertex_prototypes[0]),
         Edge(
             id=3,
             vertex1=_vertex_prototypes[3],
             vertex2=_vertex_prototypes[1],
             periodicity=(0, -1, 0),
         ),
-
         Edge(4, _vertex_prototypes[4], _vertex_prototypes[0]),
         Edge(
             id=5,
             vertex1=_vertex_prototypes[4],
             vertex2=_vertex_prototypes[1],
             periodicity=(-1, 0, 0),
-        )
+        ),
     )
```

### Comparing `stk-2022.6.17.0/src/stk/molecular/topology_graphs/cof/periodic_kagome.py` & `stk-2023.7.5.0/src/stk/_internal/topology_graphs/cof/periodic_kagome.py`

 * *Files 4% similar despite different names*

```diff
@@ -3,16 +3,20 @@
 ===============
 
 """
 
 
 import numpy as np
 
-from ...reactions import GenericReactionFactory
-from ..topology_graph import Edge, NullOptimizer
+from stk._internal.optimizers.null import NullOptimizer
+from stk._internal.reaction_factories.generic_reaction_factory import (
+    GenericReactionFactory,
+)
+from stk._internal.topology_graphs.edge import Edge
+
 from .cof import Cof
 from .vertices import LinearVertex, NonLinearVertex
 
 
 class PeriodicKagome(Cof):
     """
     Represents a periodic kagome COF topology graph.
@@ -213,23 +217,23 @@
             vertex_alignments=vertex_alignments,
             reaction_factory=reaction_factory,
             num_processes=num_processes,
             optimizer=optimizer,
         )
 
     _lattice_constants = _a, _b, _c = (
-        np.array([1., 0., 0.]),
-        np.array([0.5, 0.866, 0.]),
-        np.array([0., 0., 5/1.7321])
+        np.array([1.0, 0.0, 0.0]),
+        np.array([0.5, 0.866, 0.0]),
+        np.array([0.0, 0.0, 5 / 1.7321]),
     )
 
     _non_linears = (
-        NonLinearVertex(0, (1/4)*_a + (3/4)*_b + (0.5)*_c),
-        NonLinearVertex(1, (3/4)*_a + (3/4)*_b + (1/2)*_c),
-        NonLinearVertex(2, (3/4)*_a + (1/4)*_b + (1/2)*_c),
+        NonLinearVertex(0, (1 / 4) * _a + (3 / 4) * _b + (0.5) * _c),
+        NonLinearVertex(1, (3 / 4) * _a + (3 / 4) * _b + (1 / 2) * _c),
+        NonLinearVertex(2, (3 / 4) * _a + (1 / 4) * _b + (1 / 2) * _c),
     )
 
     _vertex_prototypes = (
         *_non_linears,
         LinearVertex.init_at_center(
             id=3,
             vertices=(_non_linears[0], _non_linears[1]),
@@ -242,57 +246,51 @@
             id=5,
             vertices=(_non_linears[1], _non_linears[2]),
         ),
         LinearVertex.init_at_shifted_center(
             id=6,
             vertices=(_non_linears[0], _non_linears[1]),
             cell_shifts=((0, 0, 0), (-1, 0, 0)),
-            lattice_constants=_lattice_constants
+            lattice_constants=_lattice_constants,
         ),
         LinearVertex.init_at_shifted_center(
             id=7,
             vertices=(_non_linears[0], _non_linears[2]),
             cell_shifts=((0, 0, 0), (-1, 1, 0)),
-            lattice_constants=_lattice_constants
+            lattice_constants=_lattice_constants,
         ),
         LinearVertex.init_at_shifted_center(
             id=8,
             vertices=(_non_linears[1], _non_linears[2]),
             cell_shifts=((0, 0, 0), (0, 1, 0)),
-            lattice_constants=_lattice_constants
+            lattice_constants=_lattice_constants,
         ),
-
     )
 
     _edge_prototypes = (
         Edge(0, _vertex_prototypes[3], _vertex_prototypes[0]),
         Edge(1, _vertex_prototypes[3], _vertex_prototypes[1]),
-
         Edge(2, _vertex_prototypes[4], _vertex_prototypes[0]),
         Edge(3, _vertex_prototypes[4], _vertex_prototypes[2]),
-
         Edge(4, _vertex_prototypes[5], _vertex_prototypes[1]),
         Edge(5, _vertex_prototypes[5], _vertex_prototypes[2]),
-
         Edge(6, _vertex_prototypes[6], _vertex_prototypes[0]),
         Edge(
             id=7,
             vertex1=_vertex_prototypes[6],
             vertex2=_vertex_prototypes[1],
             periodicity=(-1, 0, 0),
         ),
-
         Edge(8, _vertex_prototypes[7], _vertex_prototypes[0]),
         Edge(
             id=9,
             vertex1=_vertex_prototypes[7],
             vertex2=_vertex_prototypes[2],
             periodicity=(-1, 1, 0),
         ),
-
         Edge(10, _vertex_prototypes[8], _vertex_prototypes[1]),
         Edge(
             id=11,
             vertex1=_vertex_prototypes[8],
             vertex2=_vertex_prototypes[2],
             periodicity=(0, 1, 0),
         ),
```

### Comparing `stk-2022.6.17.0/src/stk/molecular/topology_graphs/cof/periodic_linkerless_honeycomb.py` & `stk-2023.7.5.0/src/stk/_internal/topology_graphs/cof/periodic_linkerless_honeycomb.py`

 * *Files 7% similar despite different names*

```diff
@@ -3,16 +3,20 @@
 =============================
 
 """
 
 
 import numpy as np
 
-from ...reactions import GenericReactionFactory
-from ..topology_graph import Edge, NullOptimizer
+from stk._internal.optimizers.null import NullOptimizer
+from stk._internal.reaction_factories.generic_reaction_factory import (
+    GenericReactionFactory,
+)
+from stk._internal.topology_graphs.edge import Edge
+
 from .cof import Cof
 from .vertices import NonLinearVertex
 
 
 class PeriodicLinkerlessHoneycomb(Cof):
     """
     Represents a periodic honeycomb COF topology graph.
@@ -196,22 +200,22 @@
             vertex_alignments=vertex_alignments,
             reaction_factory=reaction_factory,
             num_processes=num_processes,
             optimizer=optimizer,
         )
 
     _lattice_constants = _a, _b, _c = (
-        np.array([1., 0., 0.]),
-        np.array([0.5, 0.866, 0.]),
-        np.array([0., 0., 5/1.7321]),
+        np.array([1.0, 0.0, 0.0]),
+        np.array([0.5, 0.866, 0.0]),
+        np.array([0.0, 0.0, 5 / 1.7321]),
     )
 
     _vertex_prototypes = (
-        NonLinearVertex(0, (1/3)*_a + (1/3)*_b + (1/2)*_c),
-        NonLinearVertex(1, (2/3)*_a + (2/3)*_b + (1/2)*_c),
+        NonLinearVertex(0, (1 / 3) * _a + (1 / 3) * _b + (1 / 2) * _c),
+        NonLinearVertex(1, (2 / 3) * _a + (2 / 3) * _b + (1 / 2) * _c),
     )
 
     _edge_prototypes = (
         Edge(0, _vertex_prototypes[0], _vertex_prototypes[1]),
         Edge(
             id=1,
             vertex1=_vertex_prototypes[0],
```

### Comparing `stk-2022.6.17.0/src/stk/molecular/topology_graphs/cof/periodic_square.py` & `stk-2023.7.5.0/src/stk/_internal/topology_graphs/cof/periodic_square.py`

 * *Files 2% similar despite different names*

```diff
@@ -3,16 +3,20 @@
 ===============
 
 """
 
 
 import numpy as np
 
-from ...reactions import GenericReactionFactory
-from ..topology_graph import Edge, NullOptimizer
+from stk._internal.optimizers.null import NullOptimizer
+from stk._internal.reaction_factories.generic_reaction_factory import (
+    GenericReactionFactory,
+)
+from stk._internal.topology_graphs.edge import Edge
+
 from .cof import Cof
 from .vertices import LinearVertex, NonLinearVertex
 
 
 class PeriodicSquare(Cof):
     """
     Represents a periodic square COF topology graph.
@@ -205,37 +209,34 @@
             vertex_alignments=vertex_alignments,
             reaction_factory=reaction_factory,
             num_processes=num_processes,
             optimizer=optimizer,
         )
 
     _lattice_constants = _a, _b, _c = (
-        np.array([1., 0., 0.]),
-        np.array([0., 1., 0.]),
-        np.array([0., 0., 1.])
+        np.array([1.0, 0.0, 0.0]),
+        np.array([0.0, 1.0, 0.0]),
+        np.array([0.0, 0.0, 1.0]),
     )
 
-    _non_linears = (
-        NonLinearVertex(0, (0.5)*_a + (0.5)*_b + (0.5)*_c),
-    )
+    _non_linears = (NonLinearVertex(0, (0.5) * _a + (0.5) * _b + (0.5) * _c),)
     _vertex_prototypes = (
         *_non_linears,
         LinearVertex.init_at_shifted_center(
             id=1,
             vertices=(_non_linears[0], _non_linears[0]),
             cell_shifts=((0, 0, 0), (1, 0, 0)),
             lattice_constants=_lattice_constants,
         ),
         LinearVertex.init_at_shifted_center(
             id=2,
             vertices=(_non_linears[0], _non_linears[0]),
             cell_shifts=((0, 0, 0), (0, 1, 0)),
             lattice_constants=_lattice_constants,
         ),
-
     )
 
     _edge_prototypes = (
         Edge(0, _vertex_prototypes[1], _vertex_prototypes[0]),
         Edge(
             id=1,
             vertex1=_vertex_prototypes[1],
```

### Comparing `stk-2022.6.17.0/src/stk/molecular/topology_graphs/cof/square.py` & `stk-2023.7.5.0/src/stk/_internal/topology_graphs/cof/square.py`

 * *Files 3% similar despite different names*

```diff
@@ -2,15 +2,16 @@
 Square
 ======
 
 """
 
 import numpy as np
 
-from ..topology_graph import Edge
+from stk._internal.topology_graphs.edge import Edge
+
 from .cof import Cof
 from .vertices import LinearVertex, NonLinearVertex
 
 
 class Square(Cof):
     """
     Represents a sqaure COF topology graph.
@@ -113,37 +114,34 @@
         | 2-functional groups: 1 to 2
 
     See :class:`.Cof` for more details and examples.
 
     """
 
     _lattice_constants = _a, _b, _c = (
-        np.array([1., 0., 0.]),
-        np.array([0., 1., 0.]),
-        np.array([0., 0., 1.])
+        np.array([1.0, 0.0, 0.0]),
+        np.array([0.0, 1.0, 0.0]),
+        np.array([0.0, 0.0, 1.0]),
     )
 
-    _non_linears = (
-        NonLinearVertex(0, (0.5)*_a + (0.5)*_b + (0.5)*_c),
-    )
+    _non_linears = (NonLinearVertex(0, (0.5) * _a + (0.5) * _b + (0.5) * _c),)
     _vertex_prototypes = (
         *_non_linears,
         LinearVertex.init_at_shifted_center(
             id=1,
             vertices=(_non_linears[0], _non_linears[0]),
             cell_shifts=((0, 0, 0), (1, 0, 0)),
             lattice_constants=_lattice_constants,
         ),
         LinearVertex.init_at_shifted_center(
             id=2,
             vertices=(_non_linears[0], _non_linears[0]),
             cell_shifts=((0, 0, 0), (0, 1, 0)),
             lattice_constants=_lattice_constants,
         ),
-
     )
 
     _edge_prototypes = (
         Edge(0, _vertex_prototypes[1], _vertex_prototypes[0]),
         Edge(
             id=1,
             vertex1=_vertex_prototypes[1],
```

### Comparing `stk-2022.6.17.0/src/stk/molecular/topology_graphs/cof/vertices.py` & `stk-2023.7.5.0/src/stk/_internal/topology_graphs/cof/vertices.py`

 * *Files 3% similar despite different names*

```diff
@@ -3,17 +3,17 @@
 ============
 
 """
 
 import numpy as np
 from scipy.spatial.distance import euclidean
 
-from stk.utilities import get_acute_vector
+from stk._internal.topology_graphs.vertex import Vertex
+from stk._internal.utilities.utilities import get_acute_vector
 
-from ..topology_graph import Vertex
 from ..utilities import _EdgeSorter, _FunctionalGroupSorter
 
 
 class _CofVertex(Vertex):
     """
     A :class:`._CofVertex` .
 
@@ -155,17 +155,16 @@
             The new vertex.
 
         """
 
         positions = []
         for vertex, cell_shift in zip(vertices, cell_shifts):
             shift = sum(
-                dim_shift*constant
-                for dim_shift, constant
-                in zip(cell_shift, lattice_constants)
+                dim_shift * constant
+                for dim_shift, constant in zip(cell_shift, lattice_constants)
             )
             positions.append(vertex.get_position() + shift)
 
         position = np.divide(
             np.sum(positions, axis=0),
             len(positions),
         )
@@ -175,28 +174,26 @@
         clone = super().clone()
         clone._aligner_edge = self._aligner_edge
         clone._cell = np.array(self._cell)
         return clone
 
     def __str__(self):
         return (
-            f'Vertex(id={self._id}, '
-            f'position={self._position.tolist()}, '
-            f'aligner_edge={self._aligner_edge})'
+            f"Vertex(id={self._id}, "
+            f"position={self._position.tolist()}, "
+            f"aligner_edge={self._aligner_edge})"
         )
 
 
 class LinearVertex(_CofVertex):
     def place_building_block(self, building_block, edges):
-        assert (
-            building_block.get_num_functional_groups() == 2
-        ), (
-            f'{building_block} needs to have exactly 2 functional '
-            'groups but has '
-            f'{building_block.get_num_functional_groups()}.'
+        assert building_block.get_num_functional_groups() == 2, (
+            f"{building_block} needs to have exactly 2 functional "
+            "groups but has "
+            f"{building_block.get_num_functional_groups()}."
         )
         building_block = building_block.with_centroid(
             position=self._position,
             atom_ids=building_block.get_placer_ids(),
         )
 
         # Align the normal of the plane of best fit, defined by
@@ -212,47 +209,43 @@
         building_block = building_block.with_rotation_between_vectors(
             start=normal,
             target=[0, 0, 1],
             origin=self._position,
         )
 
         # Rotate to place fg-fg vector along edge-edge vector.
-        fg, = building_block.get_functional_groups(0)
+        (fg,) = building_block.get_functional_groups(0)
         fg_centroid = building_block.get_centroid(fg.get_placer_ids())
         target = edges[0].get_position() - edges[1].get_position()
         target *= 1 if self._aligner_edge == 0 else -1
 
         building_block = building_block.with_rotation_between_vectors(
             start=fg_centroid - self._position,
             target=target,
             origin=self._position,
         )
         return building_block.get_position_matrix()
 
     def map_functional_groups_to_edges(self, building_block, edges):
-        fg, = building_block.get_functional_groups(0)
+        (fg,) = building_block.get_functional_groups(0)
         fg_position = building_block.get_centroid(fg.get_placer_ids())
 
         def fg_distance(edge):
             return euclidean(edge.get_position(), fg_position)
 
         edges = sorted(edges, key=fg_distance)
-        return {
-            fg_id: edge.get_id() for fg_id, edge in enumerate(edges)
-        }
+        return {fg_id: edge.get_id() for fg_id, edge in enumerate(edges)}
 
 
 class NonLinearVertex(_CofVertex):
     def place_building_block(self, building_block, edges):
-        assert (
-            building_block.get_num_functional_groups() > 2
-        ), (
-            f'{building_block} needs to have more than 2 functional '
-            'groups but has '
-            f'{building_block.get_num_functional_groups()}.'
+        assert building_block.get_num_functional_groups() > 2, (
+            f"{building_block} needs to have more than 2 functional "
+            "groups but has "
+            f"{building_block.get_num_functional_groups()}."
         )
         # Sort to ensure that for two vertices, which are periodically
         # equivalent, "edges" has identical ordering. This means that
         # the aligner_edge is chosen consistently in both cases.
         edges = sorted(edges, key=lambda edge: edge.get_parent_id())
 
         building_block = building_block.with_centroid(
@@ -270,15 +263,15 @@
             vector=normal,
         )
         building_block = building_block.with_rotation_between_vectors(
             start=normal,
             target=[0, 0, 1],
             origin=self._position,
         )
-        fg, = building_block.get_functional_groups(0)
+        (fg,) = building_block.get_functional_groups(0)
         fg_centroid = building_block.get_centroid(fg.get_placer_ids())
         edge_position = edges[self._aligner_edge].get_position()
         return building_block.with_rotation_to_minimize_angle(
             start=fg_centroid - self._position,
             target=edge_position - self._position,
             axis=np.array([0, 0, 1], dtype=np.float64),
             origin=self._position,
@@ -314,34 +307,29 @@
     def place_building_block(self, building_block, edges):
         return building_block.with_centroid(
             position=self._position,
             atom_ids=building_block.get_placer_ids(),
         ).get_position_matrix()
 
     def map_functional_groups_to_edges(self, building_block, edges):
-
-        return {
-            fg_id: edge.get_id() for fg_id, edge in enumerate(edges)
-        }
+        return {fg_id: edge.get_id() for fg_id, edge in enumerate(edges)}
 
     @classmethod
     def init_at_center(
         cls,
         id,
         vertices,
         aligner_edge=0,
         cell=(0, 0, 0),
     ):
-
         vertex = cls.__new__(cls)
         vertex._id = id
-        vertex._position = (
-            sum(vertex.get_position() for vertex in vertices)
-            / len(vertices)
-        )
+        vertex._position = sum(
+            vertex.get_position() for vertex in vertices
+        ) / len(vertices)
         vertex._cell = np.array(cell)
         vertex._aligner_edge = aligner_edge
         return vertex
 
     @classmethod
     def init_at_shifted_center(
         cls,
@@ -354,17 +342,16 @@
     ):
         new_vertex = cls.__new__(cls)
         new_vertex._id = id
 
         positions = []
         for vertex, cell_shift in zip(vertices, cell_shifts):
             shift = sum(
-                dim_shift*constant
-                for dim_shift, constant
-                in zip(cell_shift, lattice_constants)
+                dim_shift * constant
+                for dim_shift, constant in zip(cell_shift, lattice_constants)
             )
             positions.append(vertex.get_position() + shift)
 
         new_vertex._position = np.divide(
             np.sum(positions, axis=0),
             len(positions),
         )
```

### Comparing `stk-2022.6.17.0/src/stk/molecular/topology_graphs/host_guest/complex.py` & `stk-2023.7.5.0/src/stk/_internal/topology_graphs/host_guest/complex.py`

 * *Files 3% similar despite different names*

```diff
@@ -1,42 +1,47 @@
-"""
-Host Guest Complex
-==================
-
-"""
-
 from __future__ import annotations
 
 import typing
 from collections import abc
 
-from ...molecules import BuildingBlock
-from ...reactions import GenericReactionFactory
-from ..topology_graph import (
+from stk._internal.building_block import BuildingBlock
+from stk._internal.construction_state import (
     ConstructionState,
+)
+from stk._internal.optimizers.null import (
     NullOptimizer,
+)
+from stk._internal.optimizers.optimizer import (
     Optimizer,
+)
+from stk._internal.reaction_factories.generic_reaction_factory import (
+    GenericReactionFactory,
+)
+from stk._internal.topology_graphs.topology_graph.topology_graph import (
     TopologyGraph,
+)
+from stk._internal.topology_graphs.vertex import (
     Vertex,
 )
+
 from .vertices import GuestVertex, HostVertex
 
 
 class Guest:
     """
     Holds the data defining the placement of a guest molecule.
 
     """
 
     def __init__(
         self,
         building_block: BuildingBlock,
-        start_vector: tuple[float, float, float] = (1., 0., 0.),
-        end_vector: tuple[float, float, float] = (1., 0., 0.),
-        displacement: tuple[float, float, float] = (1., 0., 0.),
+        start_vector: tuple[float, float, float] = (1.0, 0.0, 0.0),
+        end_vector: tuple[float, float, float] = (1.0, 0.0, 0.0),
+        displacement: tuple[float, float, float] = (1.0, 0.0, 0.0),
     ) -> None:
         """
         Initialize a :class:`.Guest` instance.
 
         Parameters:
             building_block: The guest molecule.
 
@@ -99,19 +104,19 @@
 
         """
 
         return self._displacement
 
     def __repr__(self) -> str:
         return (
-            f'{self.__class__.__name__}('
-            f'{self._building_block!r}, '
-            f'start_vector={self._start_vector!r}, '
-            f'end_vector={self._end_vector!r}, '
-            f'displacement={self._displacement!r})'
+            f"{self.__class__.__name__}("
+            f"{self._building_block!r}, "
+            f"start_vector={self._start_vector!r}, "
+            f"end_vector={self._end_vector!r}, "
+            f"displacement={self._displacement!r})"
         )
 
 
 class Complex(TopologyGraph):
     """
     Represents a host-guest complex topology graph.
 
@@ -485,31 +490,28 @@
         )
 
     def _get_vertices_from_guests(
         self,
         host: BuildingBlock,
         guests: typing.Union[Guest, typing.Iterable[Guest]],
     ) -> dict[BuildingBlock, abc.Sequence[Vertex]]:
-
         if isinstance(guests, Guest):
-            guests = (guests, )
+            guests = (guests,)
 
-        building_block_vertices: dict[
-            BuildingBlock, abc.Sequence[Vertex]
-        ]
-        building_block_vertices = {
-            host: (HostVertex(0, (0., 0., 0.)), )
-        }
+        building_block_vertices: dict[BuildingBlock, abc.Sequence[Vertex]]
+        building_block_vertices = {host: (HostVertex(0, (0.0, 0.0, 0.0)),)}
         guest_vertices = {
-            guest.get_building_block(): (GuestVertex(
-                id=i+1,
-                position=guest.get_displacement(),
-                start=guest.get_start_vector(),
-                target=guest.get_end_vector(),
-            ), )
+            guest.get_building_block(): (
+                GuestVertex(
+                    id=i + 1,
+                    position=guest.get_displacement(),
+                    start=guest.get_start_vector(),
+                    target=guest.get_end_vector(),
+                ),
+            )
             for i, guest in enumerate(guests)
         }
         building_block_vertices.update(guest_vertices)
 
         return building_block_vertices
 
     def clone(self) -> Complex:
@@ -519,15 +521,13 @@
         self,
         state: ConstructionState,
     ) -> ConstructionState:
         return state
 
     def _get_scale(
         self,
-        building_block_vertices: dict[
-            BuildingBlock, abc.Sequence[Vertex]
-        ],
+        building_block_vertices: dict[BuildingBlock, abc.Sequence[Vertex]],
     ) -> float:
-        return 1.
+        return 1.0
 
     def __repr__(self) -> str:
-        return 'host_guest.Complex()'
+        return "host_guest.Complex()"
```

### Comparing `stk-2022.6.17.0/src/stk/molecular/topology_graphs/host_guest/vertices.py` & `stk-2023.7.5.0/src/stk/_internal/topology_graphs/host_guest/vertices.py`

 * *Files 8% similar despite different names*

```diff
@@ -3,15 +3,15 @@
 ===========================
 
 """
 
 
 import numpy as np
 
-from ..topology_graph import Vertex
+from stk._internal.topology_graphs.vertex import Vertex
 
 
 class HostVertex(Vertex):
     """
     Places the host in a :class:`.Complex`.
 
     """
@@ -61,18 +61,22 @@
     def clone(self):
         clone = super().clone()
         clone._start = np.array(self._start)
         clone._target = np.array(self._target)
         return clone
 
     def place_building_block(self, building_block, edges):
-        return building_block.with_centroid(
-            position=self._position,
-            atom_ids=building_block.get_placer_ids(),
-        ).with_rotation_between_vectors(
-            start=self._start,
-            target=self._target,
-            origin=self._position,
-        ).get_position_matrix()
+        return (
+            building_block.with_centroid(
+                position=self._position,
+                atom_ids=building_block.get_placer_ids(),
+            )
+            .with_rotation_between_vectors(
+                start=self._start,
+                target=self._target,
+                origin=self._position,
+            )
+            .get_position_matrix()
+        )
 
     def map_functional_groups_to_edges(self, building_block, edges):
         return {}
```

### Comparing `stk-2022.6.17.0/src/stk/molecular/topology_graphs/macrocycle/macrocycle.py` & `stk-2023.7.5.0/src/stk/_internal/topology_graphs/macrocycle/macrocycle.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,30 +1,36 @@
-"""
-Macrocycle
-==========
-
-"""
-
 from __future__ import annotations
 
 import typing
 import warnings
 from collections import abc
 
 import numpy as np
 
-from ...molecules import BuildingBlock
-from ...reactions import GenericReactionFactory, ReactionFactory
-from ..topology_graph import (
-    Edge,
+from stk._internal.building_block import BuildingBlock
+from stk._internal.optimizers.null import (
     NullOptimizer,
+)
+from stk._internal.optimizers.optimizer import (
     Optimizer,
+)
+from stk._internal.reaction_factories.generic_reaction_factory import (
+    GenericReactionFactory,
+)
+from stk._internal.reaction_factories.reaction_factory import ReactionFactory
+from stk._internal.topology_graphs.edge import (
+    Edge,
+)
+from stk._internal.topology_graphs.topology_graph.topology_graph import (
     TopologyGraph,
+)
+from stk._internal.topology_graphs.vertex import (
     Vertex,
 )
+
 from .vertices import CycleVertex
 
 
 class Macrocycle(TopologyGraph):
     """
     Represents a macrocycle topology graph.
 
@@ -322,16 +328,16 @@
     """
 
     def __init__(
         self,
         building_blocks: tuple[BuildingBlock, ...],
         repeating_unit: typing.Union[str, tuple[int, ...]],
         num_repeating_units: int,
-        orientations: typing.Optional[tuple[float, ...]] = None,
-        random_seed: typing.Optional[int] = None,
+        orientations: tuple[float, ...] | None = None,
+        random_seed: int | np.random.Generator | None = None,
         reaction_factory: ReactionFactory = GenericReactionFactory(),
         num_processes: int = 1,
         optimizer: Optimizer = NullOptimizer(),
     ) -> None:
         """
         Initialize a :class:`Macrocycle` instance.
 
@@ -388,68 +394,67 @@
             :class:`ValueError`
                 If the length of `orientations` is not equal in length
                 to `repeating_unit` or to the total number of vertices.
 
         """
 
         if orientations is None:
-            orientations = tuple(
-                0. for i in range(len(repeating_unit))
-            )
+            orientations = tuple(0.0 for i in range(len(repeating_unit)))
 
         if len(orientations) == len(repeating_unit):
-            orientations = orientations*num_repeating_units
+            orientations = orientations * num_repeating_units
 
-        chain_length = len(repeating_unit)*num_repeating_units
+        chain_length = len(repeating_unit) * num_repeating_units
         if chain_length == 2:
             warnings.warn(
-                'The orientation of macrocycles with chain length '
-                f'{chain_length} is not expected to provide robust '
-                'alignment and bonding.'
+                "The orientation of macrocycles with chain length "
+                f"{chain_length} is not expected to provide robust "
+                "alignment and bonding."
             )
 
         if len(orientations) != chain_length:
             raise ValueError(
-                'The length of orientations must match either '
-                'the length of repeating_unit or the '
-                'total number of vertices.'
+                "The length of orientations must match either "
+                "the length of repeating_unit or the "
+                "total number of vertices."
             )
 
-        generator = np.random.RandomState(random_seed)
+        if random_seed is None or isinstance(random_seed, int):
+            random_seed = np.random.default_rng(random_seed)
 
         # Keep these for __repr__.
         self._repeating_unit = self._normalize_repeating_unit(
             repeating_unit=repeating_unit
         )
         self._num_repeating_units = num_repeating_units
 
         # Each monomer in the macrocycle is separated by angle_diff.
-        angle_diff = (2*np.pi)/chain_length
+        angle_diff = (2 * np.pi) / chain_length
         vertices: list[CycleVertex] = []
         edges: list[Edge] = []
         choices = [True, False]
         for vertex_id, flip_chance in enumerate(orientations):
-            theta = vertex_id*angle_diff
+            theta = vertex_id * angle_diff
             vertices.append(
                 CycleVertex(
                     id=vertex_id,
                     position=(np.cos(theta), np.sin(theta), 0),
-                    flip=generator.choice(
+                    flip=random_seed.choice(
                         choices,
-                        p=[flip_chance, 1-flip_chance],
+                        p=[flip_chance, 1 - flip_chance],
                     ),
                     angle=theta,
                 )
             )
 
             if vertex_id > 0:
                 edges.append(
                     Edge(
                         id=len(edges),
-                        vertex1=vertices[vertex_id-1],
+                        vertex1=vertices[vertex_id - 1],
                         vertex2=vertices[vertex_id],
                     )
                 )
 
         # Save the chosen orientations for __repr__.
         self._orientations = tuple(
             int(vertex.get_flip()) for vertex in vertices
@@ -476,59 +481,52 @@
         clone._orientations = self._orientations
         return clone
 
     @staticmethod
     def _normalize_repeating_unit(
         repeating_unit: typing.Union[str, tuple[int, ...]],
     ) -> tuple[int, ...]:
-
         if isinstance(repeating_unit, tuple):
             return repeating_unit
-        base = ord('A')
-        return tuple(ord(letter)-base for letter in repeating_unit)
+        base = ord("A")
+        return tuple(ord(letter) - base for letter in repeating_unit)
 
     def _get_building_block_vertices(
         self,
         building_blocks: tuple[BuildingBlock, ...],
         vertices: abc.Sequence[CycleVertex],
     ) -> dict[BuildingBlock, abc.Sequence[Vertex]]:
-
-        polymer = self._repeating_unit*self._num_repeating_units
+        polymer = self._repeating_unit * self._num_repeating_units
         building_block_vertices: dict[BuildingBlock, list[Vertex]]
         building_block_vertices = {}
         for bb_index, vertex in zip(polymer, vertices):
             bb = building_blocks[bb_index]
-            building_block_vertices[bb] = (
-                building_block_vertices.get(bb, [])
-            )
+            building_block_vertices[bb] = building_block_vertices.get(bb, [])
             building_block_vertices[bb].append(vertex)
         return typing.cast(
             dict[BuildingBlock, abc.Sequence[Vertex]],
             building_block_vertices,
         )
 
     def _get_scale(
         self,
-        building_block_vertices: dict[
-            BuildingBlock,
-            abc.Sequence[Vertex]
-        ],
+        building_block_vertices: dict[BuildingBlock, abc.Sequence[Vertex]],
     ) -> float:
-
-        length = len(self._repeating_unit)*self._num_repeating_units
-        return length*0.25*max(
-            bb.get_maximum_diameter()
-            for bb in building_block_vertices
+        length = len(self._repeating_unit) * self._num_repeating_units
+        return (
+            length
+            * 0.25
+            * max(bb.get_maximum_diameter() for bb in building_block_vertices)
         )
 
     def with_building_blocks(
         self,
         building_block_map: dict[BuildingBlock, BuildingBlock],
     ) -> Macrocycle:
         return super()._with_building_blocks(building_block_map)
 
     def __repr__(self) -> str:
         return (
-            f'macrocycle.Macrocycle({self._repeating_unit!r}, '
-            f'{self._num_repeating_units!r}, '
-            f'{self._orientations!r})'
+            f"macrocycle.Macrocycle({self._repeating_unit!r}, "
+            f"{self._num_repeating_units!r}, "
+            f"{self._orientations!r})"
         )
```

### Comparing `stk-2022.6.17.0/src/stk/molecular/topology_graphs/macrocycle/vertices.py` & `stk-2023.7.5.0/src/stk/_internal/topology_graphs/macrocycle/vertices.py`

 * *Files 8% similar despite different names*

```diff
@@ -7,16 +7,17 @@
 from __future__ import annotations
 
 import typing
 
 import numpy as np
 from scipy.spatial.distance import euclidean
 
-from ...molecules import BuildingBlock
-from ..topology_graph import Edge, Vertex
+from stk._internal.building_block import BuildingBlock
+from stk._internal.topology_graphs.edge import Edge
+from stk._internal.topology_graphs.vertex import Vertex
 
 
 class CycleVertex(Vertex):
     """
     Represents a vertex in a macrocycle.
 
     """
@@ -72,68 +73,64 @@
         return self._flip
 
     def place_building_block(
         self,
         building_block: BuildingBlock,
         edges: tuple[Edge, ...],
     ) -> np.ndarray:
-
-        assert (
-            building_block.get_num_functional_groups() == 2
-        ), (
-            f'{building_block} needs to have exactly 2 functional '
-            'groups but has '
-            f'{building_block.get_num_functional_groups()}.'
+        assert building_block.get_num_functional_groups() == 2, (
+            f"{building_block} needs to have exactly 2 functional "
+            "groups but has "
+            f"{building_block.get_num_functional_groups()}."
         )
         building_block = building_block.with_centroid(
             position=self._position,
             atom_ids=building_block.get_placer_ids(),
         )
         fg0, fg1 = building_block.get_functional_groups()
         fg0_position = building_block.get_centroid(
             atom_ids=fg0.get_placer_ids(),
         )
         fg1_position = building_block.get_centroid(
             atom_ids=fg1.get_placer_ids(),
         )
-        return building_block.with_rotation_between_vectors(
-            start=fg1_position - fg0_position,
-            target=np.array([-1 if self._flip else 1, 0, 0]),
-            origin=self._position,
-        ).with_rotation_about_axis(
-            angle=self._angle-(np.pi/2),
-            axis=np.array([0, 0, 1]),
-            origin=self._position,
-        ).get_position_matrix()
+        return (
+            building_block.with_rotation_between_vectors(
+                start=fg1_position - fg0_position,
+                target=np.array([-1 if self._flip else 1, 0, 0]),
+                origin=self._position,
+            )
+            .with_rotation_about_axis(
+                angle=self._angle - (np.pi / 2),
+                axis=np.array([0, 0, 1]),
+                origin=self._position,
+            )
+            .get_position_matrix()
+        )
 
     def map_functional_groups_to_edges(
         self,
         building_block: BuildingBlock,
         edges: tuple[Edge, ...],
     ) -> dict[int, int]:
-
         fg0_position = building_block.get_centroid(
             atom_ids=next(
                 building_block.get_functional_groups()
             ).get_placer_ids(),
         )
 
         def fg0_distance(edge: Edge) -> float:
             return euclidean(edge.get_position(), fg0_position)
 
         edge0 = min(edges, key=fg0_distance)
         return {
             0: edge0.get_id(),
-            1: (
-                edges[1].get_id()
-                if edge0 is edges[0]
-                else edges[0].get_id()
-            ),
+            1: (edges[1].get_id() if edge0 is edges[0] else edges[0].get_id()),
         }
 
     def __str__(self) -> str:
         return (
-            f'Vertex(id={self._id}, '
-            f'position={tuple(self._position.tolist())}, '
-            f'flip={self._flip}, '
-            f'angle={self._angle})'
+            f"Vertex(id={self._id}, "
+            f"position={tuple(self._position.tolist())}, "
+            f"flip={self._flip}, "
+            f"angle={self._angle})"
         )
```

### Comparing `stk-2022.6.17.0/src/stk/molecular/topology_graphs/metal_complex/metal_complex.py` & `stk-2023.7.5.0/src/stk/_internal/topology_graphs/metal_complex/metal_complex.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,66 +1,32 @@
-"""
-Metal Complex
-=============
-
-.. toctree::
-    :maxdepth: 2
-
-    Paddlewheel <\
-stk.molecular.topology_graphs.metal_complex.paddlewheel.paddlewheel\
->
-    Porphyrin <\
-stk.molecular.topology_graphs.metal_complex.porphyrin.porphyrin\
->
-    Octahedral <\
-stk.molecular.topology_graphs.metal_complex.octahedral.octahedral\
->
-    Octahedral Lambda <\
-stk.molecular.topology_graphs.metal_complex.octahedral\
-.octahedral_lambda\
->
-    Octahedral Delta <\
-stk.molecular.topology_graphs.metal_complex.octahedral\
-.octahedral_delta\
->
-    Square Planar <\
-stk.molecular.topology_graphs.metal_complex.square_planar\
-.square_planar\
->
-    Bidentate Square Planar <\
-stk.molecular.topology_graphs.metal_complex.square_planar\
-.bidentate_square_planar\
->
-    Cis Protected Square Planar <\
-stk.molecular.topology_graphs.metal_complex.square_planar\
-.cis_protected_square_planar\
->
-
-"""
-
 from __future__ import annotations
 
 import typing
 from collections import Counter, abc, defaultdict
 from itertools import product
 
-from ....utilities import OneOrMany
-from ...molecules import BuildingBlock
-from ...reactions import (
+from stk._internal.building_block import BuildingBlock
+from stk._internal.optimizers.null import NullOptimizer
+from stk._internal.optimizers.optimizer import Optimizer
+from stk._internal.reaction_factories.dative_reaction_factory import (
     DativeReactionFactory,
+)
+from stk._internal.reaction_factories.generic_reaction_factory import (
     GenericReactionFactory,
+)
+from stk._internal.reaction_factories.reaction_factory import (
     ReactionFactory,
 )
-from ..topology_graph import (
-    Edge,
-    NullOptimizer,
-    Optimizer,
+from stk._internal.topology_graphs.edge import Edge
+from stk._internal.topology_graphs.topology_graph.topology_graph import (
     TopologyGraph,
-    Vertex,
 )
+from stk._internal.topology_graphs.vertex import Vertex
+from stk._internal.utilities.utilities import OneOrMany
+
 from .vertices import (
     BiDentateLigandVertex,
     MetalVertex,
     MonoDentateLigandVertex,
     UnaligningVertex,
 )
 
@@ -519,23 +485,17 @@
                 ),
             )
 
     """
 
     _edge_prototypes: typing.ClassVar[tuple[Edge, ...]]
     _metal_vertex_prototypes: typing.ClassVar[tuple[MetalVertex, ...]]
-    _ligand_vertex_prototypes: typing.ClassVar[
-        tuple[_LigandVertex, ...],
-    ]
-    _metal_vertices_of_degree: typing.ClassVar[
-        abc.Mapping[int, set[int]],
-    ]
-    _ligand_vertices_of_degree: typing.ClassVar[
-        abc.Mapping[int, set[int]],
-    ]
+    _ligand_vertex_prototypes: typing.ClassVar[tuple[_LigandVertex, ...],]
+    _metal_vertices_of_degree: typing.ClassVar[abc.Mapping[int, set[int]],]
+    _ligand_vertices_of_degree: typing.ClassVar[abc.Mapping[int, set[int]],]
     _vertex_degrees: typing.ClassVar[abc.Mapping[int, int]]
 
     def __init_subclass__(cls, **kwargs: typing.Any) -> None:
         cls._vertex_degrees = Counter(
             vertex_id
             for edge in cls._edge_prototypes
             for vertex_id in edge.get_vertex_ids()
@@ -620,16 +580,17 @@
                 molecule.
 
         """
 
         building_block_vertices = self._normalize_metals(metals)
         building_block_vertices.update(
             (building_block, vertices)
-            for building_block, vertices
-            in self._normalize_ligands(ligands).items()
+            for building_block, vertices in self._normalize_ligands(
+                ligands
+            ).items()
         )
 
         # By default, assign a dative bond order to available
         # functional groups.
         if reaction_factory is None:
             metal_functional_groups = set(
                 type(functional_group)
@@ -644,16 +605,15 @@
             functional_group_pairs = product(
                 metal_functional_groups,
                 ligand_functional_groups,
             )
             reaction_factory = DativeReactionFactory(
                 GenericReactionFactory(
                     bond_orders={
-                        frozenset(pair): 9
-                        for pair in functional_group_pairs
+                        frozenset(pair): 9 for pair in functional_group_pairs
                     }
                 )
             )
 
         super().__init__(
             building_block_vertices=building_block_vertices,
             edges=self._edge_prototypes,
@@ -691,43 +651,36 @@
         if isinstance(metals, dict):
             metals_dict = {
                 metal: tuple(self._get_metal_vertices(ids))
                 for metal, ids in metals.items()
             }
         elif isinstance(metals, tuple):
             functional_group_counter = Counter(
-                metal.get_num_functional_groups()
-                for metal in metals
+                metal.get_num_functional_groups() for metal in metals
             )
-            assert (
-                all(
-                    count == 1
-                    for count
-                    in functional_group_counter.values()
-                )
+            assert all(
+                count == 1 for count in functional_group_counter.values()
             ), (
-                'Cannot use a tuple when multiple metals '
-                'have the same number of functional groups. '
-                'Use a dictionary instead.'
+                "Cannot use a tuple when multiple metals "
+                "have the same number of functional groups. "
+                "Use a dictionary instead."
             )
             metals_dict = {
                 metal: tuple(
                     self._get_metal_vertices(
                         self._metal_vertices_of_degree[
                             metal.get_num_functional_groups()
                         ]
                     )
                 )
                 for metal in metals
             }
         else:
             ids = range(len(self._metal_vertex_prototypes))
-            metals_dict = {
-                metals: tuple(self._get_metal_vertices(ids))
-            }
+            metals_dict = {metals: tuple(self._get_metal_vertices(ids))}
 
         return metals_dict
 
     def _normalize_ligands(
         self,
         ligands: typing.Union[
             BuildingBlock,
@@ -760,44 +713,37 @@
         if isinstance(ligands, dict):
             ligands_dict = {
                 ligand: tuple(self._get_ligand_vertices(ids))
                 for ligand, ids in ligands.items()
             }
         elif isinstance(ligands, tuple):
             functional_group_counter = Counter(
-                ligand.get_num_functional_groups()
-                for ligand in ligands
+                ligand.get_num_functional_groups() for ligand in ligands
             )
-            assert (
-                all(
-                    count == 1
-                    for count
-                    in functional_group_counter.values()
-                )
+            assert all(
+                count == 1 for count in functional_group_counter.values()
             ), (
-                'Cannot use a tuple when multiple ligands '
-                'have the same number of functional groups. '
-                'Use a dictionary instead.'
+                "Cannot use a tuple when multiple ligands "
+                "have the same number of functional groups. "
+                "Use a dictionary instead."
             )
             ligands_dict = {
                 ligand: tuple(
                     self._get_ligand_vertices(
                         self._ligand_vertices_of_degree[
                             ligand.get_num_functional_groups()
                         ]
                     )
                 )
                 for ligand in ligands
             }
 
         else:
             ids = range(len(self._ligand_vertex_prototypes))
-            ligands_dict = {
-                ligands: tuple(self._get_ligand_vertices(ids))
-            }
+            ligands_dict = {ligands: tuple(self._get_ligand_vertices(ids))}
 
         return ligands_dict
 
     def _get_metal_vertices(
         self,
         vertex_ids: OneOrMany[int],
     ) -> typing.Iterator[MetalVertex]:
@@ -812,15 +758,15 @@
         Yields:
 
             A vertex prototype of the topology graph.
 
         """
 
         if isinstance(vertex_ids, int):
-            vertex_ids = (vertex_ids, )
+            vertex_ids = (vertex_ids,)
 
         for vertex_id in vertex_ids:
             yield self._metal_vertex_prototypes[vertex_id]
 
     def _get_ligand_vertices(
         self,
         vertex_ids: OneOrMany[int],
@@ -836,35 +782,29 @@
         Yields:
 
             A vertex prototype of the topology graph.
 
         """
 
         if isinstance(vertex_ids, int):
-            vertex_ids = (vertex_ids, )
+            vertex_ids = (vertex_ids,)
 
         for vertex_id in vertex_ids:
             yield self._ligand_vertex_prototypes[vertex_id]
 
     def _get_scale(
         self,
-        building_block_vertices: dict[
-            BuildingBlock,
-            abc.Sequence[Vertex]
-        ],
+        building_block_vertices: dict[BuildingBlock, abc.Sequence[Vertex]],
     ) -> float:
         return 1
 
     def clone(self) -> MetalComplex:
         return self._clone()
 
     def with_building_blocks(
         self,
         building_block_map: dict[BuildingBlock, BuildingBlock],
     ) -> MetalComplex:
         return self.clone()._with_building_blocks(building_block_map)
 
     def __repr__(self) -> str:
-        return (
-            f'metal_complex.{self.__class__.__name__}'
-            f'()'
-        )
+        return f"metal_complex.{self.__class__.__name__}" f"()"
```

### Comparing `stk-2022.6.17.0/src/stk/molecular/topology_graphs/metal_complex/octahedral/octahedral.py` & `stk-2023.7.5.0/src/stk/_internal/topology_graphs/metal_complex/octahedral.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,16 +1,17 @@
 """
 Octahedral
 ==========
 
 """
 
-from ...topology_graph import Edge
-from ..metal_complex import MetalComplex
-from ..vertices import MetalVertex, MonoDentateLigandVertex
+from stk._internal.topology_graphs.edge import Edge
+
+from .metal_complex import MetalComplex
+from .vertices import MetalVertex, MonoDentateLigandVertex
 
 
 class Octahedral(MetalComplex):
     """
     Represents a metal complex topology graph.
 
     .. moldoc::
@@ -79,17 +80,15 @@
         | metals: (0, )
         | ligands: (0, 1, 2, 3, 4, 5)
 
     See :class:`.MetalComplex` for more details and examples.
 
     """
 
-    _metal_vertex_prototypes = (
-        MetalVertex(0, (0, 0, 0)),
-    )
+    _metal_vertex_prototypes = (MetalVertex(0, (0, 0, 0)),)
     _ligand_vertex_prototypes = (
         MonoDentateLigandVertex(1, (2.5, 0, 0)),
         MonoDentateLigandVertex(2, (0, 2.5, 0)),
         MonoDentateLigandVertex(3, (0, 0, 2.5)),
         MonoDentateLigandVertex(4, (-2.5, 0, 0)),
         MonoDentateLigandVertex(5, (0, -2.5, 0)),
         MonoDentateLigandVertex(6, (0, 0, -2.5)),
```

### Comparing `stk-2022.6.17.0/src/stk/molecular/topology_graphs/metal_complex/octahedral/octahedral_delta.py` & `stk-2023.7.5.0/src/stk/_internal/topology_graphs/metal_complex/octahedral_lambda.py`

 * *Files 3% similar despite different names*

```diff
@@ -1,19 +1,20 @@
 """
-Octahedral Delta
-================
+Octahedral Lambda
+=================
 
 """
 
-from ...topology_graph import Edge
-from ..metal_complex import MetalComplex
-from ..vertices import BiDentateLigandVertex, MetalVertex
+from stk._internal.topology_graphs.edge import Edge
 
+from .metal_complex import MetalComplex
+from .vertices import BiDentateLigandVertex, MetalVertex
 
-class OctahedralDelta(MetalComplex):
+
+class OctahedralLambda(MetalComplex):
     """
     Represents a metal complex topology graph.
 
     .. moldoc::
 
         import moldoc.molecule as molecule
         import stk
@@ -36,15 +37,15 @@
                     smarts='[#6]~[#7X2]~[#6]',
                     bonders=(1, ),
                     deleters=(),
                 ),
             ],
         )
         complex = stk.ConstructedMolecule(
-            topology_graph=stk.metal_complex.OctahedralDelta(
+            topology_graph=stk.metal_complex.OctahedralLambda(
                 metals=bb1,
                 ligands=bb2,
             ),
         )
 
         moldoc_display_molecule = molecule.Molecule(
             atoms=(
@@ -82,21 +83,19 @@
         | metals: (0, )
         | ligands: (0, 1, 2)
 
     See :class:`.MetalComplex` for more details and examples.
 
     """
 
-    _metal_vertex_prototypes = (
-        MetalVertex(0, (0, 0, 0)),
-    )
+    _metal_vertex_prototypes = (MetalVertex(0, (0, 0, 0)),)
     _ligand_vertex_prototypes = (
         BiDentateLigandVertex(1, (2.5, 2.5, 0)),
-        BiDentateLigandVertex(2, (0, -2.5, 2.5)),
-        BiDentateLigandVertex(3, (-2.5, 0, -2.5)),
+        BiDentateLigandVertex(2, (0, -2.5, -2.5)),
+        BiDentateLigandVertex(3, (-2.5, 0, 2.5)),
     )
 
     # The ordering here matters for the stereochemistry.
     # The first edge to appear between two vertices determines the
     # directionality of the binding ligand.
     _edge_prototypes = (
         Edge(
@@ -108,31 +107,31 @@
         Edge(
             id=1,
             vertex1=_metal_vertex_prototypes[0],
             vertex2=_ligand_vertex_prototypes[0],
             position=(0, 2.5, 0),
         ),
         Edge(
-            id=4,
-            vertex1=_metal_vertex_prototypes[0],
-            vertex2=_ligand_vertex_prototypes[1],
-            position=(0, -2.5, 0),
-        ),
-        Edge(
             id=2,
             vertex1=_metal_vertex_prototypes[0],
-            vertex2=_ligand_vertex_prototypes[1],
+            vertex2=_ligand_vertex_prototypes[2],
             position=(0, 0, 2.5),
         ),
         Edge(
-            id=5,
+            id=3,
             vertex1=_metal_vertex_prototypes[0],
             vertex2=_ligand_vertex_prototypes[2],
-            position=(0, 0, -2.5),
+            position=(-2.5, 0, 0),
         ),
         Edge(
-            id=3,
+            id=4,
             vertex1=_metal_vertex_prototypes[0],
-            vertex2=_ligand_vertex_prototypes[2],
-            position=(-2.5, 0, 0),
+            vertex2=_ligand_vertex_prototypes[1],
+            position=(0, -2.5, 0),
+        ),
+        Edge(
+            id=5,
+            vertex1=_metal_vertex_prototypes[0],
+            vertex2=_ligand_vertex_prototypes[1],
+            position=(0, 0, -2.5),
         ),
     )
```

### Comparing `stk-2022.6.17.0/src/stk/molecular/topology_graphs/metal_complex/octahedral/octahedral_lambda.py` & `stk-2023.7.5.0/src/stk/_internal/topology_graphs/metal_complex/octahedral_delta.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,19 +1,20 @@
 """
-Octahedral Lambda
-=================
+Octahedral Delta
+================
 
 """
 
-from ...topology_graph import Edge
-from ..metal_complex import MetalComplex
-from ..vertices import BiDentateLigandVertex, MetalVertex
+from stk._internal.topology_graphs.edge import Edge
 
+from .metal_complex import MetalComplex
+from .vertices import BiDentateLigandVertex, MetalVertex
 
-class OctahedralLambda(MetalComplex):
+
+class OctahedralDelta(MetalComplex):
     """
     Represents a metal complex topology graph.
 
     .. moldoc::
 
         import moldoc.molecule as molecule
         import stk
@@ -36,15 +37,15 @@
                     smarts='[#6]~[#7X2]~[#6]',
                     bonders=(1, ),
                     deleters=(),
                 ),
             ],
         )
         complex = stk.ConstructedMolecule(
-            topology_graph=stk.metal_complex.OctahedralLambda(
+            topology_graph=stk.metal_complex.OctahedralDelta(
                 metals=bb1,
                 ligands=bb2,
             ),
         )
 
         moldoc_display_molecule = molecule.Molecule(
             atoms=(
@@ -82,21 +83,19 @@
         | metals: (0, )
         | ligands: (0, 1, 2)
 
     See :class:`.MetalComplex` for more details and examples.
 
     """
 
-    _metal_vertex_prototypes = (
-        MetalVertex(0, (0, 0, 0)),
-    )
+    _metal_vertex_prototypes = (MetalVertex(0, (0, 0, 0)),)
     _ligand_vertex_prototypes = (
         BiDentateLigandVertex(1, (2.5, 2.5, 0)),
-        BiDentateLigandVertex(2, (0, -2.5, -2.5)),
-        BiDentateLigandVertex(3, (-2.5, 0, 2.5)),
+        BiDentateLigandVertex(2, (0, -2.5, 2.5)),
+        BiDentateLigandVertex(3, (-2.5, 0, -2.5)),
     )
 
     # The ordering here matters for the stereochemistry.
     # The first edge to appear between two vertices determines the
     # directionality of the binding ligand.
     _edge_prototypes = (
         Edge(
@@ -108,31 +107,31 @@
         Edge(
             id=1,
             vertex1=_metal_vertex_prototypes[0],
             vertex2=_ligand_vertex_prototypes[0],
             position=(0, 2.5, 0),
         ),
         Edge(
-            id=2,
-            vertex1=_metal_vertex_prototypes[0],
-            vertex2=_ligand_vertex_prototypes[2],
-            position=(0, 0, 2.5),
-        ),
-        Edge(
-            id=3,
+            id=4,
             vertex1=_metal_vertex_prototypes[0],
-            vertex2=_ligand_vertex_prototypes[2],
-            position=(-2.5, 0, 0),
+            vertex2=_ligand_vertex_prototypes[1],
+            position=(0, -2.5, 0),
         ),
         Edge(
-            id=4,
+            id=2,
             vertex1=_metal_vertex_prototypes[0],
             vertex2=_ligand_vertex_prototypes[1],
-            position=(0, -2.5, 0),
+            position=(0, 0, 2.5),
         ),
         Edge(
             id=5,
             vertex1=_metal_vertex_prototypes[0],
-            vertex2=_ligand_vertex_prototypes[1],
+            vertex2=_ligand_vertex_prototypes[2],
             position=(0, 0, -2.5),
         ),
+        Edge(
+            id=3,
+            vertex1=_metal_vertex_prototypes[0],
+            vertex2=_ligand_vertex_prototypes[2],
+            position=(-2.5, 0, 0),
+        ),
     )
```

### Comparing `stk-2022.6.17.0/src/stk/molecular/topology_graphs/metal_complex/paddlewheel/paddlewheel.py` & `stk-2023.7.5.0/src/stk/_internal/topology_graphs/metal_complex/paddlewheel.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,16 +1,17 @@
 """
 Paddlewheel
 ===========
 
 """
 
-from ...topology_graph import Edge
-from ..metal_complex import MetalComplex
-from ..vertices import BiDentateLigandVertex, MetalVertex
+from stk._internal.topology_graphs.edge import Edge
+
+from .metal_complex import MetalComplex
+from .vertices import BiDentateLigandVertex, MetalVertex
 
 
 class Paddlewheel(MetalComplex):
     """
     Represents a metal complex topology graph.
 
     .. moldoc::
@@ -118,41 +119,38 @@
         ),
         Edge(
             id=1,
             vertex1=_metal_vertex_prototypes[1],
             vertex2=_ligand_vertex_prototypes[0],
             position=(0.1, -0.5, 0),
         ),
-
         Edge(
             id=2,
             vertex1=_metal_vertex_prototypes[0],
             vertex2=_ligand_vertex_prototypes[1],
             position=(0, 0.5, 0.1),
         ),
         Edge(
             id=3,
             vertex1=_metal_vertex_prototypes[1],
             vertex2=_ligand_vertex_prototypes[1],
             position=(0, -0.5, 0.1),
         ),
-
         Edge(
             id=4,
             vertex1=_metal_vertex_prototypes[0],
             vertex2=_ligand_vertex_prototypes[2],
             position=(-0.1, 0.5, 0),
         ),
         Edge(
             id=5,
             vertex1=_metal_vertex_prototypes[1],
             vertex2=_ligand_vertex_prototypes[2],
             position=(-0.1, -0.5, 0),
         ),
-
         Edge(
             id=6,
             vertex1=_metal_vertex_prototypes[0],
             vertex2=_ligand_vertex_prototypes[3],
             position=(0, 0.5, -0.1),
         ),
         Edge(
```

### Comparing `stk-2022.6.17.0/src/stk/molecular/topology_graphs/metal_complex/porphyrin/porphyrin.py` & `stk-2023.7.5.0/src/stk/_internal/topology_graphs/metal_complex/porphyrin.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,16 +1,17 @@
 """
 Porphyrin
 =========
 
 """
 
-from ...topology_graph import Edge
-from ..metal_complex import MetalComplex
-from ..vertices import MetalVertex, UnaligningVertex
+from stk._internal.topology_graphs.edge import Edge
+
+from .metal_complex import MetalComplex
+from .vertices import MetalVertex, UnaligningVertex
 
 
 class Porphyrin(MetalComplex):
     """
     Represents a metal complex topology graph.
 
     .. moldoc::
@@ -82,16 +83,16 @@
         | metals: (0, )
         | ligands: (0, )
 
     See :class:`.MetalComplex` for more details and examples.
 
     """
 
-    _metal_vertex_prototypes = (MetalVertex(0, (0, 0, 0)), )
-    _ligand_vertex_prototypes = (UnaligningVertex(1, (0, 0, 0)), )
+    _metal_vertex_prototypes = (MetalVertex(0, (0, 0, 0)),)
+    _ligand_vertex_prototypes = (UnaligningVertex(1, (0, 0, 0)),)
 
     _edge_prototypes = (
         Edge(
             id=0,
             vertex1=_metal_vertex_prototypes[0],
             vertex2=_ligand_vertex_prototypes[0],
             position=(0.1, 0, 0),
```

### Comparing `stk-2022.6.17.0/src/stk/molecular/topology_graphs/metal_complex/square_planar/bidentate_square_planar.py` & `stk-2023.7.5.0/src/stk/_internal/topology_graphs/metal_complex/bidentate_square_planar.py`

 * *Files 5% similar despite different names*

```diff
@@ -1,16 +1,17 @@
 """
 Bidentate Square Planar
 =======================
 
 """
 
-from ...topology_graph import Edge
-from ..metal_complex import MetalComplex
-from ..vertices import BiDentateLigandVertex, MetalVertex
+from stk._internal.topology_graphs.edge import Edge
+
+from .metal_complex import MetalComplex
+from .vertices import BiDentateLigandVertex, MetalVertex
 
 
 class BidentateSquarePlanar(MetalComplex):
     """
     Represents a square planar metal complex topology graph.
 
     .. moldoc::
@@ -79,17 +80,15 @@
         | metals: (0, )
         | ligands: (0, 1)
 
     See :class:`.MetalComplex` for more details and examples.
 
     """
 
-    _metal_vertex_prototypes = (
-        MetalVertex(0, (0, 0, 0)),
-    )
+    _metal_vertex_prototypes = (MetalVertex(0, (0, 0, 0)),)
     _ligand_vertex_prototypes = (
         BiDentateLigandVertex(1, (2.5, 2.5, 0)),
         BiDentateLigandVertex(2, (-2.5, -2.5, 0)),
     )
 
     _edge_prototypes = (
         Edge(
@@ -100,15 +99,14 @@
         ),
         Edge(
             id=1,
             vertex1=_metal_vertex_prototypes[0],
             vertex2=_ligand_vertex_prototypes[0],
             position=(0, 2.5, 0),
         ),
-
         Edge(
             id=2,
             vertex1=_metal_vertex_prototypes[0],
             vertex2=_ligand_vertex_prototypes[1],
             position=(-1, 0, 0),
         ),
         Edge(
```

### Comparing `stk-2022.6.17.0/src/stk/molecular/topology_graphs/metal_complex/square_planar/cis_protected_square_planar.py` & `stk-2023.7.5.0/src/stk/_internal/topology_graphs/metal_complex/cis_protected_square_planar.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,16 +1,17 @@
 """
 Cis Protected Square Planar
 ===========================
 
 """
 
-from ...topology_graph import Edge
-from ..metal_complex import MetalComplex
-from ..vertices import BiDentateLigandVertex, MetalVertex
+from stk._internal.topology_graphs.edge import Edge
+
+from .metal_complex import MetalComplex
+from .vertices import BiDentateLigandVertex, MetalVertex
 
 
 class CisProtectedSquarePlanar(MetalComplex):
     """
     Represents a square planar metal complex topology graph.
 
     .. moldoc::
@@ -79,20 +80,16 @@
         | metals: (0, )
         | ligands: (0, )
 
     See :class:`.MetalComplex` for more details and examples.
 
     """
 
-    _metal_vertex_prototypes = (
-        MetalVertex(0, (0, 0, 0)),
-    )
-    _ligand_vertex_prototypes = (
-        BiDentateLigandVertex(1, (2.5, 2.5, 0)),
-    )
+    _metal_vertex_prototypes = (MetalVertex(0, (0, 0, 0)),)
+    _ligand_vertex_prototypes = (BiDentateLigandVertex(1, (2.5, 2.5, 0)),)
 
     _edge_prototypes = (
         Edge(
             id=0,
             vertex1=_metal_vertex_prototypes[0],
             vertex2=_ligand_vertex_prototypes[0],
             position=(2.5, 0, 0),
```

### Comparing `stk-2022.6.17.0/src/stk/molecular/topology_graphs/metal_complex/square_planar/square_planar.py` & `stk-2023.7.5.0/src/stk/_internal/topology_graphs/metal_complex/square_planar.py`

 * *Files 5% similar despite different names*

```diff
@@ -1,16 +1,17 @@
 """
 Square Planar
 =============
 
 """
 
-from ...topology_graph import Edge
-from ..metal_complex import MetalComplex
-from ..vertices import MetalVertex, MonoDentateLigandVertex
+from stk._internal.topology_graphs.edge import Edge
+
+from .metal_complex import MetalComplex
+from .vertices import MetalVertex, MonoDentateLigandVertex
 
 
 class SquarePlanar(MetalComplex):
     """
     Represents a square planar metal complex topology graph.
 
     .. moldoc::
@@ -79,17 +80,15 @@
         | metals: (0, )
         | ligands: (0, 1, 2, 3)
 
     See :class:`.MetalComplex` for more details and examples.
 
     """
 
-    _metal_vertex_prototypes = (
-        MetalVertex(0, (0, 0, 0)),
-    )
+    _metal_vertex_prototypes = (MetalVertex(0, (0, 0, 0)),)
     _ligand_vertex_prototypes = (
         MonoDentateLigandVertex(1, (2.5, 0, 0)),
         MonoDentateLigandVertex(2, (0, 2.5, 0)),
         MonoDentateLigandVertex(3, (-2.5, 0, 0)),
         MonoDentateLigandVertex(4, (0, -2.5, 0)),
     )
```

### Comparing `stk-2022.6.17.0/src/stk/molecular/topology_graphs/metal_complex/vertices.py` & `stk-2023.7.5.0/src/stk/_internal/topology_graphs/metal_complex/vertices.py`

 * *Files 3% similar despite different names*

```diff
@@ -2,17 +2,16 @@
 Metal Complex Vertices
 ======================
 
 """
 
 from scipy.spatial.distance import euclidean
 
-from stk.utilities import get_projection
-
-from ..topology_graph import Vertex
+from stk._internal.topology_graphs.vertex import Vertex
+from stk._internal.utilities.utilities import get_projection
 
 
 class UnaligningVertex(Vertex):
     """
     A vertex which does no rotations.
 
     """
@@ -20,18 +19,15 @@
     def place_building_block(self, building_block, edges):
         return building_block.with_centroid(
             position=self._position,
             atom_ids=building_block.get_placer_ids(),
         ).get_position_matrix()
 
     def map_functional_groups_to_edges(self, building_block, edges):
-
-        return {
-            fg_id: edge.get_id() for fg_id, edge in enumerate(edges)
-        }
+        return {fg_id: edge.get_id() for fg_id, edge in enumerate(edges)}
 
 
 class MetalVertex(UnaligningVertex):
     """
     Places the metal in a :class:`.MetalComplex`.
 
     """
@@ -46,71 +42,64 @@
     """
 
     def place_building_block(self, building_block, edges):
         building_block = building_block.with_centroid(
             position=self._position,
             atom_ids=building_block.get_placer_ids(),
         )
-        assert (
-            building_block.get_num_functional_groups() == 1
-        ), (
-            f'{building_block} needs to have exactly 1 functional '
-            'group but has '
-            f'{building_block.get_num_functional_groups()}.'
+        assert building_block.get_num_functional_groups() == 1, (
+            f"{building_block} needs to have exactly 1 functional "
+            "group but has "
+            f"{building_block.get_num_functional_groups()}."
         )
-        fg, = building_block.get_functional_groups(0)
+        (fg,) = building_block.get_functional_groups(0)
         fg_centroid = building_block.get_centroid(
             atom_ids=fg.get_placer_ids(),
         )
         core_centroid = building_block.get_centroid(
             atom_ids=building_block.get_core_atom_ids(),
         )
-        edge_centroid = (
-            sum(edge.get_position() for edge in edges) / len(edges)
-        )
+        edge_centroid = sum(edge.get_position() for edge in edges) / len(edges)
         return building_block.with_rotation_between_vectors(
             start=fg_centroid - core_centroid,
             target=edge_centroid - self._position,
             origin=self._position,
         ).get_position_matrix()
 
     def map_functional_groups_to_edges(self, building_block, edges):
-
         return {0: edges[0].get_id()}
 
 
 class BiDentateLigandVertex(Vertex):
     """
     Places bidentate ligand in a :class:`.MetalComplex`.
 
     """
 
     def place_building_block(self, building_block, edges):
         building_block = building_block.with_centroid(
             position=self._position,
             atom_ids=building_block.get_placer_ids(),
         )
-        assert (
-            building_block.get_num_functional_groups() == 2
-        ), (
-            f'{building_block} needs to have exactly 2 functional '
-            'groups but has '
-            f'{building_block.get_num_functional_groups()}.'
+        assert building_block.get_num_functional_groups() == 2, (
+            f"{building_block} needs to have exactly 2 functional "
+            "groups but has "
+            f"{building_block.get_num_functional_groups()}."
         )
 
         fg0_position, fg1_position = (
             building_block.get_centroid(fg.get_placer_ids())
             for fg in building_block.get_functional_groups()
         )
         edge_position1, edge_position2 = (
             edge.get_position() for edge in edges
         )
         building_block = building_block.with_rotation_between_vectors(
-            start=fg1_position-fg0_position,
-            target=edge_position2-edge_position1,
+            start=fg1_position - fg0_position,
+            target=edge_position2 - edge_position1,
             origin=building_block.get_centroid(),
         )
 
         placer_centroid = building_block.get_centroid(
             atom_ids=building_block.get_placer_ids(),
         )
         core_centroid = building_block.get_centroid(
@@ -125,32 +114,28 @@
         fg_vector = fg1_position - fg0_position
 
         fg_vector_projection = get_projection(
             start=core_to_placer,
             target=fg_vector,
         )
 
-        edge_centroid = (
-            sum(edge.get_position() for edge in edges) / len(edges)
-        )
+        edge_centroid = sum(edge.get_position() for edge in edges) / len(edges)
         building_block = building_block.with_rotation_between_vectors(
             start=core_to_placer - fg_vector_projection,
             target=edge_centroid - self._position,
             origin=building_block.get_centroid(),
         )
 
         return building_block.with_centroid(
             position=self._position,
             atom_ids=building_block.get_placer_ids(),
         ).get_position_matrix()
 
     def map_functional_groups_to_edges(self, building_block, edges):
-        fg, = building_block.get_functional_groups(0)
+        (fg,) = building_block.get_functional_groups(0)
         fg_position = building_block.get_centroid(fg.get_placer_ids())
 
         def fg_distance(edge):
             return euclidean(edge.get_position(), fg_position)
 
         edges = sorted(edges, key=fg_distance)
-        return {
-            fg_id: edge.get_id() for fg_id, edge in enumerate(edges)
-        }
+        return {fg_id: edge.get_id() for fg_id, edge in enumerate(edges)}
```

### Comparing `stk-2022.6.17.0/src/stk/molecular/topology_graphs/polymer/linear/linear.py` & `stk-2023.7.5.0/src/stk/_internal/topology_graphs/polymer/linear/linear.py`

 * *Files 7% similar despite different names*

```diff
@@ -1,30 +1,30 @@
-"""
-Linear
-======
-
-"""
-
 from __future__ import annotations
 
 import typing
 from collections import abc
 from dataclasses import dataclass
 
 import numpy as np
 
-from ....molecules import BuildingBlock
-from ....reactions import GenericReactionFactory, ReactionFactory
-from ...topology_graph import (
-    Edge,
-    NullOptimizer,
+from stk._internal.building_block import BuildingBlock
+from stk._internal.optimizers.null import NullOptimizer
+from stk._internal.optimizers.optimizer import Optimizer
+from stk._internal.reaction_factories.generic_reaction_factory import (
+    GenericReactionFactory,
+)
+from stk._internal.reaction_factories.reaction_factory import (
+    ReactionFactory,
+)
+from stk._internal.topology_graphs.edge import Edge
+from stk._internal.topology_graphs.topology_graph.topology_graph import (
     TopologyGraph,
-    Vertex,
 )
-from ...topology_graph.optimizers import Optimizer
+from stk._internal.topology_graphs.vertex import Vertex
+
 from .vertices import (
     HeadVertex,
     LinearVertex,
     TailVertex,
     UnaligningVertex,
 )
 
@@ -34,14 +34,15 @@
     Represents a linear polymer topology graph.
 
     Building blocks with two functional groups are required, unless the
     building block's position is specified to only be at the capping
     positions.
 
     Examples:
+
         *Construction*
 
         Linear polymers require building blocks with two functional
         groups
 
         .. testcode:: construction
 
@@ -407,16 +408,16 @@
     """
 
     def __init__(
         self,
         building_blocks: tuple[BuildingBlock, ...],
         repeating_unit: typing.Union[str, tuple[int, ...]],
         num_repeating_units: int,
-        orientations: typing.Optional[tuple[float, ...]] = None,
-        random_seed: typing.Optional[int] = None,
+        orientations: tuple[float, ...] | None = None,
+        random_seed: int | np.random.Generator | None = None,
         reaction_factory: ReactionFactory = GenericReactionFactory(),
         num_processes: int = 1,
         optimizer: Optimizer = NullOptimizer(),
     ) -> None:
         """
         Initialize a :class:`Linear` instance.
 
@@ -482,27 +483,25 @@
             :class:`ValueError`
                 If the length of `orientations` is not equal in length
                 to `repeating_unit` or to the total number of vertices.
 
         """
 
         if orientations is None:
-            orientations = tuple(
-                0. for i in range(len(repeating_unit))
-            )
+            orientations = tuple(0.0 for _ in range(len(repeating_unit)))
 
         if len(orientations) == len(repeating_unit):
-            orientations = orientations*num_repeating_units
+            orientations = orientations * num_repeating_units
 
-        polymer_length = len(repeating_unit)*num_repeating_units
+        polymer_length = len(repeating_unit) * num_repeating_units
         if len(orientations) != polymer_length:
             raise ValueError(
-                'The length of orientations must match either '
-                'the length of repeating_unit or the '
-                'total number of vertices.'
+                "The length of orientations must match either "
+                "the length of repeating_unit or the "
+                "total number of vertices."
             )
 
         # Keep these for __repr__.
         self._repeating_unit = self._normalize_repeating_unit(
             repeating_unit=repeating_unit
         )
         self._num_repeating_units = num_repeating_units
@@ -515,17 +514,15 @@
                 tail_orientation=tail,
                 random_seed=random_seed,
             )
             vertices = vertices_and_edges.vertices
             edges = vertices_and_edges.edges
 
         except ValueError:
-            vertices = (
-                UnaligningVertex(0, (0., 0., 0.), False),
-            )
+            vertices = (UnaligningVertex(0, (0.0, 0.0, 0.0), False),)
             edges = ()
 
         # Save the chosen orientations for __repr__.
         self._orientations = tuple(int(v.get_flip()) for v in vertices)
 
         super().__init__(
             building_block_vertices=self._get_building_block_vertices(
@@ -538,17 +535,17 @@
             optimizer=optimizer,
             num_processes=num_processes,
         )
 
     @staticmethod
     def _get_vertices_and_edges(
         head_orientation: float,
-        body_orientations: typing.Iterable[float],
+        body_orientations: abc.Iterable[float],
         tail_orientation: float,
-        random_seed: typing.Optional[int],
+        random_seed: int | np.random.Generator | None,
     ) -> _VerticesAndEdges:
         """
         Get the vertices and edges of the topology graph.
 
         Parameters:
 
             head_orientation:
@@ -566,42 +563,43 @@
 
         Returns:
 
             The vertices and edges of the topology graph.
 
         """
 
-        generator = np.random.RandomState(random_seed)
+        if random_seed is None or isinstance(random_seed, int):
+            random_seed = np.random.default_rng(random_seed)
 
         choices = [True, False]
         vertices: list[LinearVertex] = [
             HeadVertex(
                 id=0,
                 position=np.array([0, 0, 0]),
-                flip=generator.choice(
+                flip=random_seed.choice(
                     a=choices,
-                    p=[head_orientation, 1-head_orientation],
+                    p=[head_orientation, 1 - head_orientation],
                 ),
             ),
         ]
         edges: list[Edge] = []
         for i, p in enumerate(body_orientations, 1):
-            flip = generator.choice(choices, p=[p, 1-p])
+            flip = random_seed.choice(choices, p=[p, 1 - p])
             vertices.append(
                 LinearVertex(i, np.array([i, 0, 0]), flip),
             )
-            edges.append(Edge(len(edges), vertices[i-1], vertices[i]))
+            edges.append(Edge(len(edges), vertices[i - 1], vertices[i]))
 
         vertices.append(
             TailVertex(
                 id=len(vertices),
                 position=np.array([len(vertices), 0, 0]),
-                flip=generator.choice(
+                flip=random_seed.choice(
                     a=choices,
-                    p=[tail_orientation, 1-tail_orientation],
+                    p=[tail_orientation, 1 - tail_orientation],
                 ),
             ),
         )
 
         edges.append(Edge(len(edges), vertices[-2], vertices[-1]))
 
         return _VerticesAndEdges(
@@ -616,64 +614,56 @@
         clone._orientations = self._orientations
         return clone
 
     @staticmethod
     def _normalize_repeating_unit(
         repeating_unit: typing.Union[str, tuple[int, ...]],
     ) -> tuple[int, ...]:
-
         if isinstance(repeating_unit, tuple):
             return repeating_unit
 
-        base = ord('A')
-        return tuple(ord(letter)-base for letter in repeating_unit)
+        base = ord("A")
+        return tuple(ord(letter) - base for letter in repeating_unit)
 
     def _get_building_block_vertices(
         self,
         building_blocks: tuple[BuildingBlock, ...],
         vertices: tuple[LinearVertex, ...],
     ) -> dict[BuildingBlock, abc.Sequence[Vertex]]:
+        polymer = self._repeating_unit * self._num_repeating_units
 
-        polymer = self._repeating_unit*self._num_repeating_units
-
-        building_block_vertices: dict[
-            BuildingBlock, list[LinearVertex]
-        ] = {}
+        building_block_vertices: dict[BuildingBlock, list[LinearVertex]] = {}
 
         for bb_index, vertex in zip(polymer, vertices):
             bb = building_blocks[bb_index]
-            building_block_vertices[bb] = (
-                building_block_vertices.get(bb, [])
-            )
+            building_block_vertices[bb] = building_block_vertices.get(bb, [])
             building_block_vertices[bb].append(vertex)
 
         return self._with_unaligning_vertices(
             building_block_vertices=building_block_vertices,
         )
 
     @staticmethod
     def _with_unaligning_vertices(
-        building_block_vertices: dict[
-            BuildingBlock, list[LinearVertex]
-        ],
+        building_block_vertices: dict[BuildingBlock, list[LinearVertex]],
     ) -> dict[BuildingBlock, abc.Sequence[Vertex]]:
-
         clone: dict[BuildingBlock, abc.Sequence[Vertex]]
         clone = {}
         terminal_ids = {
             0,
             max(
                 vertex.get_id()
                 for vertex_list in building_block_vertices.values()
                 for vertex in vertex_list
-            )
+            ),
         }
-        for building_block, vertices in (
-            building_block_vertices.items()
-        ):
+        for (
+            building_block,
+            vertices,
+        ) in building_block_vertices.items():
             # Building blocks with 1 placer, cannot be aligned on
             # linear vertices and must therefore use an
             # UnaligningVertex. Building blocks with 1 placer can be
             # placed on terminal vertices (HeadVertex or TailVertex).
             # This can be discerned based on the knowledge that the
             # first and last vertex are the Head and Tail,
             # respectively.
@@ -683,43 +673,39 @@
                         UnaligningVertex(
                             id=vertex.get_id(),
                             position=vertex.get_position(),
                             flip=vertex.get_flip(),
                         )
                         if vertex.get_id() not in terminal_ids
                         else vertex
-                    ) for vertex in vertices
+                    )
+                    for vertex in vertices
                 )
             else:
                 clone[building_block] = vertices
 
         return clone
 
     def _get_scale(
         self,
-        building_block_vertices: dict[
-            BuildingBlock, abc.Sequence[Vertex]
-        ],
+        building_block_vertices: dict[BuildingBlock, abc.Sequence[Vertex]],
     ) -> float:
-        return max(
-            bb.get_maximum_diameter()
-            for bb in building_block_vertices
-        )
+        return max(bb.get_maximum_diameter() for bb in building_block_vertices)
 
     def with_building_blocks(
         self,
         building_block_map: dict[BuildingBlock, BuildingBlock],
     ) -> Linear:
         return self.clone()._with_building_blocks(building_block_map)
 
     def __repr__(self) -> str:
         return (
-            f'polymer.Linear({self._repeating_unit!r}, '
-            f'{self._num_repeating_units!r}, '
-            f'{self._orientations!r})'
+            f"polymer.Linear({self._repeating_unit!r}, "
+            f"{self._num_repeating_units!r}, "
+            f"{self._orientations!r})"
         )
 
 
 @dataclass(frozen=True)
 class _VerticesAndEdges:
     vertices: tuple[LinearVertex, ...]
     edges: tuple[Edge, ...]
```

### Comparing `stk-2022.6.17.0/src/stk/molecular/topology_graphs/polymer/linear/vertices.py` & `stk-2023.7.5.0/src/stk/_internal/topology_graphs/polymer/linear/vertices.py`

 * *Files 3% similar despite different names*

```diff
@@ -2,15 +2,15 @@
 Linear Polymer Vertices
 =======================
 
 """
 
 import logging
 
-from ...topology_graph import Vertex
+from stk._internal.topology_graphs.vertex import Vertex
 
 logger = logging.getLogger(__name__)
 
 
 class LinearVertex(Vertex):
     """
     Represents a vertex in the middle of a linear polymer chain.
@@ -53,20 +53,18 @@
 
     def clone(self):
         clone = super().clone()
         clone._flip = self._flip
         return clone
 
     def place_building_block(self, building_block, edges):
-        assert (
-            building_block.get_num_functional_groups() == 2
-        ), (
-            f'{building_block} needs to have exactly 2 functional '
-            'groups but has '
-            f'{building_block.get_num_functional_groups()}.'
+        assert building_block.get_num_functional_groups() == 2, (
+            f"{building_block} needs to have exactly 2 functional "
+            "groups but has "
+            f"{building_block.get_num_functional_groups()}."
         )
         building_block = building_block.with_centroid(
             position=self._position,
             atom_ids=building_block.get_placer_ids(),
         )
         fg1, fg2 = building_block.get_functional_groups()
         fg1_position = building_block.get_centroid(
@@ -108,17 +106,17 @@
         if x1 < x2:
             return edge1.get_id(), edge2.get_id()
         else:
             return edge2.get_id(), edge1.get_id()
 
     def __str__(self):
         return (
-            f'Vertex(id={self._id}, '
-            f'position={self._position.tolist()}, '
-            f'flip={self._flip})'
+            f"Vertex(id={self._id}, "
+            f"position={self._position.tolist()}, "
+            f"flip={self._flip})"
         )
 
 
 class TerminalVertex(LinearVertex):
     """
     Represents a vertex at the end of a polymer chain.
 
@@ -161,16 +159,16 @@
             return {functional_groups[index]: edges[0].get_id()}
 
         elif building_block.get_num_functional_groups() == 1:
             return {0: edges[0].get_id()}
 
         else:
             raise ValueError(
-                'The building block of a polymer '
-                'must have 1 or 2 functional groups.'
+                "The building block of a polymer "
+                "must have 1 or 2 functional groups."
             )
 
 
 class HeadVertex(TerminalVertex):
     """
     Represents a vertex at the head of a polymer chain.
 
@@ -201,10 +199,8 @@
     def place_building_block(self, building_block, edges):
         return building_block.with_centroid(
             position=self._position,
             atom_ids=building_block.get_placer_ids(),
         ).get_position_matrix()
 
     def map_functional_groups_to_edges(self, building_block, edges):
-        return {
-            fg_id: edge.get_id() for fg_id, edge in enumerate(edges)
-        }
+        return {fg_id: edge.get_id() for fg_id, edge in enumerate(edges)}
```

### Comparing `stk-2022.6.17.0/src/stk/molecular/topology_graphs/rotaxane/nrotaxane.py` & `stk-2023.7.5.0/src/stk/_internal/topology_graphs/rotaxane/nrotaxane.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,16 +1,21 @@
-"""
-[n]Rotaxane
-===========
-
-"""
+from collections.abc import Iterable
 
 import numpy as np
 
-from ..topology_graph import NullOptimizer, TopologyGraph
+from stk._internal.building_block import BuildingBlock
+from stk._internal.optimizers.null import NullOptimizer
+from stk._internal.optimizers.optimizer import Optimizer
+from stk._internal.reaction_factories.generic_reaction_factory import (
+    GenericReactionFactory,
+)
+from stk._internal.topology_graphs.topology_graph.topology_graph import (
+    TopologyGraph,
+)
+
 from .vertices import AxleVertex, CycleVertex
 
 
 class NRotaxane(TopologyGraph):
     """
     Represents [n]rotaxane topology graphs.
 
@@ -18,480 +23,482 @@
 
     This class assumes one axle with (n-1) macrocycles threaded on it.
     The macrocycles are spaced evenly along the axle in repeating
     patterns. The threaded macrocycles can be described analogously
     to monomers in linear polymers, in terms of a repeating unit,
     except that no bonds are formed between them.
 
-    Examples
-    --------
-    *Construction*
+    Examples:
+
+        *Construction*
 
-    .. testcode:: construction
+        .. testcode:: construction
 
-        import stk
+            import stk
 
-        cycle = stk.ConstructedMolecule(
-            topology_graph=stk.macrocycle.Macrocycle(
-                building_blocks=(
-                    stk.BuildingBlock(
-                        smiles='[Br]CC[Br]',
-                        functional_groups=[stk.BromoFactory()],
+            cycle = stk.ConstructedMolecule(
+                topology_graph=stk.macrocycle.Macrocycle(
+                    building_blocks=(
+                        stk.BuildingBlock(
+                            smiles='[Br]CC[Br]',
+                            functional_groups=[stk.BromoFactory()],
+                        ),
                     ),
+                    repeating_unit='A',
+                    num_repeating_units=5,
                 ),
-                repeating_unit='A',
-                num_repeating_units=5,
-            ),
-        )
-        axle = stk.ConstructedMolecule(
-            topology_graph=stk.polymer.Linear(
-                building_blocks=(
-                    stk.BuildingBlock('BrCCBr', [stk.BromoFactory()]),
-                    stk.BuildingBlock('BrCNCBr', [stk.BromoFactory()]),
-                ),
-                repeating_unit='AB',
-                num_repeating_units=7,
             )
-        )
-        rotaxane = stk.ConstructedMolecule(
-            topology_graph=stk.rotaxane.NRotaxane(
-                axle=stk.BuildingBlock.init_from_molecule(axle),
-                cycles=(
-                    stk.BuildingBlock.init_from_molecule(cycle),
+            axle = stk.ConstructedMolecule(
+                topology_graph=stk.polymer.Linear(
+                    building_blocks=(
+                        stk.BuildingBlock('BrCCBr', [stk.BromoFactory()]),
+                        stk.BuildingBlock('BrCNCBr', [stk.BromoFactory()]),
+                    ),
+                    repeating_unit='AB',
+                    num_repeating_units=7,
+                )
+            )
+            rotaxane = stk.ConstructedMolecule(
+                topology_graph=stk.rotaxane.NRotaxane(
+                    axle=stk.BuildingBlock.init_from_molecule(axle),
+                    cycles=(
+                        stk.BuildingBlock.init_from_molecule(cycle),
+                    ),
+                    repeating_unit='A',
+                    num_repeating_units=3,
                 ),
-                repeating_unit='A',
-                num_repeating_units=3,
-            ),
-        )
+            )
 
-    .. moldoc::
+        .. moldoc::
 
-        import moldoc.molecule as molecule
-        import stk
+            import moldoc.molecule as molecule
+            import stk
 
-        cycle = stk.ConstructedMolecule(
-            topology_graph=stk.macrocycle.Macrocycle(
-                building_blocks=(
-                    stk.BuildingBlock(
-                        smiles='[Br]CC[Br]',
-                        functional_groups=[stk.BromoFactory()],
+            cycle = stk.ConstructedMolecule(
+                topology_graph=stk.macrocycle.Macrocycle(
+                    building_blocks=(
+                        stk.BuildingBlock(
+                            smiles='[Br]CC[Br]',
+                            functional_groups=[stk.BromoFactory()],
+                        ),
                     ),
+                    repeating_unit='A',
+                    num_repeating_units=5,
                 ),
-                repeating_unit='A',
-                num_repeating_units=5,
-            ),
-        )
-        axle = stk.ConstructedMolecule(
-            topology_graph=stk.polymer.Linear(
-                building_blocks=(
-                    stk.BuildingBlock('BrCCBr', [stk.BromoFactory()]),
-                    stk.BuildingBlock('BrCNCBr', [stk.BromoFactory()]),
-                ),
-                repeating_unit='AB',
-                num_repeating_units=7,
             )
-        )
-        rotaxane = stk.ConstructedMolecule(
-            topology_graph=stk.rotaxane.NRotaxane(
-                axle=stk.BuildingBlock.init_from_molecule(axle),
-                cycles=(
-                    stk.BuildingBlock.init_from_molecule(cycle),
-                ),
-                repeating_unit='A',
-                num_repeating_units=3,
-            ),
-        )
-
-        moldoc_display_molecule = molecule.Molecule(
-            atoms=(
-                molecule.Atom(
-                    atomic_number=atom.get_atomic_number(),
-                    position=position,
-                ) for atom, position in zip(
-                    rotaxane.get_atoms(),
-                    rotaxane.get_position_matrix(),
+            axle = stk.ConstructedMolecule(
+                topology_graph=stk.polymer.Linear(
+                    building_blocks=(
+                        stk.BuildingBlock('BrCCBr', [stk.BromoFactory()]),
+                        stk.BuildingBlock('BrCNCBr', [stk.BromoFactory()]),
+                    ),
+                    repeating_unit='AB',
+                    num_repeating_units=7,
                 )
-            ),
-            bonds=(
-                molecule.Bond(
-                    atom1_id=bond.get_atom1().get_id(),
-                    atom2_id=bond.get_atom2().get_id(),
-                    order=bond.get_order(),
-                ) for bond in rotaxane.get_bonds()
-            ),
-        )
+            )
+            rotaxane = stk.ConstructedMolecule(
+                topology_graph=stk.rotaxane.NRotaxane(
+                    axle=stk.BuildingBlock.init_from_molecule(axle),
+                    cycles=(
+                        stk.BuildingBlock.init_from_molecule(cycle),
+                    ),
+                    repeating_unit='A',
+                    num_repeating_units=3,
+                ),
+            )
 
-    *Suggested Optimization*
+            moldoc_display_molecule = molecule.Molecule(
+                atoms=(
+                    molecule.Atom(
+                        atomic_number=atom.get_atomic_number(),
+                        position=position,
+                    ) for atom, position in zip(
+                        rotaxane.get_atoms(),
+                        rotaxane.get_position_matrix(),
+                    )
+                ),
+                bonds=(
+                    molecule.Bond(
+                        atom1_id=bond.get_atom1().get_id(),
+                        atom2_id=bond.get_atom2().get_id(),
+                        order=bond.get_order(),
+                    ) for bond in rotaxane.get_bonds()
+                ),
+            )
 
-    For :class:`.NRotaxane` topologies, there is no need to use an
-    optimizer, so stick with :class:`.NullOptimizer`. However, it is
-    recommended that all building blocks be optimized prior to
-    construction.
+        *Suggested Optimization*
 
-    *Defining the Orientation of Each Building Block*
+        For :class:`.NRotaxane` topologies, there is no need to use an
+        optimizer, so stick with :class:`.NullOptimizer`. However, it is
+        recommended that all building blocks be optimized prior to
+        construction.
+
+        *Defining the Orientation of Each Building Block*
+
+        The `orientations` parameter allows the direction of each cycle
+        along the axle to be flipped
+
+        .. testcode:: defining-the-orientation-of-each-building-block
+
+            import stk
+
+            cycle1 = stk.ConstructedMolecule(
+                topology_graph=stk.macrocycle.Macrocycle(
+                    building_blocks=(
+                        stk.BuildingBlock(
+                            smiles='BrCCBr',
+                            functional_groups=[stk.BromoFactory()],
+                        ),
+                        stk.BuildingBlock(
+                            smiles='BrCNCBr',
+                            functional_groups=[stk.BromoFactory()],
+                        ),
+                    ),
+                    repeating_unit='AB',
+                    num_repeating_units=5,
+                    optimizer=stk.MCHammer(),
+                ),
+            )
+            cycle2 = stk.ConstructedMolecule(
+                topology_graph=stk.macrocycle.Macrocycle(
+                    building_blocks=(
+                        stk.BuildingBlock(
+                            smiles='BrCCCBr',
+                            functional_groups=[stk.BromoFactory()],
+                        ),
+                        stk.BuildingBlock(
+                            smiles='BrCCNCBr',
+                            functional_groups=[stk.BromoFactory()],
+                        ),
+                    ),
+                    repeating_unit='AB',
+                    num_repeating_units=5,
+                    optimizer=stk.MCHammer(),
+                ),
+            )
+            axle = stk.ConstructedMolecule(
+                topology_graph=stk.polymer.Linear(
+                    building_blocks=(
+                        stk.BuildingBlock('BrCCBr', [stk.BromoFactory()]),
+                    ),
+                    repeating_unit='A',
+                    num_repeating_units=2,
+                ),
+            )
+            rotaxane1 = stk.ConstructedMolecule(
+                topology_graph=stk.rotaxane.NRotaxane(
+                    axle=stk.BuildingBlock.init_from_molecule(axle),
+                    cycles=(
+                        stk.BuildingBlock.init_from_molecule(cycle1),
+                        stk.BuildingBlock.init_from_molecule(cycle2),
+                    ),
+                    repeating_unit='AB',
+                    num_repeating_units=3,
+                    orientations=(1., 0.5),
+                ),
+            )
 
-    The `orientations` parameter allows the direction of each cycle
-    along the axle to be flipped
+        In the above example, ``cycle1`` is guaranteed to be flipped,
+        ``cycle2`` has a 50% chance of being flipped, each time it is
+        placed on a node.
 
-    .. testcode:: defining-the-orientation-of-each-building-block
+        Note that whether a building block will be flipped or not
+        is decided during the initialization of :class:`.NRotaxane`
 
-        import stk
+        .. testcode:: defining-the-orientation-of-each-building-block
 
-        cycle1 = stk.ConstructedMolecule(
-            topology_graph=stk.macrocycle.Macrocycle(
-                building_blocks=(
-                    stk.BuildingBlock(
-                        smiles='BrCCBr',
-                        functional_groups=[stk.BromoFactory()],
-                    ),
-                    stk.BuildingBlock(
-                        smiles='BrCNCBr',
-                        functional_groups=[stk.BromoFactory()],
-                    ),
-                ),
-                repeating_unit='AB',
-                num_repeating_units=5,
-                optimizer=stk.MCHammer(),
-            ),
-        )
-        cycle2 = stk.ConstructedMolecule(
-            topology_graph=stk.macrocycle.Macrocycle(
-                building_blocks=(
-                    stk.BuildingBlock(
-                        smiles='BrCCCBr',
-                        functional_groups=[stk.BromoFactory()],
-                    ),
-                    stk.BuildingBlock(
-                        smiles='BrCCNCBr',
-                        functional_groups=[stk.BromoFactory()],
-                    ),
+            # graph1 will always construct the same [n]rotaxane.
+            graph1 = stk.rotaxane.NRotaxane(
+                axle=stk.BuildingBlock.init_from_molecule(axle),
+                cycles=(
+                    stk.BuildingBlock.init_from_molecule(cycle1),
+                    stk.BuildingBlock.init_from_molecule(cycle2),
                 ),
                 repeating_unit='AB',
                 num_repeating_units=5,
-                optimizer=stk.MCHammer(),
-            ),
-        )
-        axle = stk.ConstructedMolecule(
-            topology_graph=stk.polymer.Linear(
-                building_blocks=(
-                    stk.BuildingBlock('BrCCBr', [stk.BromoFactory()]),
-                ),
-                repeating_unit='A',
-                num_repeating_units=2,
-            ),
-        )
-        rotaxane1 = stk.ConstructedMolecule(
-            topology_graph=stk.rotaxane.NRotaxane(
+                orientations=(0.65, 0.45),
+            )
+            # rotaxane2 and rotaxane3 are guaranteed to be the same as they
+            # used the same topology graph.
+            rotaxane2 = stk.ConstructedMolecule(graph1)
+            rotaxane3 = stk.ConstructedMolecule(graph1)
+
+            # graph2 may lead to a different [n]rotaxane, despite
+            # being initialized with the same parameters.
+            graph2 = stk.rotaxane.NRotaxane(
                 axle=stk.BuildingBlock.init_from_molecule(axle),
                 cycles=(
                     stk.BuildingBlock.init_from_molecule(cycle1),
                     stk.BuildingBlock.init_from_molecule(cycle2),
                 ),
                 repeating_unit='AB',
-                num_repeating_units=3,
-                orientations=(1., 0.5),
-            ),
-        )
-
-    In the above example, ``cycle1`` is guaranteed to be flipped,
-    ``cycle2`` has a 50% chance of being flipped, each time it is
-    placed on a node.
-
-    Note that whether a building block will be flipped or not
-    is decided during the initialization of :class:`.NRotaxane`
-
-    .. testcode:: defining-the-orientation-of-each-building-block
-
-        # graph1 will always construct the same [n]rotaxane.
-        graph1 = stk.rotaxane.NRotaxane(
-            axle=stk.BuildingBlock.init_from_molecule(axle),
-            cycles=(
-                stk.BuildingBlock.init_from_molecule(cycle1),
-                stk.BuildingBlock.init_from_molecule(cycle2),
-            ),
-            repeating_unit='AB',
-            num_repeating_units=5,
-            orientations=(0.65, 0.45),
-        )
-        # rotaxane2 and rotaxane3 are guaranteed to be the same as they
-        # used the same topology graph.
-        rotaxane2 = stk.ConstructedMolecule(graph1)
-        rotaxane3 = stk.ConstructedMolecule(graph1)
-
-        # graph2 may lead to a different [n]rotaxane, despite
-        # being initialized with the same parameters.
-        graph2 = stk.rotaxane.NRotaxane(
-            axle=stk.BuildingBlock.init_from_molecule(axle),
-            cycles=(
-                stk.BuildingBlock.init_from_molecule(cycle1),
-                stk.BuildingBlock.init_from_molecule(cycle2),
-            ),
-            repeating_unit='AB',
-            num_repeating_units=5,
-            orientations=(0.65, 0.45)
-        )
-
-        # rotaxane4 and rotaxane5 are guaranteed to be the same because
-        # they used the same topology graph. However, they may be
-        # different to rotaxane2 and rotaxane3.
-        rotaxane4 = stk.ConstructedMolecule(graph2)
-        rotaxane5 = stk.ConstructedMolecule(graph2)
-
-    The `random_seed` parameter can be used to get reproducible results
-
-    .. testcode:: defining-the-orientation-of-each-building-block
-
-        # rotaxane6 and rotaxane7 are guaranteed to be the same,
-        # because graph3 and graph4 used the same random seed.
-
-        graph3 = stk.rotaxane.NRotaxane(
-            axle=stk.BuildingBlock.init_from_molecule(axle),
-            cycles=(
-                stk.BuildingBlock.init_from_molecule(cycle1),
-                stk.BuildingBlock.init_from_molecule(cycle2),
-            ),
-            repeating_unit='AB',
-            num_repeating_units=5,
-            orientations=(0.65, 0.45),
-            random_seed=4,
-        )
-        rotaxane6 = stk.ConstructedMolecule(graph3)
-
-        graph4 = stk.rotaxane.NRotaxane(
-            axle=stk.BuildingBlock.init_from_molecule(axle),
-            cycles=(
-                stk.BuildingBlock.init_from_molecule(cycle1),
-                stk.BuildingBlock.init_from_molecule(cycle2),
-            ),
-            repeating_unit='AB',
-            num_repeating_units=5,
-            orientations=(0.65, 0.45),
-            random_seed=4,
-        )
-        rotaxane7 = stk.ConstructedMolecule(graph4)
+                num_repeating_units=5,
+                orientations=(0.65, 0.45)
+            )
 
-    *Using Numbers to Define the Repeating Unit*
+            # rotaxane4 and rotaxane5 are guaranteed to be the same because
+            # they used the same topology graph. However, they may be
+            # different to rotaxane2 and rotaxane3.
+            rotaxane4 = stk.ConstructedMolecule(graph2)
+            rotaxane5 = stk.ConstructedMolecule(graph2)
 
-    The repeating unit can also be specified through the indices of
-    the building blocks
+        The `random_seed` parameter can be used to get reproducible results
 
-    .. testcode:: using-numbers-to-define-the-repeating-unit
+        .. testcode:: defining-the-orientation-of-each-building-block
 
-        import stk
+            # rotaxane6 and rotaxane7 are guaranteed to be the same,
+            # because graph3 and graph4 used the same random seed.
 
-        cycle1 = stk.ConstructedMolecule(
-            topology_graph=stk.macrocycle.Macrocycle(
-                building_blocks=(
-                    stk.BuildingBlock(
-                        smiles='BrCCBr',
-                        functional_groups=[stk.BromoFactory()],
-                    ),
-                    stk.BuildingBlock(
-                        smiles='BrCNCBr',
-                        functional_groups=[stk.BromoFactory()],
-                    ),
+            graph3 = stk.rotaxane.NRotaxane(
+                axle=stk.BuildingBlock.init_from_molecule(axle),
+                cycles=(
+                    stk.BuildingBlock.init_from_molecule(cycle1),
+                    stk.BuildingBlock.init_from_molecule(cycle2),
                 ),
                 repeating_unit='AB',
                 num_repeating_units=5,
-                optimizer=stk.MCHammer(),
-            ),
-        )
-        cycle2 = stk.ConstructedMolecule(
-            topology_graph=stk.macrocycle.Macrocycle(
-                building_blocks=(
-                    stk.BuildingBlock(
-                        smiles='BrCCCBr',
-                        functional_groups=[stk.BromoFactory()],
-                    ),
-                    stk.BuildingBlock(
-                        smiles='BrCCNCBr',
-                        functional_groups=[stk.BromoFactory()],
-                    ),
+                orientations=(0.65, 0.45),
+                random_seed=4,
+            )
+            rotaxane6 = stk.ConstructedMolecule(graph3)
+
+            graph4 = stk.rotaxane.NRotaxane(
+                axle=stk.BuildingBlock.init_from_molecule(axle),
+                cycles=(
+                    stk.BuildingBlock.init_from_molecule(cycle1),
+                    stk.BuildingBlock.init_from_molecule(cycle2),
                 ),
                 repeating_unit='AB',
                 num_repeating_units=5,
-                optimizer=stk.MCHammer(),
-            ),
-        )
-        cycle3 = stk.ConstructedMolecule(
-            topology_graph=stk.macrocycle.Macrocycle(
-                building_blocks=(
-                    stk.BuildingBlock(
-                        smiles='BrCCNNCBr',
-                        functional_groups=[stk.BromoFactory()],
-                    ),
-                    stk.BuildingBlock(
-                        smiles='BrCCNNNCBr',
-                        functional_groups=[stk.BromoFactory()],
-                    ),
+                orientations=(0.65, 0.45),
+                random_seed=4,
+            )
+            rotaxane7 = stk.ConstructedMolecule(graph4)
+
+        *Using Numbers to Define the Repeating Unit*
+
+        The repeating unit can also be specified through the indices of
+        the building blocks
+
+        .. testcode:: using-numbers-to-define-the-repeating-unit
+
+            import stk
+
+            cycle1 = stk.ConstructedMolecule(
+                topology_graph=stk.macrocycle.Macrocycle(
+                    building_blocks=(
+                        stk.BuildingBlock(
+                            smiles='BrCCBr',
+                            functional_groups=[stk.BromoFactory()],
+                        ),
+                        stk.BuildingBlock(
+                            smiles='BrCNCBr',
+                            functional_groups=[stk.BromoFactory()],
+                        ),
+                    ),
+                    repeating_unit='AB',
+                    num_repeating_units=5,
+                    optimizer=stk.MCHammer(),
                 ),
-                repeating_unit='AB',
-                num_repeating_units=5,
-                optimizer=stk.MCHammer(),
-            ),
-        )
-        axle = stk.ConstructedMolecule(
-            topology_graph=stk.polymer.Linear(
-                building_blocks=(
-                    stk.BuildingBlock('BrCCBr', [stk.BromoFactory()]),
+            )
+            cycle2 = stk.ConstructedMolecule(
+                topology_graph=stk.macrocycle.Macrocycle(
+                    building_blocks=(
+                        stk.BuildingBlock(
+                            smiles='BrCCCBr',
+                            functional_groups=[stk.BromoFactory()],
+                        ),
+                        stk.BuildingBlock(
+                            smiles='BrCCNCBr',
+                            functional_groups=[stk.BromoFactory()],
+                        ),
+                    ),
+                    repeating_unit='AB',
+                    num_repeating_units=5,
+                    optimizer=stk.MCHammer(),
                 ),
-                repeating_unit='A',
-                num_repeating_units=2,
-            ),
-        )
+            )
+            cycle3 = stk.ConstructedMolecule(
+                topology_graph=stk.macrocycle.Macrocycle(
+                    building_blocks=(
+                        stk.BuildingBlock(
+                            smiles='BrCCNNCBr',
+                            functional_groups=[stk.BromoFactory()],
+                        ),
+                        stk.BuildingBlock(
+                            smiles='BrCCNNNCBr',
+                            functional_groups=[stk.BromoFactory()],
+                        ),
+                    ),
+                    repeating_unit='AB',
+                    num_repeating_units=5,
+                    optimizer=stk.MCHammer(),
+                ),
+            )
+            axle = stk.ConstructedMolecule(
+                topology_graph=stk.polymer.Linear(
+                    building_blocks=(
+                        stk.BuildingBlock('BrCCBr', [stk.BromoFactory()]),
+                    ),
+                    repeating_unit='A',
+                    num_repeating_units=2,
+                ),
+            )
 
-        # r1 and r2 are different ways to write the same thing.
-        r1 = stk.ConstructedMolecule(
-            topology_graph=stk.rotaxane.NRotaxane(
-                axle=stk.BuildingBlock.init_from_molecule(axle),
-                cycles=(
-                    stk.BuildingBlock.init_from_molecule(cycle1),
-                    stk.BuildingBlock.init_from_molecule(cycle2),
-                    stk.BuildingBlock.init_from_molecule(cycle3),
+            # r1 and r2 are different ways to write the same thing.
+            r1 = stk.ConstructedMolecule(
+                topology_graph=stk.rotaxane.NRotaxane(
+                    axle=stk.BuildingBlock.init_from_molecule(axle),
+                    cycles=(
+                        stk.BuildingBlock.init_from_molecule(cycle1),
+                        stk.BuildingBlock.init_from_molecule(cycle2),
+                        stk.BuildingBlock.init_from_molecule(cycle3),
+                    ),
+                    repeating_unit='ACB',
+                    num_repeating_units=3,
                 ),
-                repeating_unit='ACB',
-                num_repeating_units=3,
-            ),
-        )
-        r2 = stk.ConstructedMolecule(
-            topology_graph=stk.rotaxane.NRotaxane(
-                axle=stk.BuildingBlock.init_from_molecule(axle),
-                cycles=(
-                    stk.BuildingBlock.init_from_molecule(cycle1),
-                    stk.BuildingBlock.init_from_molecule(cycle2),
-                    stk.BuildingBlock.init_from_molecule(cycle3),
+            )
+            r2 = stk.ConstructedMolecule(
+                topology_graph=stk.rotaxane.NRotaxane(
+                    axle=stk.BuildingBlock.init_from_molecule(axle),
+                    cycles=(
+                        stk.BuildingBlock.init_from_molecule(cycle1),
+                        stk.BuildingBlock.init_from_molecule(cycle2),
+                        stk.BuildingBlock.init_from_molecule(cycle3),
+                    ),
+                    repeating_unit=(0, 2, 1),
+                    num_repeating_units=3,
                 ),
-                repeating_unit=(0, 2, 1),
-                num_repeating_units=3,
-            ),
-        )
+            )
 
     """
 
     def __init__(
         self,
-        axle,
-        cycles,
-        repeating_unit,
-        num_repeating_units,
-        orientations=None,
-        random_seed=None,
-        num_processes=1,
-        optimizer=NullOptimizer(),
-    ):
+        axle: BuildingBlock,
+        cycles: Iterable[BuildingBlock],
+        repeating_unit: str | Iterable[int],
+        num_repeating_units: int,
+        orientations: Iterable[float] | None = None,
+        random_seed: int | np.random.Generator | None = None,
+        num_processes: int = 1,
+        optimizer: Optimizer = NullOptimizer(),
+    ) -> None:
         """
-        Initialize a :class:`NRotaxane` instance.
+        Parameters:
+
+            axle:
+                The axle of the rotaxane.
 
-        Parameters
-        ----------
-        axle : :class:`.BuildingBlock`
-            The axle of the rotaxane.
-
-        cycles : :class:`tuple` of :class:`.BuildingBlock`
-            The cycles threaded onto the `axle`.
-
-        repeating_unit : :class:`str` or :class:`tuple` of :class:`int`
-            A string specifying the repeating unit of the `cycles`.
-            For example, ``'AB'`` or ``'ABB'``. The first cycle in
-            `cycles` is ``'A'`` and so on.
-
-            The repeating unit can also be specified by the indices of
-            `cycles`, for example ``'ABB'`` can be
-            written as ``(0, 1, 1)``.
-
-        num_repeating_units : :class:`int`
-            The number of repeating units threaded along the axle.
-
-        orientations : :class:`tuple` of :class:`float`, optional
-            For each character in the repeating unit, a value
-            between ``0`` and ``1`` (both inclusive) must be given in
-            a :class:`tuple`. It indicates the probability that each
-            cycle will have its orientation along the axle
-            flipped. If ``0`` then the cycle is guaranteed not to
-            flip. If ``1`` it is guaranteed to flip. This allows the
-            user to create head-to-head or head-to-tail chains, as well
-            as chain with a preference for head-to-head or head-to-tail
-            if a number between ``0`` and ``1`` is chosen. If
-            ``None``, then defaults to ``0`` in every case.
-
-            It is also possible to supply an orientation for every
-            cycle vertex in the final topology graph. In this case, the
-            length of `orientations` must be equal to
-            ``len(repeating_unit)*num_repeating_units``.
-
-        random_seed : :class:`int`, optional
-            The random seed to use when choosing random orientations.
-
-        num_processes : :class:`int`, optional
-            The number of parallel processes to create during
-            :meth:`construct`.
-
-        optimizer : :class:`.Optimizer`, optional
-            Used to optimize the structure of the constructed
-            molecule.
-
-        Raises
-        ------
-        :class:`ValueError`
-            If the length of `orientations` is not equal in length to
-            `repeating_unit` or to the total number of vertices.
+            cycles (list[BuildingBlock]):
+                The cycles threaded onto the `axle`.
+
+            repeating_unit (str | list[int]):
+                A string specifying the repeating unit of the `cycles`.
+                For example, ``'AB'`` or ``'ABB'``. The first cycle in
+                `cycles` is ``'A'`` and so on.
+
+                The repeating unit can also be specified by the indices of
+                `cycles`, for example ``'ABB'`` can be
+                written as ``[0, 1, 1]``.
+
+            num_repeating_units:
+                The number of repeating units threaded along the axle.
+
+            orientations (list[float] | None):
+                For each character in the repeating unit, a value
+                between ``0`` and ``1`` (both inclusive) must be given in
+                a :class:`tuple`. It indicates the probability that each
+                cycle will have its orientation along the axle
+                flipped. If ``0`` then the cycle is guaranteed not to
+                flip. If ``1`` it is guaranteed to flip. This allows the
+                user to create head-to-head or head-to-tail chains, as well
+                as chain with a preference for head-to-head or head-to-tail
+                if a number between ``0`` and ``1`` is chosen. If
+                ``None``, then defaults to ``0`` in every case.
+
+                It is also possible to supply an orientation for every
+                cycle vertex in the final topology graph. In this case, the
+                length of `orientations` must be equal to
+                ``len(repeating_unit)*num_repeating_units``.
+
+            random_seed:
+                The random seed to use when choosing random orientations.
+
+            num_processes:
+                The number of parallel processes to create during
+                :meth:`construct`.
+
+            optimizer:
+                Used to optimize the structure of the constructed
+                molecule.
+
+        Raises:
+
+            :class:`ValueError`
+                If the length of `orientations` is not equal in length to
+                `repeating_unit` or to the total number of vertices.
 
         """
 
+        if not isinstance(repeating_unit, str):
+            repeating_unit = tuple(repeating_unit)
+
         if orientations is None:
-            orientations = tuple(
-                0. for i in range(len(repeating_unit))
-            )
+            orientations = tuple(0.0 for _ in range(len(repeating_unit)))
+        else:
+            orientations = tuple(orientations)
 
         if len(orientations) == len(repeating_unit):
-            orientations = orientations*num_repeating_units
+            orientations = orientations * num_repeating_units
 
-        chain_length = len(repeating_unit)*num_repeating_units
+        chain_length = len(repeating_unit) * num_repeating_units
         if len(orientations) != chain_length:
             raise ValueError(
-                'The length of orientations must match either '
-                'the length of repeating_unit or the '
-                'total number of vertices.'
+                "The length of orientations must match either "
+                "the length of repeating_unit or the "
+                "total number of vertices."
             )
 
-        generator = np.random.RandomState(random_seed)
+        if random_seed is None or isinstance(random_seed, int):
+            random_seed = np.random.default_rng(random_seed)
 
         self._repeating_unit = self._normalize_repeating_unit(
             repeating_unit=repeating_unit,
         )
         self._num_repeating_units = num_repeating_units
 
-        vertices = [AxleVertex(0, [0, 0, 0])]
-        distance = 1 / (chain_length+1)
+        vertices: list[AxleVertex | CycleVertex] = [AxleVertex(0, (0, 0, 0))]
+        distance = 1 / (chain_length + 1)
         choices = [True, False]
         for vertex_id, flip_chance in enumerate(orientations, 1):
             vertices.append(
                 CycleVertex(
                     id=vertex_id,
-                    position=[vertex_id*distance-0.5, 0, 0],
-                    flip=generator.choice(
+                    position=[vertex_id * distance - 0.5, 0, 0],
+                    flip=random_seed.choice(
                         choices,
-                        p=[flip_chance, 1-flip_chance],
-                    )
+                        p=[flip_chance, 1 - flip_chance],
+                    ),
                 )
             )
 
         # Save the chosen orientations for __repr__.
         self._orientations = tuple(
-            int(vertex.get_flip()) for vertex in vertices[1:]
+            int(vertex.get_flip()) for vertex in vertices[1:]  # type:ignore
         )
 
         super().__init__(
             building_block_vertices=self._get_building_block_vertices(
                 axle=axle,
-                cycles=cycles,
+                cycles=tuple(cycles),
                 vertices=vertices,
             ),
             edges=(),
-            reaction_factory=None,
+            reaction_factory=GenericReactionFactory(),
             construction_stages=(),
             num_processes=num_processes,
             optimizer=optimizer,
             edge_groups=None,
         )
 
     def clone(self):
@@ -501,37 +508,35 @@
         clone._orientations = self._orientations
         return clone
 
     @staticmethod
     def _normalize_repeating_unit(repeating_unit):
         if isinstance(repeating_unit, tuple):
             return repeating_unit
-        base = ord('A')
-        return tuple(ord(letter)-base for letter in repeating_unit)
+        base = ord("A")
+        return tuple(ord(letter) - base for letter in repeating_unit)
 
     def _get_building_block_vertices(self, axle, cycles, vertices):
-        threads = self._repeating_unit*self._num_repeating_units
+        threads = self._repeating_unit * self._num_repeating_units
         building_block_vertices = {}
         building_block_vertices[axle] = vertices[0:1]
         for cycle_index, vertex in zip(threads, vertices[1:]):
             bb = cycles[cycle_index]
-            building_block_vertices[bb] = (
-                building_block_vertices.get(bb, [])
-            )
+            building_block_vertices[bb] = building_block_vertices.get(bb, [])
             building_block_vertices[bb].append(vertex)
         return building_block_vertices
 
     def _run_reactions(self, state):
         return state
 
     def _get_scale(self, building_block_vertices):
         axle = next(iter(building_block_vertices))
-        return 0.8*axle.get_maximum_diameter()
+        return 0.8 * axle.get_maximum_diameter()
 
     def __repr__(self):
         return (
-            f'rotaxane.NRotaxane('
-            f'{self._repeating_unit!r}, '
-            f'{self._num_repeating_units}, '
-            f'{self._orientations!r}'
-            f')'
+            f"rotaxane.NRotaxane("
+            f"{self._repeating_unit!r}, "
+            f"{self._num_repeating_units}, "
+            f"{self._orientations!r}"
+            f")"
         )
```

### Comparing `stk-2022.6.17.0/src/stk/molecular/topology_graphs/rotaxane/vertices.py` & `stk-2023.7.5.0/src/stk/_internal/topology_graphs/rotaxane/vertices.py`

 * *Files 16% similar despite different names*

```diff
@@ -1,16 +1,10 @@
-"""
-Rotaxane Vertices
-=================
-
-"""
-
 import rdkit.Chem.AllChem as rdkit
 
-from ..topology_graph import Vertex
+from stk._internal.topology_graphs.vertex import Vertex
 
 
 class AxleVertex(Vertex):
     def place_building_block(self, building_block, edges):
         return building_block.with_centroid(
             position=self._position,
             atom_ids=building_block.get_placer_ids(),
@@ -64,25 +58,29 @@
         clone = super().clone()
         clone._flip = self._flip
         return clone
 
     def place_building_block(self, building_block, edges):
         rdkit_mol = building_block.to_rdkit_mol()
         macrocycle = max(rdkit.GetSymmSSSR(rdkit_mol), key=len)
-        return building_block.with_centroid(
-            position=self._position,
-            atom_ids=macrocycle,
-        ).with_rotation_between_vectors(
-            start=building_block.get_plane_normal(macrocycle),
-            target=[-1 if self._flip else 1, 0, 0],
-            origin=self._position
-        ).get_position_matrix()
+        return (
+            building_block.with_centroid(
+                position=self._position,
+                atom_ids=macrocycle,
+            )
+            .with_rotation_between_vectors(
+                start=building_block.get_plane_normal(macrocycle),
+                target=[-1 if self._flip else 1, 0, 0],
+                origin=self._position,
+            )
+            .get_position_matrix()
+        )
 
     def map_functional_groups_to_edges(self, building_block, edges):
         return {}
 
     def __str__(self):
         return (
-            f'Vertex(id={self._id}, '
-            f'position={self._position.tolist()}, '
-            f'flip={self._flip})'
+            f"Vertex(id={self._id}, "
+            f"position={self._position.tolist()}, "
+            f"flip={self._flip})"
         )
```

### Comparing `stk-2022.6.17.0/src/stk/molecular/topology_graphs/topology_graph/construction_result/construction_result.py` & `stk-2023.7.5.0/src/stk/_internal/construction_result/construction_result.py`

 * *Files 1% similar despite different names*

```diff
@@ -8,47 +8,44 @@
 class ConstructionResult:
     """
     The result of :meth:`.TopologyGraph.construct`.
 
     """
 
     __slots__ = [
-        '_atoms',
-        '_bonds',
-        '_atom_infos',
-        '_bond_infos',
-        '_position_matrix',
-        '_num_building_blocks',
+        "_atoms",
+        "_bonds",
+        "_atom_infos",
+        "_bond_infos",
+        "_position_matrix",
+        "_num_building_blocks",
     ]
 
     def __init__(self, construction_state):
         """
         Initialize a :class:`.ConstructionResult`.
 
         Parameters
         ----------
         construction_state : :class:`.ConstructionState`
             The state from which the result is initialized.
 
         """
 
-        self._position_matrix = (
-            construction_state.get_position_matrix()
-        )
+        self._position_matrix = construction_state.get_position_matrix()
         self._position_matrix.setflags(write=False)
         self._atoms = tuple(construction_state.get_atoms())
         self._bonds = tuple(construction_state.get_bonds())
         self._atom_infos = tuple(construction_state.get_atom_infos())
         self._bond_infos = tuple(construction_state.get_bond_infos())
         self._num_building_blocks = {
             building_block: construction_state.get_num_building_block(
                 building_block=building_block,
             )
-            for building_block
-            in construction_state.get_building_blocks()
+            for building_block in construction_state.get_building_blocks()
         }
 
     def get_position_matrix(self):
         """
         Get the position matrix of the constructed molecule.
 
         Returns
```

### Comparing `stk-2022.6.17.0/src/stk/molecular/topology_graphs/topology_graph/construction_result/periodic.py` & `stk-2023.7.5.0/src/stk/_internal/construction_result/periodic.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,25 +1,26 @@
 """
 Periodic Construction Result
 ============================
 
 """
 
-from ....periodic_info import PeriodicInfo
+from stk._internal.periodic_info import PeriodicInfo
+
 from .construction_result import ConstructionResult
 
 
 class PeriodicConstructionResult(ConstructionResult):
     """
     The result of :meth:`.TopologyGraph.construct` with periodic info.
 
     """
 
     __slots__ = [
-        '_periodic_info',
+        "_periodic_info",
     ]
 
     def __init__(
         self,
         construction_state,
         lattice_size,
     ):
@@ -35,15 +36,15 @@
             The size of the lattice in the x, y and z directions.
 
         """
 
         super().__init__(construction_state)
         self._periodic_info = PeriodicInfo(
             *(
-                lattice_constant*dim
+                lattice_constant * dim
                 for lattice_constant, dim in zip(
                     construction_state.get_lattice_constants(),
                     lattice_size,
                 )
             )
         )
```

### Comparing `stk-2022.6.17.0/src/stk/molecular/topology_graphs/topology_graph/construction_state/construction_state.py` & `stk-2023.7.5.0/src/stk/_internal/construction_state/construction_state.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,15 +1,15 @@
 """
 Construction State
 ==================
 
 """
 
-from .graph_state import _GraphState
-from .molecule_state import _MoleculeState
+from .graph_state import GraphState
+from .molecule_state import MoleculeState
 
 
 class ConstructionState:
     """
     The state of the molecule and topology graph under construction.
 
     """
@@ -36,20 +36,20 @@
         lattice_constants : :class:`tuple`, optional
             A :class:`numpy.ndarray` for each lattice constant.
             Can be an empty :class:`tuple` if the topology graph is
             not periodic.
 
         """
 
-        self._graph_state = _GraphState(
+        self._graph_state = GraphState(
             building_block_vertices=building_block_vertices,
             edges=edges,
             lattice_constants=lattice_constants,
         )
-        self._molecule_state = _MoleculeState()
+        self._molecule_state = MoleculeState()
 
     def clone(self):
         """
         Return a clone.
 
         Returns
         -------
@@ -71,21 +71,19 @@
         results,
     ):
         """
         Modify the instance.
 
         """
 
-        self._molecule_state = (
-            self._molecule_state.with_placement_results(
-                vertices=vertices,
-                edges=edges,
-                building_blocks=building_blocks,
-                results=results,
-            )
+        self._molecule_state = self._molecule_state.with_placement_results(
+            vertices=vertices,
+            edges=edges,
+            building_blocks=building_blocks,
+            results=results,
         )
         return self
 
     def with_placement_results(
         self,
         vertices,
         edges,
@@ -264,19 +262,17 @@
 
     def _with_reaction_results(self, reactions, results):
         """
         Modify the instance.
 
         """
 
-        self._molecule_state = (
-            self._molecule_state.with_reaction_results(
-                reactions=reactions,
-                results=results,
-            )
+        self._molecule_state = self._molecule_state.with_reaction_results(
+            reactions=reactions,
+            results=results,
         )
         return self
 
     def with_reaction_results(self, reactions, results):
         """
         Return a clone holding the reaction results.
 
@@ -300,18 +296,16 @@
 
     def _with_lattice_constants(self, lattice_constants):
         """
         Modify the instance.
 
         """
 
-        self._graph_state = (
-            self._graph_state.with_lattice_constants(
-                lattice_constants=lattice_constants,
-            )
+        self._graph_state = self._graph_state.with_lattice_constants(
+            lattice_constants=lattice_constants,
         )
         return self
 
     def with_lattice_constants(self, lattice_constants):
         """
         Return a clone holding the `lattice_constants`.
 
@@ -333,18 +327,16 @@
 
     def _with_position_matrix(self, position_matrix):
         """
         Modify the instance.
 
         """
 
-        self._molecule_state = (
-            self._molecule_state.with_position_matrix(
-                position_matrix=position_matrix,
-            )
+        self._molecule_state = self._molecule_state.with_position_matrix(
+            position_matrix=position_matrix,
         )
         return self
 
     def with_position_matrix(self, position_matrix):
         """
         Return a clone holding the `position_matrix`.
```

### Comparing `stk-2022.6.17.0/src/stk/molecular/topology_graphs/topology_graph/construction_state/graph_state.py` & `stk-2023.7.5.0/src/stk/_internal/construction_state/graph_state.py`

 * *Files 2% similar despite different names*

```diff
@@ -5,27 +5,27 @@
 """
 
 from collections import defaultdict
 
 import numpy as np
 
 
-class _GraphState:
+class GraphState:
     """
     The topology graph of a molecule under construction.
 
     """
 
     __slots__ = [
-        '_vertex_building_blocks',
-        '_vertices',
-        '_edges',
-        '_lattice_constants',
-        '_vertex_edges',
-        '_num_building_blocks',
+        "_vertex_building_blocks",
+        "_vertices",
+        "_edges",
+        "_lattice_constants",
+        "_vertex_edges",
+        "_num_building_blocks",
     ]
 
     def __init__(
         self,
         building_block_vertices,
         edges,
         lattice_constants,
@@ -48,33 +48,33 @@
             Can be an empty :class:`tuple` if the topology graph is
             not periodic.
 
         """
 
         self._vertex_building_blocks = {
             vertex.get_id(): building_block
-            for building_block, vertices
-            in building_block_vertices.items()
+            for building_block, vertices in building_block_vertices.items()
             for vertex in vertices
         }
         self._num_building_blocks = {
             building_block: len(vertices)
-            for building_block, vertices
-            in building_block_vertices.items()
+            for building_block, vertices in building_block_vertices.items()
         }
         self._vertices = {
             vertex.get_id(): vertex
             for vertices in building_block_vertices.values()
             for vertex in vertices
         }
         self._edges = edges
-        self._lattice_constants = tuple(map(
-            np.array,
-            lattice_constants,
-        ))
+        self._lattice_constants = tuple(
+            map(
+                np.array,
+                lattice_constants,
+            )
+        )
         self._vertex_edges = self._get_vertex_edges()
 
     def _get_vertex_edges(self):
         """
         Get the edges connected to each vertex.
 
         Returns
@@ -131,51 +131,51 @@
 
         vertex1 = self._vertices[reference]
         id1, id2 = edge.get_vertex_ids()
         vertex2 = self._vertices[id1 if reference == id2 else id2]
 
         direction = 1 if reference == id1 else -1
         periodicity = np.array(edge.get_periodicity())
-        end_cell = vertex1.get_cell() + direction*periodicity
+        end_cell = vertex1.get_cell() + direction * periodicity
         cell_shift = end_cell - vertex2.get_cell()
 
         shift = sum(
-            axis_shift*constant
+            axis_shift * constant
             for axis_shift, constant in zip(
                 cell_shift,
                 self._lattice_constants,
             )
         )
         position = (
-            (vertex2.get_position()+shift+vertex1.get_position()) / 2
-        )
+            vertex2.get_position() + shift + vertex1.get_position()
+        ) / 2
         return edge.with_position(position)
 
     def clone(self):
         """
         Get a clone.
 
         Returns
         -------
         :class:`._GraphState`
             The clone. Has the same type as the original instance.
 
         """
 
         clone = self.__class__.__new__(self.__class__)
-        clone._vertex_building_blocks = dict(
-            self._vertex_building_blocks
-        )
+        clone._vertex_building_blocks = dict(self._vertex_building_blocks)
         clone._vertices = dict(self._vertices)
         clone._vertex_edges = dict(self._vertex_edges)
         clone._edges = self._edges
-        clone._lattice_constants = tuple(map(
-            np.array,
-            self._lattice_constants,
-        ))
+        clone._lattice_constants = tuple(
+            map(
+                np.array,
+                self._lattice_constants,
+            )
+        )
         clone._num_building_blocks = dict(self._num_building_blocks)
         return clone
 
     def get_building_block(self, vertex_id):
         """
         Get the building block to be placed on a given vertex.
 
@@ -211,15 +211,15 @@
             A vertex.
 
         """
 
         if vertex_ids is None:
             vertex_ids = range(len(self._vertices))
         elif isinstance(vertex_ids, int):
-            vertex_ids = (vertex_ids, )
+            vertex_ids = (vertex_ids,)
 
         for vertex_id in vertex_ids:
             yield self._vertices[vertex_id]
 
     def get_num_vertices(self):
         """
         Get the number of vertices in the topology graph.
@@ -297,17 +297,15 @@
 
     def _with_vertices(self, vertices):
         """
         Modify the instance.
 
         """
 
-        self._vertices = {
-            vertex.get_id(): vertex for vertex in vertices
-        }
+        self._vertices = {vertex.get_id(): vertex for vertex in vertices}
         return self
 
     def with_vertices(self, vertices):
         """
         Returns a clone holding `vertices`.
 
         Parameters
@@ -326,18 +324,20 @@
 
     def _with_lattice_constants(self, lattice_constants):
         """
         Modify the instance.
 
         """
 
-        self._lattice_constants = tuple(map(
-            np.array,
-            lattice_constants,
-        ))
+        self._lattice_constants = tuple(
+            map(
+                np.array,
+                lattice_constants,
+            )
+        )
         return self
 
     def with_lattice_constants(self, lattice_constants):
         """
         Return a clone holding the `lattice_constants`.
 
         Parameters
@@ -390,12 +390,12 @@
         ------
         :class:`.BuildingBlock`
             A building block of the topology graph.
 
         """
 
         yielded = set()
-        for vertex_id in range(max(self._vertex_building_blocks)+1):
+        for vertex_id in range(max(self._vertex_building_blocks) + 1):
             building_block = self._vertex_building_blocks[vertex_id]
             if building_block not in yielded:
                 yielded.add(building_block)
                 yield building_block
```

### Comparing `stk-2022.6.17.0/src/stk/molecular/topology_graphs/topology_graph/construction_state/molecule_state/deletions_summary.py` & `stk-2023.7.5.0/src/stk/_internal/construction_state/molecule_state/deletions_summary.py`

 * *Files 2% similar despite different names*

```diff
@@ -2,38 +2,37 @@
 Deletions Summary
 =================
 
 """
 
 import numpy as np
 
-from .....atoms import AtomInfo
-from .....bonds import BondInfo
+from stk._internal.atom_info import AtomInfo
+from stk._internal.bond_info import BondInfo
 
 
 class _DeletionsSummary:
     """
     A summary of deletion results.
 
     """
 
     __slots__ = [
-        '_atoms',
-        '_atom_infos',
-        '_bonds',
-        '_bond_infos',
-        '_position_matrix',
-        '_deleted_atom_ids',
-        '_deleted_bond_ids',
-
-        '_valid_atoms',
-        '_valid_atom_infos',
-        '_valid_bonds',
-        '_valid_bond_infos',
-        '_valid_positions',
+        "_atoms",
+        "_atom_infos",
+        "_bonds",
+        "_bond_infos",
+        "_position_matrix",
+        "_deleted_atom_ids",
+        "_deleted_bond_ids",
+        "_valid_atoms",
+        "_valid_atom_infos",
+        "_valid_bonds",
+        "_valid_bond_infos",
+        "_valid_positions",
     ]
 
     def __init__(
         self,
         atoms,
         atom_infos,
         bonds,
```

### Comparing `stk-2022.6.17.0/src/stk/molecular/topology_graphs/topology_graph/construction_state/molecule_state/molecule_state.py` & `stk-2023.7.5.0/src/stk/_internal/construction_state/molecule_state/molecule_state.py`

 * *Files 2% similar despite different names*

```diff
@@ -7,28 +7,28 @@
 import numpy as np
 
 from .deletions_summary import _DeletionsSummary
 from .placements_summary import _PlacementsSummary
 from .reactions_summary import _ReactionsSummary
 
 
-class _MoleculeState:
+class MoleculeState:
     """
     Represents the state of a molecule under construction.
 
     """
 
     __slots__ = [
-        '_position_matrix',
-        '_atoms',
-        '_atom_infos',
-        '_bonds',
-        '_bond_infos',
-        '_edge_functional_groups',
-        '_num_placements',
+        "_position_matrix",
+        "_atoms",
+        "_atom_infos",
+        "_bonds",
+        "_bond_infos",
+        "_edge_functional_groups",
+        "_num_placements",
     ]
 
     def __init__(self):
         """
         Initialize a :class:`._MoleculeState` instance.
 
         """
@@ -55,18 +55,19 @@
         clone = self.__class__.__new__(self.__class__)
         clone._position_matrix = np.array(self._position_matrix)
         clone._atoms = list(self._atoms)
         clone._atom_infos = list(self._atom_infos)
         clone._bonds = list(self._bonds)
         clone._bond_infos = list(self._bond_infos)
         clone._num_placements = self._num_placements
+
+        edge_functional_groups = self._edge_functional_groups.items()
         clone._edge_functional_groups = {
             edge_id: list(functional_groups)
-            for edge_id, functional_groups
-            in self._edge_functional_groups.items()
+            for edge_id, functional_groups in edge_functional_groups
         }
         return clone
 
     def _with_placement_results(
         self,
         vertices,
         edges,
@@ -85,27 +86,28 @@
             num_previous_placements=self._num_placements,
         )
         self._num_placements += len(vertices)
         self._atoms.extend(summary.get_atoms())
         self._atom_infos.extend(summary.get_atom_infos())
         self._bonds.extend(summary.get_bonds())
         self._bond_infos.extend(summary.get_bond_infos())
-        self._position_matrix = np.concatenate([
-            self._position_matrix,
-            summary.get_position_matrix(),
-        ])
-        for edge_id, functional_groups in (
-            summary.get_edge_functional_groups()
-        ):
-            self._edge_functional_groups[edge_id] = (
-                self._edge_functional_groups.get(edge_id, [])
-            )
-            self._edge_functional_groups[edge_id].extend(
-                functional_groups
-            )
+        self._position_matrix = np.concatenate(
+            [
+                self._position_matrix,
+                summary.get_position_matrix(),
+            ]
+        )
+        for (
+            edge_id,
+            functional_groups,
+        ) in summary.get_edge_functional_groups():
+            self._edge_functional_groups[
+                edge_id
+            ] = self._edge_functional_groups.get(edge_id, [])
+            self._edge_functional_groups[edge_id].extend(functional_groups)
         return self
 
     def with_placement_results(
         self,
         vertices,
         edges,
         building_blocks,
@@ -288,23 +290,25 @@
         """
 
         reactions_summary = _ReactionsSummary(
             num_atoms=len(self._atoms),
             reaction_results=results,
         )
         self._with_reactions_summary(reactions_summary)
-        self._with_deletions_summary(_DeletionsSummary(
-            atoms=self._atoms,
-            atom_infos=self._atom_infos,
-            bonds=self._bonds,
-            bond_infos=self._bond_infos,
-            position_matrix=self._position_matrix,
-            deleted_atom_ids=reactions_summary.get_deleted_atom_ids(),
-            deleted_bond_ids=reactions_summary.get_deleted_bond_ids(),
-        ))
+        self._with_deletions_summary(
+            _DeletionsSummary(
+                atoms=self._atoms,
+                atom_infos=self._atom_infos,
+                bonds=self._bonds,
+                bond_infos=self._bond_infos,
+                position_matrix=self._position_matrix,
+                deleted_atom_ids=reactions_summary.get_deleted_atom_ids(),
+                deleted_bond_ids=reactions_summary.get_deleted_bond_ids(),
+            )
+        )
         return self
 
     def _with_reactions_summary(self, summary):
         """
         Add the results held in `summary`.
 
         Parameters
@@ -321,18 +325,20 @@
         self._atoms.extend(summary.get_atoms())
         self._atom_infos.extend(summary.get_atom_infos())
         self._bonds.extend(summary.get_bonds())
         self._bond_infos.extend(summary.get_bond_infos())
 
         positions = tuple(summary.get_positions())
         if positions:
-            self._position_matrix = np.vstack([
-                self._position_matrix,
-                positions,
-            ])
+            self._position_matrix = np.vstack(
+                [
+                    self._position_matrix,
+                    positions,
+                ]
+            )
 
     def _with_deletions_summary(self, summary):
         """
         Add the results held in `summary`.
 
         Parameters
         ----------
```

### Comparing `stk-2022.6.17.0/src/stk/molecular/topology_graphs/topology_graph/construction_state/molecule_state/placements_summary/atom_batch.py` & `stk-2023.7.5.0/src/stk/_internal/construction_state/molecule_state/placements_summary/atom_batch.py`

 * *Files 26% similar despite different names*

```diff
@@ -4,25 +4,26 @@
 
 """
 
 from __future__ import annotations
 
 from typing import Iterable
 
-from ......atoms import Atom, AtomInfo
-from ......molecules import BuildingBlock
+from stk._internal.atom import Atom
+from stk._internal.atom_info import AtomInfo
+from stk._internal.building_block import BuildingBlock
 
 
 class _AtomBatch:
     """
     A batch of atoms.
 
     """
 
-    __slots__ = ['_atoms', '_atom_infos', '_id_map']
+    __slots__ = ["_atoms", "_atom_infos", "_id_map"]
 
     _atoms: tuple[Atom, ...]
     _atom_infos: tuple[AtomInfo, ...]
     _id_map: dict[int, int]
 
     def __init__(
         self,
```

### Comparing `stk-2022.6.17.0/src/stk/molecular/topology_graphs/topology_graph/construction_state/molecule_state/placements_summary/bond_batch.py` & `stk-2023.7.5.0/src/stk/_internal/construction_state/molecule_state/placements_summary/bond_batch.py`

 * *Files 8% similar despite different names*

```diff
@@ -4,25 +4,26 @@
 
 """
 
 from __future__ import annotations
 
 from typing import Iterable
 
-from ......bonds import Bond, BondInfo
-from ......molecules import BuildingBlock
+from stk._internal.bond import Bond
+from stk._internal.bond_info import BondInfo
+from stk._internal.building_block import BuildingBlock
 
 
 class _BondBatch:
     """
     A batch of bonds.
 
     """
 
-    __slots__ = ['_bonds', '_bond_infos']
+    __slots__ = ["_bonds", "_bond_infos"]
 
     _bonds: list[Bond]
     _bond_infos: list[BondInfo]
 
     def __init__(
         self,
         bonds: Iterable[Bond],
```

### Comparing `stk-2022.6.17.0/src/stk/molecular/topology_graphs/topology_graph/construction_state/molecule_state/placements_summary/placements_summary.py` & `stk-2023.7.5.0/src/stk/_internal/construction_state/molecule_state/placements_summary/placements_summary.py`

 * *Files 12% similar despite different names*

```diff
@@ -1,60 +1,61 @@
 """
 Placements Summary
 ==================
 
 """
 
-from __future__ import annotations
-
 from collections import defaultdict
-from typing import Iterable
+from typing import TYPE_CHECKING, Iterable
 
 import numpy as np
 
-import stk
+from stk._internal.atom import Atom
+from stk._internal.atom_info import AtomInfo
+from stk._internal.bond import Bond
+from stk._internal.bond_info import BondInfo
+from stk._internal.functional_groups.functional_group import FunctionalGroup
+from stk._internal.topology_graphs.topology_graph.utilities import (
+    _PlacementResult,
+)
 
-from ......atoms import Atom, AtomInfo
-from ......bonds import Bond, BondInfo
-from ......functional_groups import FunctionalGroup
-from ......molecules import BuildingBlock
 from .atom_batch import _AtomBatch
 from .bond_batch import _BondBatch
 
+if TYPE_CHECKING:
+    from stk._internal.building_block import BuildingBlock
+
 
 class _PlacementsSummary:
     """
     A summary of placement results.
 
     """
 
     __slots__ = [
-        '_atoms',
-        '_atom_infos',
-        '_bonds',
-        '_bond_infos',
-        '_edge_functional_groups',
-        '_position_matrices',
-        '_num_atoms',
+        "_atoms",
+        "_atom_infos",
+        "_bonds",
+        "_bond_infos",
+        "_edge_functional_groups",
+        "_position_matrices",
+        "_num_atoms",
     ]
 
     _atoms: list[Atom]
     _atom_infos: list[AtomInfo]
     _bonds: list[Bond]
     _bond_infos: list[BondInfo]
     _edge_functional_groups: defaultdict[int, list[FunctionalGroup]]
     _position_matrices: list[np.ndarray]
 
     def __init__(
         self,
-        building_blocks: Iterable[BuildingBlock],
-        placement_results: Iterable[
-            stk.molecular.topology_graphs.topology_graph
-            .topology_graph.implementations._PlacementResult
-        ],
+        building_blocks: Iterable["BuildingBlock"],
+        placement_results: Iterable[_PlacementResult],
         num_atoms: int,
         num_previous_placements: int,
     ) -> None:
         """
         Initialize a :class:`._PlacementsSummary` instance.
 
         Parameters:
@@ -90,20 +91,17 @@
             num_previous_placements,
         ):
             self._with_placement_result(building_block, id_, result)
             self._num_atoms += building_block.get_num_atoms()
 
     def _with_placement_result(
         self,
-        building_block: BuildingBlock,
+        building_block: "BuildingBlock",
         building_block_id: int,
-        result: (
-            stk.molecular.topology_graphs.topology_graph
-            .topology_graph.implementations._PlacementResult
-        )
+        result: _PlacementResult,
     ) -> None:
         """
         Add the placement result to the summary.
 
         Parameters:
 
             building_block:
@@ -176,15 +174,15 @@
         """
 
         self._bonds.extend(batch.get_bonds())
         self._bond_infos.extend(batch.get_bond_infos())
 
     def _with_functional_group_edges(
         self,
-        building_block: BuildingBlock,
+        building_block: "BuildingBlock",
         functional_group_edges: dict[int, int],
         id_map: dict[int, int],
     ):
         """
         Add the mapping from functional groups to edges.
 
         Parameters:
```

### Comparing `stk-2022.6.17.0/src/stk/molecular/topology_graphs/topology_graph/construction_state/molecule_state/reactions_summary/atom_batch.py` & `stk-2023.7.5.0/src/stk/_internal/construction_state/molecule_state/reactions_summary/atom_batch.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,23 +1,23 @@
 """
 Atom Batch
 ==========
 
 """
 
-from ......atoms import AtomInfo
+from stk._internal.atom_info import AtomInfo
 
 
 class _AtomBatch:
     """
     A batch of atoms.
 
     """
 
-    __slots__ = ['_atoms', '_atom_infos', '_atom_map', '_positions']
+    __slots__ = ["_atoms", "_atom_infos", "_atom_map", "_positions"]
 
     def __init__(self, atoms, num_atoms):
         """
         Initialize an :class:`._AtomBatch` instance.
 
         Parameters
         ----------
@@ -34,20 +34,22 @@
         self._positions = positions = []
         self._atom_infos = atom_infos = []
         self._atom_map = atom_map = {}
 
         for id_, (atom, position) in enumerate(atoms, num_atoms):
             _atoms.append(atom.with_id(id_))
             atom_map[atom.get_id()] = _atoms[-1]
-            atom_infos.append(AtomInfo(
-                atom=_atoms[-1],
-                building_block_atom=None,
-                building_block=None,
-                building_block_id=None,
-            ))
+            atom_infos.append(
+                AtomInfo(
+                    atom=_atoms[-1],
+                    building_block_atom=None,
+                    building_block=None,
+                    building_block_id=None,
+                )
+            )
             positions.append(position)
 
     def get_positions(self):
         """
         Yield the positions of atoms in the batch.
 
         Yields
```

### Comparing `stk-2022.6.17.0/src/stk/molecular/topology_graphs/topology_graph/construction_state/molecule_state/reactions_summary/bond_batch.py` & `stk-2023.7.5.0/src/stk/_internal/construction_state/molecule_state/reactions_summary/bond_batch.py`

 * *Files 9% similar despite different names*

```diff
@@ -1,24 +1,24 @@
 """
 Bond Batch
 ==========
 
 
 """
 
-from ......bonds import BondInfo
+from stk._internal.bond_info import BondInfo
 
 
 class _BondBatch:
     """
     A batch of bonds.
 
     """
 
-    __slots__ = ['_bonds', '_bond_infos']
+    __slots__ = ["_bonds", "_bond_infos"]
 
     def __init__(self, bonds, atom_map):
         """
         Initialize a :class:`.BondBatch` instance.
 
         Parameters
         ----------
```

### Comparing `stk-2022.6.17.0/src/stk/molecular/topology_graphs/topology_graph/construction_state/molecule_state/reactions_summary/reactions_summary.py` & `stk-2023.7.5.0/src/stk/_internal/construction_state/molecule_state/reactions_summary/reactions_summary.py`

 * *Files 6% similar despite different names*

```diff
@@ -31,22 +31,22 @@
 class _ReactionsSummary:
     """
     A summary of reaction results.
 
     """
 
     __slots__ = [
-        '_num_atoms',
-        '_atoms',
-        '_atom_infos',
-        '_positions',
-        '_bonds',
-        '_bond_infos',
-        '_deleted_atom_ids',
-        '_deleted_bond_ids',
+        "_num_atoms",
+        "_atoms",
+        "_atom_infos",
+        "_positions",
+        "_bonds",
+        "_bond_infos",
+        "_deleted_atom_ids",
+        "_deleted_bond_ids",
     ]
 
     def __init__(self, num_atoms, reaction_results):
         """
         Initialize a :class:`.ReactionsSummary` instance.
 
         Parameters
```

### Comparing `stk-2022.6.17.0/src/stk/molecular/topology_graphs/topology_graph/edge.py` & `stk-2023.7.5.0/src/stk/_internal/topology_graphs/edge.py`

 * *Files 1% similar despite different names*

```diff
@@ -237,10 +237,8 @@
 
         return self.clone()._with_position(position)
 
     def __repr__(self):
         return str(self)
 
     def __str__(self):
-        return (
-            f'Edge({self._id}, {self._vertex1_id}, {self._vertex2_id})'
-        )
+        return f"Edge({self._id}, {self._vertex1_id}, {self._vertex2_id})"
```

### Comparing `stk-2022.6.17.0/src/stk/molecular/topology_graphs/topology_graph/edge_group.py` & `stk-2023.7.5.0/src/stk/_internal/topology_graphs/edge_group.py`

 * *Files 1% similar despite different names*

```diff
@@ -40,8 +40,8 @@
 
         yield from self._edge_ids
 
     def __str__(self):
         return repr(self)
 
     def __repr__(self):
-        return f'{self.__class__.__name__}(edge_ids={self._edge_ids})'
+        return f"{self.__class__.__name__}(edge_ids={self._edge_ids})"
```

### Comparing `stk-2022.6.17.0/src/stk/molecular/topology_graphs/topology_graph/optimizers/collapser.py` & `stk-2023.7.5.0/src/stk/_internal/optimizers/collapser.py`

 * *Files 7% similar despite different names*

```diff
@@ -8,51 +8,52 @@
 
 from .optimizer import Optimizer
 from .utilities import get_long_bond_ids, get_mch_bonds, get_subunits
 
 
 class Collapser(Optimizer):
     """
-    Performs rigid-body collapse of molecules [1]_.
+    Performs rigid-body collapse of molecules.
 
-    Examples
-    --------
-    *Structure Optimization*
+    Examples:
 
-    Using :class:`.Collapser` will lead to
-    :class:`.ConstructedMolecule` structures without long bonds.
+        *Structure Optimization*
 
-    .. testcode:: structure-optimization
+        Using :class:`.Collapser` will lead to
+        :class:`.ConstructedMolecule` structures without long bonds.
 
-        import stk
+        .. testcode:: structure-optimization
 
-        bb1 = stk.BuildingBlock('NCCN', [stk.PrimaryAminoFactory()])
-        bb2 = stk.BuildingBlock('O=CCC=O', [stk.AldehydeFactory()])
+            import stk
 
-        polymer = stk.ConstructedMolecule(
-            topology_graph=stk.polymer.Linear(
-                building_blocks=(bb1, bb2),
-                repeating_unit='AB',
-                num_repeating_units=2,
-                optimizer=stk.Collapser(),
-            ),
-        )
+            bb1 = stk.BuildingBlock('NCCN', [stk.PrimaryAminoFactory()])
+            bb2 = stk.BuildingBlock('O=CCC=O', [stk.AldehydeFactory()])
+
+            polymer = stk.ConstructedMolecule(
+                topology_graph=stk.polymer.Linear(
+                    building_blocks=(bb1, bb2),
+                    repeating_unit='AB',
+                    num_repeating_units=2,
+                    optimizer=stk.Collapser(),
+                ),
+            )
+
+        Optimisation with :mod:`stk` simply collects the final position
+        matrix. The optimisation's trajectory can be output using the
+        :mod:`MCHammer` implementation if required by the
+        user [#mchammer]_.
+
+        The open-source optimization code :mod:`MCHammer` specializes in
+        the `collapsing` of molecules with long bonds like those
+        constructed by :mod:`stk`. This code is entirely nonphysical and
+        is, therefore, completely general to any chemistry.
+
+    References:
 
-    Optimisation with :mod:`stk` simply collects the final position
-    matrix. The optimisation's trajectory can be output using the
-    :mod:`MCHammer` implementation if required by the user [1]_.
-
-    The open-source optimization code :mod:`MCHammer` specializes in
-    the `collapsing` of molecules with long bonds like those
-    constructed by :mod:`stk`. This code is entirely nonphysical and
-    is, therefore, completely general to any chemistry.
-
-    References
-    ----------
-    .. [1] https://github.com/andrewtarzia/MCHammer
+        .. [#mchammer] https://github.com/andrewtarzia/MCHammer
 
     """
 
     def __init__(
         self,
         step_size=0.1,
         distance_threshold=1.5,
@@ -86,15 +87,16 @@
     def optimize(self, state):
         # Define MCHammer molecule to optimize.
         mch_mol = mch.Molecule(
             atoms=(
                 mch.Atom(
                     id=atom.get_id(),
                     element_string=atom.__class__.__name__,
-                ) for atom in state.get_atoms()
+                )
+                for atom in state.get_atoms()
             ),
             bonds=get_mch_bonds(state),
             position_matrix=state.get_position_matrix(),
         )
 
         # Run optimization.
         mch_mol, result = self._optimizer.get_result(
```

### Comparing `stk-2022.6.17.0/src/stk/molecular/topology_graphs/topology_graph/optimizers/mchammer.py` & `stk-2023.7.5.0/src/stk/_internal/optimizers/mchammer.py`

 * *Files 12% similar despite different names*

```diff
@@ -1,145 +1,138 @@
-"""
-MCHammer
-========
-
-"""
-
 import mchammer as mch
 
+from stk._internal.construction_state.construction_state import (
+    ConstructionState,
+)
+
 from .optimizer import Optimizer
 from .utilities import get_long_bond_ids, get_mch_bonds, get_subunits
 
 
 class MCHammer(Optimizer):
     """
-    Performs Monte Carlo optimisation of long-bonds in molecules [1]_.
+    Performs Monte Carlo optimisation of long-bonds in molecules.
 
-    Examples
-    --------
-    *Structure Optimization*
+    Examples:
 
-    Using :class:`.MCHammer` will lead to :class:`.ConstructedMolecule`
-    structures without long bonds.
+        *Structure Optimization*
 
-    .. testcode:: structure-optimization
+        Using :class:`.MCHammer` will lead to :class:`.ConstructedMolecule`
+        structures without long bonds.
 
-        import stk
+        .. testcode:: structure-optimization
 
-        bb1 = stk.BuildingBlock('NCCN', [stk.PrimaryAminoFactory()])
-        bb2 = stk.BuildingBlock('O=CCC=O', [stk.AldehydeFactory()])
+            import stk
 
-        polymer = stk.ConstructedMolecule(
-            topology_graph=stk.polymer.Linear(
-                building_blocks=(bb1, bb2),
-                repeating_unit='AB',
-                num_repeating_units=6,
-                optimizer=stk.MCHammer(),
-            ),
-        )
+            bb1 = stk.BuildingBlock('NCCN', [stk.PrimaryAminoFactory()])
+            bb2 = stk.BuildingBlock('O=CCC=O', [stk.AldehydeFactory()])
+
+            polymer = stk.ConstructedMolecule(
+                topology_graph=stk.polymer.Linear(
+                    building_blocks=(bb1, bb2),
+                    repeating_unit='AB',
+                    num_repeating_units=6,
+                    optimizer=stk.MCHammer(),
+                ),
+            )
 
-    Optimisation with :mod:`stk` simply collects the final position
-    matrix. The optimisation's trajectory can be output using the
-    :mod:`MCHammer` implementation if required by the user [1]_.
-
-    The open-source optimization code :mod:`MCHammer` specializes in
-    the `collapsing` of molecules with long bonds like those
-    constructed by :mod:`stk`. This code is entirely nonphysical and
-    is, therefore, completely general to any chemistry.
-
-    References
-    ----------
-    .. [1] https://github.com/andrewtarzia/MCHammer
+        Optimisation with :mod:`stk` simply collects the final position
+        matrix. The optimisation's trajectory can be output using the
+        :mod:`MCHammer` implementation if required by the user
+        [#mchammer]_.
+
+        The open-source optimization code :mod:`MCHammer` specializes in
+        the `collapsing` of molecules with long bonds like those
+        constructed by :mod:`stk`. This code is entirely nonphysical and
+        is, therefore, completely general to any chemistry.
+
+    References:
+
+        .. [#mchammer] https://github.com/andrewtarzia/MCHammer
 
     """
 
     def __init__(
         self,
-        step_size=0.25,
-        target_bond_length=1.2,
-        num_steps=500,
-        bond_epsilon=50,
-        nonbond_epsilon=20,
-        nonbond_sigma=1.2,
-        nonbond_mu=3,
-        beta=2,
-        random_seed=1000,
-    ):
+        step_size: float = 0.25,
+        target_bond_length: float = 1.2,
+        num_steps: int = 500,
+        bond_epsilon: float = 50,
+        nonbond_epsilon: float = 20,
+        nonbond_sigma: float = 1.2,
+        nonbond_mu: float = 3,
+        beta: float = 2,
+        random_seed: int | None = 1000,
+    ) -> None:
         """
-        Initialize an instance of :class:`.MCHammer`.
+        Parameters:
 
-        Parameters
-        ----------
-        step_size : :class:`float`, optional
-            The relative size of the step to take during step.
-
-        target_bond_length : :class:`float`, optional
-            Target equilibrium bond length for long bonds to minimize
-            to in Angstrom.
-
-        num_steps : :class:`int`, optional
-            Number of MC moves to perform.
-
-        bond_epsilon : :class:`float`, optional
-            Value of epsilon used in the bond potential in MC moves.
-            Determines strength of the bond potential.
-
-        nonbond_epsilon : :class:`float`, optional
-            Value of epsilon used in the nonbond potential in MC moves.
-            Determines strength of the nonbond potential.
-            Larger values lead to a larger building block repulsion.
-
-        nonbond_sigma : :class:`float`, optional
-            Value of sigma used in the nonbond potential in MC moves.
-            Larger values lead to building block repulsion at larger
-            distances.
-
-        nonbond_mu : :class:`float`, optional
-            Value of mu used in the nonbond potential in MC moves.
-            Determines the steepness of the nonbond potential.
-
-        beta : :class:`float`, optional
-            Value of beta used in the in MC moves. Beta takes the
-            place of the inverse Boltzmann temperature.
-
-        random_seed : :class:`int` or :class:`NoneType`, optional
-            Random seed to use for MC algorithm. If
-            ``None`` a system-based random seed will be used
-            and results will not be reproducible between
-            invocations.
+            step_size:
+                The relative size of the step to take during step.
 
+            target_bond_length:
+                Target equilibrium bond length for long bonds to minimize
+                to in Angstrom.
+
+            num_steps:
+                Number of MC moves to perform.
+
+            bond_epsilon:
+                Value of epsilon used in the bond potential in MC moves.
+                Determines strength of the bond potential.
+
+            nonbond_epsilon:
+                Value of epsilon used in the nonbond potential in MC moves.
+                Determines strength of the nonbond potential.
+                Larger values lead to a larger building block repulsion.
+
+            nonbond_sigma:
+                Value of sigma used in the nonbond potential in MC moves.
+                Larger values lead to building block repulsion at larger
+                distances.
+
+            nonbond_mu:
+                Value of mu used in the nonbond potential in MC moves.
+                Determines the steepness of the nonbond potential.
+
+            beta:
+                Value of beta used in the in MC moves. Beta takes the
+                place of the inverse Boltzmann temperature.
+
+            random_seed:
+                Random seed to use for MC algorithm. If
+                ``None`` a system-based random seed will be used
+                and results will not be reproducible between
+                invocations.
         """
-
         self._optimizer = mch.Optimizer(
             step_size=step_size,
             target_bond_length=target_bond_length,
             num_steps=num_steps,
             bond_epsilon=bond_epsilon,
             nonbond_epsilon=nonbond_epsilon,
             nonbond_sigma=nonbond_sigma,
             nonbond_mu=nonbond_mu,
             beta=beta,
             random_seed=random_seed,
         )
 
-    def optimize(self, state):
-        # Define MCHammer molecule to optimize.
+    def optimize(self, state: ConstructionState) -> ConstructionState:
         mch_mol = mch.Molecule(
             atoms=(
                 mch.Atom(
                     id=atom.get_id(),
                     element_string=atom.__class__.__name__,
-                ) for atom in state.get_atoms()
+                )
+                for atom in state.get_atoms()
             ),
             bonds=tuple(get_mch_bonds(state)),
             position_matrix=state.get_position_matrix(),
         )
-
-        # Run optimization.
-        mch_mol, results = self._optimizer.get_result(
+        mch_mol, _ = self._optimizer.get_result(
             mol=mch_mol,
             bond_pair_ids=tuple(get_long_bond_ids(state)),
             subunits=get_subunits(state),
         )
         return state.with_position_matrix(
             position_matrix=mch_mol.get_position_matrix(),
         )
```

### Comparing `stk-2022.6.17.0/src/stk/molecular/topology_graphs/topology_graph/optimizers/periodic_collapser.py` & `stk-2023.7.5.0/src/stk/_internal/optimizers/periodic_collapser.py`

 * *Files 3% similar despite different names*

```diff
@@ -8,15 +8,15 @@
 
 from .optimizer import Optimizer
 from .utilities import get_long_bond_ids, get_mch_bonds, get_subunits
 
 
 class PeriodicCollapser(Optimizer):
     """
-    Performs rigid-body collapse of molecules [1]_.
+    Performs rigid-body collapse of molecules.
 
     This :class:`.Optimizer` will also update the `.PeriodicInfo`.
 
     Examples
     --------
     *Structure Optimization*
 
@@ -37,24 +37,24 @@
             optimizer=stk.PeriodicCollapser(),
         )
         cof = stk.ConstructedMolecule(topology_graph)
 
     Optimisation with :mod:`stk` simply collects the final position
     matrix and periodic info. The optimisation's trajectory can be
     output using the :mod:`MCHammer` implementation if required by the
-    user [1]_.
+    user [#mchammer]_.
 
     The open-source optimization code :mod:`MCHammer` specializes in
     the `collapsing` of molecules with long bonds like those
     constructed by :mod:`stk`. This code is entirely nonphysical and
     is, therefore, completely general to any chemistry.
 
     References
     ----------
-    .. [1] https://github.com/andrewtarzia/MCHammer
+    .. [#mchammer] https://github.com/andrewtarzia/MCHammer
 
     """
 
     def __init__(
         self,
         step_size=0.1,
         distance_threshold=1.5,
@@ -87,38 +87,39 @@
 
     def optimize(self, state):
         mch_mol = mch.Molecule(
             atoms=(
                 mch.Atom(
                     id=atom.get_id(),
                     element_string=atom.__class__.__name__,
-                ) for atom in state.get_atoms()
+                )
+                for atom in state.get_atoms()
             ),
             bonds=get_mch_bonds(state),
             position_matrix=state.get_position_matrix(),
         )
 
         mch_mol, result = self._optimizer.get_result(
             mol=mch_mol,
             bond_pair_ids=tuple(get_long_bond_ids(state)),
             subunits=get_subunits(state),
         )
 
         old_pos_mat = state.get_position_matrix()
         new_pos_mat = mch_mol.get_position_matrix()
         old_extents = (
-            abs(max(old_pos_mat[:, i])-min(old_pos_mat[:, i]))
+            abs(max(old_pos_mat[:, i]) - min(old_pos_mat[:, i]))
             for i in range(3)
         )
         new_extents = (
-            abs(max(new_pos_mat[:, i])-min(new_pos_mat[:, i]))
+            abs(max(new_pos_mat[:, i]) - min(new_pos_mat[:, i]))
             for i in range(3)
         )
-        ratios = (n/o for n, o in zip(new_extents, old_extents))
+        ratios = (n / o for n, o in zip(new_extents, old_extents))
         old_lattice = state.get_lattice_constants()
         new_lattice = tuple(
-            old_lattice[i]*ratio for i, ratio in enumerate(ratios)
+            old_lattice[i] * ratio for i, ratio in enumerate(ratios)
         )
         state = state.with_lattice_constants(new_lattice)
         return state.with_position_matrix(
             position_matrix=mch_mol.get_position_matrix()
         )
```

### Comparing `stk-2022.6.17.0/src/stk/molecular/topology_graphs/topology_graph/optimizers/spinner.py` & `stk-2023.7.5.0/src/stk/_internal/optimizers/spinner.py`

 * *Files 3% similar despite different names*

```diff
@@ -1,24 +1,22 @@
-"""
-Spinner
-=======
-
-"""
-
 import spindry as spd
 
-from ..construction_state import ConstructionState
+from stk._internal.construction_state.construction_state import (
+    ConstructionState,
+)
+
 from .optimizer import Optimizer
 
 
 class Spinner(Optimizer):
     """
-    Performs Monte Carlo optimisation of host-guest complexes [1]_.
+    Performs Monte Carlo optimisation of host-guest complexes.
 
     Examples:
+
         *Structure Optimization*
 
         Using :class:`.Spinner` will lead to
         :class:`.ConstructedMolecule` structures with better host-guest
         structures. Especially useful for multiple-guest systems and
         removing overlap.
 
@@ -53,31 +51,32 @@
                     guests=(guest1, guest2),
                     optimizer=stk.Spinner(),
                 ),
             )
 
         Optimisation with :mod:`stk` simply collects the final position
         matrix. The optimisation's trajectory can be output using the
-        :mod:`SpinDry` implementation if required by the user [1]_.
-        This code is entirely nonphysical and is, therefore, completely
-        general to any chemistry.
+        :mod:`SpinDry` implementation if required by the user
+        [#spindry]_. This code is entirely nonphysical and is,
+        therefore, completely general to any chemistry.
 
     References:
-        .. [1] https://github.com/andrewtarzia/SpinDry
+
+        .. [#spindry] https://github.com/andrewtarzia/SpinDry
 
     """
 
     def __init__(
         self,
         step_size: float = 1.5,
-        rotation_step_size: float = 5.,
+        rotation_step_size: float = 5.0,
         num_conformers: int = 50,
         max_attempts: int = 1000,
-        nonbond_epsilon: float = 5.,
-        beta: float = 2.,
+        nonbond_epsilon: float = 5.0,
+        beta: float = 2.0,
         random_seed: int = 1000,
     ) -> None:
         """
         Initialize an instance of :class:`.Spinner`.
 
         Parameters:
             step_size: The relative size of the step to take during
@@ -116,24 +115,26 @@
 
     def optimize(self, state: ConstructionState) -> ConstructionState:
         supramolecule = spd.SupraMolecule(
             atoms=(
                 spd.Atom(
                     id=atom.get_id(),
                     element_string=atom.__class__.__name__,
-                ) for atom in state.get_atoms()
+                )
+                for atom in state.get_atoms()
             ),
             bonds=(
                 spd.Bond(
                     id=i,
                     atom_ids=(
                         bond.get_atom1().get_id(),
                         bond.get_atom2().get_id(),
-                    )
-                ) for i, bond in enumerate(state.get_bonds())
+                    ),
+                )
+                for i, bond in enumerate(state.get_bonds())
             ),
             position_matrix=state.get_position_matrix(),
         )
 
         conformer = self._optimizer.get_final_conformer(supramolecule)
         return state.with_position_matrix(
             position_matrix=conformer.get_position_matrix(),
```

### Comparing `stk-2022.6.17.0/src/stk/molecular/topology_graphs/topology_graph/optimizers/utilities.py` & `stk-2023.7.5.0/src/stk/_internal/optimizers/utilities.py`

 * *Files identical despite different names*

### Comparing `stk-2022.6.17.0/src/stk/molecular/topology_graphs/topology_graph/topology_graph/implementations/parallel.py` & `stk-2023.7.5.0/src/stk/_internal/topology_graphs/topology_graph/parallel.py`

 * *Files 6% similar despite different names*

```diff
@@ -4,15 +4,18 @@
 
 """
 
 from __future__ import annotations
 
 import pathos
 
-from ...construction_state import ConstructionState
+from stk._internal.construction_state.construction_state import (
+    ConstructionState,
+)
+
 from .utilities import _Placement
 
 
 class _Parallel:
     """
     Holds parallel implementations of topology graph methods.
 
@@ -41,17 +44,15 @@
     def _place_building_blocks(
         self,
         state: ConstructionState,
     ) -> ConstructionState:
         with pathos.pools.ProcessPool(self._num_processes) as pool:
             for stage in self._stages:
                 vertices = tuple(state.get_vertices(stage))
-                building_blocks = tuple(
-                    map(state.get_building_block, stage)
-                )
+                building_blocks = tuple(map(state.get_building_block, stage))
                 edges = tuple(map(state.get_edges, stage))
                 placements = map(
                     _Placement,
                     vertices,
                     edges,
                     building_blocks,
                 )
```

### Comparing `stk-2022.6.17.0/src/stk/molecular/topology_graphs/topology_graph/topology_graph/implementations/serial.py` & `stk-2023.7.5.0/src/stk/_internal/topology_graphs/topology_graph/serial.py`

 * *Files 12% similar despite different names*

```diff
@@ -2,15 +2,18 @@
 Serial Topology Graph
 =====================
 
 """
 
 from __future__ import annotations
 
-from ...construction_state import ConstructionState
+from stk._internal.construction_state.construction_state import (
+    ConstructionState,
+)
+
 from .utilities import _Placement
 
 
 class _Serial:
     """
     Holds serial implementations of topology graph methods.
 
@@ -32,20 +35,17 @@
 
         self._stages = stages
 
     def _place_building_blocks(
         self,
         state: ConstructionState,
     ) -> ConstructionState:
-
         for stage in self._stages:
             vertices = tuple(state.get_vertices(stage))
-            building_blocks = tuple(
-                map(state.get_building_block, stage)
-            )
+            building_blocks = tuple(map(state.get_building_block, stage))
             edges = tuple(map(state.get_edges, stage))
             placements = map(
                 _Placement,
                 vertices,
                 edges,
                 building_blocks,
             )
```

### Comparing `stk-2022.6.17.0/src/stk/molecular/topology_graphs/topology_graph/topology_graph/implementations/utilities.py` & `stk-2023.7.5.0/src/stk/_internal/topology_graphs/topology_graph/utilities.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,27 +1,28 @@
 """
 Topology Graph Implementation Utilities
 =======================================
 
 """
 
-from __future__ import annotations
 
 import typing
 
 import numpy as np
 
-from ...construction_state import ConstructionState
+if typing.TYPE_CHECKING:
+    from stk._internal.construction_state.construction_state import (
+        ConstructionState,
+    )
 
 
 class _TopologyGraphImplementation(typing.Protocol):
     def _place_building_blocks(
-        self,
-        state: ConstructionState
-    ) -> ConstructionState:
+        self, state: "ConstructionState"
+    ) -> "ConstructionState":
         pass
 
     def get_num_stages(self) -> int:
         pass
 
 
 class _PlacementResult(typing.NamedTuple):
@@ -90,17 +91,15 @@
             building_block=self._building_block,
             edges=self._edges,
         )
         position_matrix.setflags(write=False)
         building_block = self._building_block.with_position_matrix(
             position_matrix=position_matrix,
         )
-        functional_group_edges = (
-            self._vertex.map_functional_groups_to_edges(
-                building_block=building_block,
-                edges=self._edges,
-            )
+        functional_group_edges = self._vertex.map_functional_groups_to_edges(
+            building_block=building_block,
+            edges=self._edges,
         )
         return _PlacementResult(
             position_matrix=position_matrix,
             functional_group_edges=functional_group_edges,
         )
```

### Comparing `stk-2022.6.17.0/src/stk/molecular/topology_graphs/topology_graph/topology_graph/topology_graph.py` & `stk-2023.7.5.0/src/stk/_internal/topology_graphs/topology_graph/topology_graph.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,40 +1,41 @@
-"""
-Topology Graph
-==============
-
-"""
-
 from __future__ import annotations
 
 import typing
 from collections import abc
 from functools import partial
 
 import numpy as np
 
-from stk.utilities import flatten
-
-from ....molecules import BuildingBlock
-from ....reactions import ReactionFactory
-from ..construction_result import ConstructionResult
-from ..construction_state import ConstructionState
-from ..edge import Edge
-from ..edge_group import EdgeGroup
-from ..optimizers import Optimizer
-from ..vertex import Vertex
-from .implementations import (
+from stk._internal.building_block import BuildingBlock
+from stk._internal.construction_result.construction_result import (
+    ConstructionResult,
+)
+from stk._internal.construction_state.construction_state import (
+    ConstructionState,
+)
+from stk._internal.optimizers.optimizer import Optimizer
+from stk._internal.reaction_factories.reaction_factory import ReactionFactory
+from stk._internal.topology_graphs.edge import Edge
+from stk._internal.topology_graphs.edge_group import EdgeGroup
+from stk._internal.topology_graphs.topology_graph.parallel import (
     _Parallel,
+)
+from stk._internal.topology_graphs.topology_graph.serial import (
     _Serial,
+)
+from stk._internal.topology_graphs.topology_graph.utilities import (
     _TopologyGraphImplementation,
 )
+from stk._internal.topology_graphs.vertex import Vertex
+from stk._internal.utilities.utilities import flatten
 
 _TopologyGraphT = typing.TypeVar(
-    '_TopologyGraphT',
-    bound='TopologyGraph',
+    "_TopologyGraphT",
+    bound="TopologyGraph",
 )
 
 
 class TopologyGraph:
     """
     An abstract base class for topology graphs.
 
@@ -159,23 +160,25 @@
     """
 
     _implementation: _TopologyGraphImplementation
 
     def __init__(
         self,
         building_block_vertices: dict[
-            BuildingBlock, abc.Sequence[Vertex],
+            BuildingBlock,
+            abc.Sequence[Vertex],
         ],
         edges: tuple[Edge, ...],
         reaction_factory: ReactionFactory,
         construction_stages: tuple[
             # TODO: Use typing.Callable here for now so that Sphinx
             # generates hyperlinks in the compiled docs. This should
             # eventually be replaced by abc.Callable.
-            typing.Callable[[Vertex], bool], ...
+            typing.Callable[[Vertex], bool],
+            ...,
         ],
         num_processes: int,
         optimizer: Optimizer,
         edge_groups: typing.Optional[tuple[EdgeGroup, ...]] = None,
     ) -> None:
         """
         Initialize an instance of :class:`.TopologyGraph`.
@@ -235,16 +238,15 @@
         self._scale = scale = self._get_scale(building_block_vertices)
 
         def apply_scale(item):
             return item.with_scale(scale)
 
         self._building_block_vertices = {
             building_block: tuple(map(apply_scale, vertices))
-            for building_block, vertices
-            in building_block_vertices.items()
+            for building_block, vertices in building_block_vertices.items()
         }
         self._edges = tuple(map(apply_scale, edges))
         self._reaction_factory = reaction_factory
 
         if num_processes == 1:
             self._implementation = _Serial(
                 stages=tuple(self._get_stages(construction_stages)),
@@ -252,17 +254,15 @@
         else:
             self._implementation = _Parallel(
                 stages=tuple(self._get_stages(construction_stages)),
                 num_processes=num_processes,
             )
 
         if edge_groups is None:
-            edge_groups = tuple(
-                EdgeGroup((edge, )) for edge in self._edges
-            )
+            edge_groups = tuple(EdgeGroup((edge,)) for edge in self._edges)
         self._edge_groups = edge_groups
 
         self._optimizer = optimizer
 
     def _with_building_blocks(
         self: _TopologyGraphT,
         building_block_map: dict[BuildingBlock, BuildingBlock],
@@ -272,39 +272,34 @@
 
         """
 
         # The original scaling first needs to be removed, so that when
         # the scale is recalculated with the new building blocks, it
         # has the same starting geometry.
         def undo_scale(vertex):
-            return vertex.with_scale(1/self._scale)
+            return vertex.with_scale(1 / self._scale)
 
-        building_block_vertices: dict[
-            BuildingBlock, abc.Sequence[Vertex]
-        ]
+        building_block_vertices: dict[BuildingBlock, abc.Sequence[Vertex]]
         building_block_vertices = {
-            building_block_map.get(building_block, building_block):
-                tuple(map(undo_scale, vertices))
-            for building_block, vertices
-            in self._building_block_vertices.items()
+            building_block_map.get(bb, bb): tuple(map(undo_scale, vertices))
+            for bb, vertices in self._building_block_vertices.items()
         }
         scale = self._get_scale(building_block_vertices)
 
         def scale_vertex(vertex):
             return vertex.with_scale(scale)
 
         self._building_block_vertices = {
             building_block: tuple(map(scale_vertex, vertices))
-            for building_block, vertices
-            in building_block_vertices.items()
+            for building_block, vertices in building_block_vertices.items()
         }
 
         def scale_edge(edge):
             # Remove the old scale and apply the new one.
-            return edge.with_scale(scale/self._scale)
+            return edge.with_scale(scale / self._scale)
 
         self._edges = edges = tuple(map(scale_edge, self._edges))
 
         def get_new_edge(edge_id):
             return edges[edge_id]
 
         self._edge_groups = tuple(
@@ -348,17 +343,15 @@
         """
 
         return self._clone()
 
     def _clone(self: _TopologyGraphT) -> _TopologyGraphT:
         clone = self.__class__.__new__(self.__class__)
         clone._scale = self._scale
-        clone._building_block_vertices = dict(
-            self._building_block_vertices
-        )
+        clone._building_block_vertices = dict(self._building_block_vertices)
         clone._edges = self._edges
         clone._reaction_factory = self._reaction_factory
         clone._implementation = self._implementation
         clone._optimizer = self._optimizer
         clone._edge_groups = self._edge_groups
         return clone
 
@@ -376,22 +369,21 @@
 
             A building block of the topology graph.
 
         """
 
         vertex_building_blocks = {}
         num_vertices = 0
-        for building_block, vertices in (
-            self._building_block_vertices.items()
-        ):
+        for (
+            building_block,
+            vertices,
+        ) in self._building_block_vertices.items():
             for vertex in vertices:
                 num_vertices += 1
-                vertex_building_blocks[vertex.get_id()] = (
-                    building_block
-                )
+                vertex_building_blocks[vertex.get_id()] = building_block
 
         yielded = set()
         for vertex_id in range(num_vertices):
             building_block = vertex_building_blocks[vertex_id]
             if building_block not in yielded:
                 yielded.add(building_block)
                 yield building_block
@@ -412,17 +404,15 @@
         Returns:
 
             The number of times `building_block` is present in the
             topology graph.
 
         """
 
-        return len(
-            self._building_block_vertices.get(building_block, [])
-        )
+        return len(self._building_block_vertices.get(building_block, []))
 
     def _get_lattice_constants(self) -> typing.Iterator[np.ndarray]:
         """
         Yield the lattice constants of the topology graph.
 
         The a, b and c lattice constants are yielded, in that order.
 
@@ -474,23 +464,24 @@
         return ConstructionResult(state)
 
     def _get_construction_state(self) -> ConstructionState:
         return ConstructionState(
             building_block_vertices=self._building_block_vertices,
             edges=self._edges,
             lattice_constants=tuple(
-                np.array(constant, dtype=np.float64)*self._scale
+                np.array(constant, dtype=np.float64) * self._scale
                 for constant in self._get_lattice_constants()
             ),
         )
 
     def _get_scale(
         self,
         building_block_vertices: dict[
-            BuildingBlock, abc.Sequence[Vertex],
+            BuildingBlock,
+            abc.Sequence[Vertex],
         ],
     ) -> float:
         """
         Get the scale, which should be applied to topology graph.
 
         The scale should be applied to the position of every vertex
         and edge of topology graph. This allows to graph to adjust
@@ -572,15 +563,15 @@
         Yields:
 
             Vertices ids, which can be placed in parallel.
 
         """
 
         stages: tuple[list[int], ...] = tuple(
-            [] for i in range(len(construction_stages)+1)
+            [] for i in range(len(construction_stages) + 1)
         )
         vertices = flatten(self._building_block_vertices.values())
         for vertex in vertices:
             placed = False
             for i, stage in enumerate(construction_stages):
                 if stage(vertex):
                     stages[i].append(vertex.get_id())
```

### Comparing `stk-2022.6.17.0/src/stk/molecular/topology_graphs/topology_graph/vertex.py` & `stk-2023.7.5.0/src/stk/_internal/topology_graphs/vertex.py`

 * *Files 3% similar despite different names*

```diff
@@ -6,18 +6,19 @@
 
 from __future__ import annotations
 
 import typing
 
 import numpy as np
 
-from ...molecules import BuildingBlock
+from stk._internal.building_block import BuildingBlock
+
 from .edge import Edge
 
-_VertexT = typing.TypeVar('_VertexT', bound='Vertex')
+_VertexT = typing.TypeVar("_VertexT", bound="Vertex")
 
 
 class Vertex:
     """
     An abstract base class for :class:`.TopologyGraph` vertices.
 
     Notes:
@@ -227,11 +228,11 @@
 
         """
 
         raise NotImplementedError()
 
     def __str__(self) -> str:
         position = self._position.tolist()
-        return f'Vertex(id={self._id}, position={position})'
+        return f"Vertex(id={self._id}, position={position})"
 
     def __repr__(self) -> str:
         return str(self)
```

### Comparing `stk-2022.6.17.0/src/stk/molecular/topology_graphs/utilities/edge_sorter.py` & `stk-2023.7.5.0/src/stk/_internal/topology_graphs/utilities/edge_sorter.py`

 * *Files 11% similar despite different names*

```diff
@@ -10,18 +10,18 @@
 class _EdgeSorter(_Sorter):
     """
     Sorted edges according to their angle.
 
     """
 
     __slots__ = [
-        '_items',
-        '_reference',
-        '_axis',
-        '_edge_centroid',
+        "_items",
+        "_reference",
+        "_axis",
+        "_edge_centroid",
     ]
 
     def __init__(self, edges, aligner_edge, axis):
         """
         Initialize an :class:`._EdgeSorter` instance.
 
         Parameters
@@ -34,17 +34,17 @@
 
         axis : :class:`numpy.ndarray`
             Must be immutable. The axis used to determine the clockwise
             direction.
 
         """
 
-        self._edge_centroid = edge_centroid = (
-            sum(edge.get_position() for edge in edges) / len(edges)
-        )
+        self._edge_centroid = edge_centroid = sum(
+            edge.get_position() for edge in edges
+        ) / len(edges)
         super().__init__(
             items=edges,
             axis=axis,
             reference=aligner_edge.get_position() - edge_centroid,
         )
 
     def _get_vector(self, item):
```

### Comparing `stk-2022.6.17.0/src/stk/molecular/topology_graphs/utilities/functional_group_sorter.py` & `stk-2023.7.5.0/src/stk/_internal/topology_graphs/utilities/functional_group_sorter.py`

 * *Files 8% similar despite different names*

```diff
@@ -2,31 +2,31 @@
 Functional Group Sorter
 =======================
 
 """
 
 import numpy as np
 
-from stk.utilities import get_acute_vector
+from stk._internal.utilities.utilities import get_acute_vector
 
 from .sorter import _Sorter
 
 
 class _FunctionalGroupSorter(_Sorter):
     """
     Sorts functional groups according to their angle.
 
     """
 
     __slots__ = [
-        '_items',
-        '_reference',
-        '_axis',
-        '_placer_centroid',
-        '_building_block',
+        "_items",
+        "_reference",
+        "_axis",
+        "_placer_centroid",
+        "_building_block",
     ]
 
     def __init__(self, building_block):
         """
         Initialize a :class:`._FunctionalGroupSorter` instance.
 
         Parameters
@@ -39,18 +39,16 @@
 
         self._building_block = building_block
         fg0_position = building_block.get_centroid(
             atom_ids=next(
                 building_block.get_functional_groups()
             ).get_placer_ids(),
         )
-        self._placer_centroid = placer_centroid = (
-            building_block.get_centroid(
-                atom_ids=building_block.get_placer_ids(),
-            )
+        self._placer_centroid = placer_centroid = building_block.get_centroid(
+            atom_ids=building_block.get_placer_ids(),
         )
         fg0_direction = fg0_position - placer_centroid
         core_centroid = building_block.get_centroid(
             atom_ids=building_block.get_core_atom_ids(),
         )
         axis = np.cross(
             fg0_direction,
@@ -64,10 +62,10 @@
             items=range(building_block.get_num_functional_groups()),
             reference=fg0_direction,
             axis=axis,
         )
 
     def _get_vector(self, item):
         building_block = self._building_block
-        fg, = building_block.get_functional_groups(item)
+        (fg,) = building_block.get_functional_groups(item)
         fg_position = building_block.get_centroid(fg.get_placer_ids())
         return fg_position - self._placer_centroid
```

### Comparing `stk-2022.6.17.0/src/stk/molecular/topology_graphs/utilities/sorter.py` & `stk-2023.7.5.0/src/stk/_internal/topology_graphs/utilities/sorter.py`

 * *Files 6% similar despite different names*

```diff
@@ -2,24 +2,24 @@
 Sorter
 ======
 
 """
 
 import numpy as np
 
-from stk.utilities import vector_angle
+from stk._internal.utilities.utilities import vector_angle
 
 
 class _Sorter:
     """
     Sorts items according to their angle from a reference vector.
 
     """
 
-    __slots__ = ['_items', '_reference', '_axis']
+    __slots__ = ["_items", "_reference", "_axis"]
 
     def __init__(self, items, reference, axis):
         """
         Initialize a :class:`._Sorter`.
 
         Parameters
         ----------
@@ -75,15 +75,15 @@
 
         """
 
         vector = self._get_vector(item)
         theta = vector_angle(self._reference, vector)
         projection = vector @ self._axis
         if theta > 0 and projection < 0:
-            return 2*np.pi - theta
+            return 2 * np.pi - theta
         return theta
 
     def get_items(self):
         """
         Yield the sorted items.
 
         Yields
```

### Comparing `stk-2022.6.17.0/src/stk/molecular/writers/mdl_mol.py` & `stk-2023.7.5.0/src/stk/_internal/writers/mdl_mol.py`

 * *Files 7% similar despite different names*

```diff
@@ -2,18 +2,19 @@
 Mol Writer
 ==========
 
 """
 
 from __future__ import annotations
 
+import pathlib
 import typing
 
-from ...utilities import OneOrMany
-from ..molecules import Molecule
+from stk._internal.molecule import Molecule
+from stk._internal.utilities.utilities import OneOrMany
 
 
 class MolWriter:
     """
     A writer class for V3000 ``.mol`` files.
 
     Examples:
@@ -43,68 +44,67 @@
     """
 
     def _write_content(
         self,
         molecule: Molecule,
         atom_ids: typing.Optional[OneOrMany[int]],
     ) -> str:
-
         if atom_ids is None:
             atom_ids = range(molecule.get_num_atoms())
         elif isinstance(atom_ids, int):
-            atom_ids = (atom_ids, )
+            atom_ids = (atom_ids,)
 
         atom_lines = []
         coords = molecule.get_position_matrix()
         # This set gets used by bonds.
         id_map = {}
         for new_atom_id, old_atom_id in enumerate(atom_ids, 1):
             id_map[old_atom_id] = new_atom_id
 
             x, y, z = (i for i in coords[old_atom_id])
-            atom, = molecule.get_atoms(atom_ids=old_atom_id)
+            (atom,) = molecule.get_atoms(atom_ids=old_atom_id)
             symbol = atom.__class__.__name__
             charge_ = atom.get_charge()
-            charge = f' CHG={charge_}' if charge_ else ''
+            charge = f" CHG={charge_}" if charge_ else ""
             atom_lines.append(
-                f'M  V30 {new_atom_id} {symbol} {x:.4f} '
-                f'{y:.4f} {z:.4f} 0{charge}\n'
+                f"M  V30 {new_atom_id} {symbol} {x:.4f} "
+                f"{y:.4f} {z:.4f} 0{charge}\n"
             )
-        atom_block = ''.join(atom_lines)
+        atom_block = "".join(atom_lines)
 
         bond_lines: list[str] = []
         for bond in molecule.get_bonds():
             a1 = bond.get_atom1().get_id()
             a2 = bond.get_atom2().get_id()
             if a1 in id_map and a2 in id_map:
                 bond_lines.append(
-                    f'M  V30 {len(bond_lines)+1} '
-                    f'{int(bond.get_order())} '
-                    f'{id_map[a1]} {id_map[a2]}\n'
+                    f"M  V30 {len(bond_lines)+1} "
+                    f"{int(bond.get_order())} "
+                    f"{id_map[a1]} {id_map[a2]}\n"
                 )
 
         num_bonds = len(bond_lines)
-        bond_block = ''.join(bond_lines)
+        bond_block = "".join(bond_lines)
         return (
-            '\n'
-            '     RDKit          3D\n'
-            '\n'
-            '  0  0  0  0  0  0  0  0  0  0999 V3000\n'
-            'M  V30 BEGIN CTAB\n'
-            f'M  V30 COUNTS {len(id_map)} {num_bonds} 0 0 0\n'
-            'M  V30 BEGIN ATOM\n'
-            f'{atom_block}'
-            'M  V30 END ATOM\n'
-            'M  V30 BEGIN BOND\n'
-            f'{bond_block}'
-            'M  V30 END BOND\n'
-            'M  V30 END CTAB\n'
-            'M  END\n'
-            '\n'
-            '$$$$\n'
+            "\n"
+            "     RDKit          3D\n"
+            "\n"
+            "  0  0  0  0  0  0  0  0  0  0999 V3000\n"
+            "M  V30 BEGIN CTAB\n"
+            f"M  V30 COUNTS {len(id_map)} {num_bonds} 0 0 0\n"
+            "M  V30 BEGIN ATOM\n"
+            f"{atom_block}"
+            "M  V30 END ATOM\n"
+            "M  V30 BEGIN BOND\n"
+            f"{bond_block}"
+            "M  V30 END BOND\n"
+            "M  V30 END CTAB\n"
+            "M  END\n"
+            "\n"
+            "$$$$\n"
         )
 
     def to_string(
         self,
         molecule: Molecule,
         atom_ids: typing.Optional[OneOrMany[int]] = None,
     ) -> str:
@@ -128,15 +128,15 @@
         """
 
         return self._write_content(molecule, atom_ids)
 
     def write(
         self,
         molecule: Molecule,
-        path: str,
+        path: pathlib.Path | str,
         atom_ids: typing.Optional[OneOrMany[int]] = None,
     ) -> None:
         """
         Write `molecule` to V3000 ``.mol`` file format.
 
         Parameters:
 
@@ -149,9 +149,9 @@
             atom_ids:
                 The atom ids of atoms to write. Can be a single
                 :class:`int`, if a single atom is to be used, or
                 ``None``, if all atoms are to be used.
 
         """
 
-        with open(path, 'w') as f:
+        with open(path, "w") as f:
             f.write(self._write_content(molecule, atom_ids))
```

### Comparing `stk-2022.6.17.0/src/stk/molecular/writers/pdb.py` & `stk-2023.7.5.0/src/stk/_internal/writers/pdb.py`

 * *Files 4% similar despite different names*

```diff
@@ -2,19 +2,20 @@
 PDB Writer
 ==========
 
 """
 
 from __future__ import annotations
 
+import pathlib
 import typing
 
-from ...utilities import OneOrMany
-from ..molecules import Molecule
-from ..periodic_info import PeriodicInfo
+from stk._internal.molecule import Molecule
+from stk._internal.periodic_info import PeriodicInfo
+from stk._internal.utilities.utilities import OneOrMany
 
 
 class PdbWriter:
     """
     A writer class for ``.pdb`` files.
 
     Examples:
@@ -66,87 +67,86 @@
 
     def _write_content(
         self,
         molecule: Molecule,
         atom_ids: typing.Optional[OneOrMany[int]],
         periodic_info: typing.Optional[PeriodicInfo] = None,
     ) -> list[str]:
-
         if atom_ids is None:
             atom_ids = range(molecule.get_num_atoms())
         elif isinstance(atom_ids, int):
-            atom_ids = (atom_ids, )
+            atom_ids = (atom_ids,)
 
         content = []
         if periodic_info is not None:
             # Input unit cell information.
             a = periodic_info.get_a()
             b = periodic_info.get_b()
             c = periodic_info.get_c()
             alpha = periodic_info.get_alpha()
             beta = periodic_info.get_beta()
             gamma = periodic_info.get_gamma()
             content.append(
-                f'CRYST1 {a:>8.3f} {b:>8.3f} {c:>8.3f}'
-                f' {alpha:>6.2f} {beta:>6.2f} {gamma:>6.2f} '
-                f'P 1\n'
+                f"CRYST1 {a:>8.3f} {b:>8.3f} {c:>8.3f}"
+                f" {alpha:>6.2f} {beta:>6.2f} {gamma:>6.2f} "
+                f"P 1\n"
             )
 
         atom_counts: dict[str, int] = {}
-        hetatm = 'HETATM'
-        alt_loc = ''
-        res_name = 'UNL'
-        chain_id = ''
-        res_seq = '1'
-        i_code = ''
-        occupancy = '1.00'
-        temp_factor = '0.00'
+        hetatm = "HETATM"
+        alt_loc = ""
+        res_name = "UNL"
+        chain_id = ""
+        res_seq = "1"
+        i_code = ""
+        occupancy = "1.00"
+        temp_factor = "0.00"
 
         coords = molecule.get_position_matrix()
         # This set will be used by bonds.
         atoms = set()
         for atom_id in atom_ids:
             atoms.add(atom_id)
-            atom, = molecule.get_atoms(atom_ids=atom_id)
-            serial = atom_id+1
+            (atom,) = molecule.get_atoms(atom_ids=atom_id)
+            serial = atom_id + 1
             element = atom.__class__.__name__
             charge = atom.get_charge()
             atom_counts[element] = atom_counts.get(element, 0) + 1
-            name = f'{element}{atom_counts[element]}'
+            name = f"{element}{atom_counts[element]}"
             # Make sure the coords are no more than 8 columns wide
             # each.
             x, y, z = (i for i in coords[atom_id])
 
             content.append(
-                f'{hetatm:<6}{serial:>5} {name:<4}'
-                f'{alt_loc:<1}{res_name:<3} {chain_id:<1}'
-                f'{res_seq:>4}{i_code:<1}   '
-                f' {x:>7.3f} {y:>7.3f} {z:>7.3f}'
-                f'{occupancy:>6}{temp_factor:>6}          '
-                f'{element:>2}{charge:>2}\n'
+                f"{hetatm:<6}{serial:>5} {name:<4}"
+                f"{alt_loc:<1}{res_name:<3} {chain_id:<1}"
+                f"{res_seq:>4}{i_code:<1}   "
+                f" {x:>7.3f} {y:>7.3f} {z:>7.3f}"
+                f"{occupancy:>6}{temp_factor:>6}          "
+                f"{element:>2}{charge:>2}\n"
             )
 
-        conect = 'CONECT'
+        conect = "CONECT"
         for bond in molecule.get_bonds():
             a1 = bond.get_atom1().get_id()
             a2 = bond.get_atom2().get_id()
             if a1 in atoms and a2 in atoms:
                 content.append(
-                    f'{conect:<6}{a1+1:>5}{a2+1:>5}               \n'
+                    f"{conect:<6}{a1+1:>5}{a2+1:>5}               \n"
                 )
 
-        content.append('END\n')
+        content.append("END\n")
 
         return content
 
     def to_string(
         self,
         molecule: Molecule,
         atom_ids: typing.Optional[OneOrMany[int]] = None,
-        periodic_info: typing.Optional[PeriodicInfo] = None
+        periodic_info: typing.Optional[PeriodicInfo] = None,
     ) -> str:
         """
         Get a ``.pdb`` file format string of `molecule`.
 
         Parameters:
 
             molecule:
@@ -168,22 +168,22 @@
 
         content = self._write_content(
             molecule=molecule,
             atom_ids=atom_ids,
             periodic_info=periodic_info,
         )
 
-        return ''.join(content)
+        return "".join(content)
 
     def write(
         self,
         molecule: Molecule,
-        path: str,
+        path: pathlib.Path | str,
         atom_ids: typing.Optional[OneOrMany[int]] = None,
-        periodic_info: typing.Optional[PeriodicInfo] = None
+        periodic_info: typing.Optional[PeriodicInfo] = None,
     ) -> None:
         """
         Write `molecule` to ``.pdb`` file format.
 
         Parameters:
 
             molecule:
@@ -204,9 +204,9 @@
 
         content = self._write_content(
             molecule=molecule,
             atom_ids=atom_ids,
             periodic_info=periodic_info,
         )
 
-        with open(path, 'w') as f:
-            f.write(''.join(content))
+        with open(path, "w") as f:
+            f.write("".join(content))
```

### Comparing `stk-2022.6.17.0/src/stk/molecular/writers/turbomole.py` & `stk-2023.7.5.0/src/stk/_internal/writers/turbomole.py`

 * *Files 2% similar despite different names*

```diff
@@ -4,17 +4,17 @@
 
 """
 
 from __future__ import annotations
 
 import typing
 
-from ...utilities import OneOrMany
-from ..molecules import Molecule
-from ..periodic_info import PeriodicInfo
+from stk._internal.molecule import Molecule
+from stk._internal.periodic_info import PeriodicInfo
+from stk._internal.utilities.utilities import OneOrMany
 
 
 class TurbomoleWriter:
     """
     A writer class for ``Turbomole`` files.
 
     Examples:
@@ -66,48 +66,46 @@
 
     def _write_content(
         self,
         molecule: Molecule,
         atom_ids: typing.Optional[OneOrMany[int]],
         periodic_info: typing.Optional[PeriodicInfo] = None,
     ) -> list[str]:
-
         if atom_ids is None:
             atom_ids = range(molecule.get_num_atoms())
         elif isinstance(atom_ids, int):
-            atom_ids = (atom_ids, )
+            atom_ids = (atom_ids,)
 
         content = []
         if periodic_info is not None:
             # Input unit cell information.
             a = periodic_info.get_a()
             b = periodic_info.get_b()
             c = periodic_info.get_c()
             alpha = periodic_info.get_alpha()
             beta = periodic_info.get_beta()
             gamma = periodic_info.get_gamma()
             content.append(
-                '$periodic 3\n'
-                '$cell angs\n'
-                f' {a:>8.3f} {b:>8.3f} {c:>8.3f} '
-                f'{alpha:>6.2f} {beta:>6.2f} {gamma:>6.2f}\n'
+                "$periodic 3\n"
+                "$cell angs\n"
+                f" {a:>8.3f} {b:>8.3f} {c:>8.3f} "
+                f"{alpha:>6.2f} {beta:>6.2f} {gamma:>6.2f}\n"
             )
 
         coords = molecule.get_position_matrix()
-        content.append('$coord angs\n')
+        content.append("$coord angs\n")
         for atom_id in atom_ids:
-            atom, = molecule.get_atoms(atom_ids=atom_id)
+            (atom,) = molecule.get_atoms(atom_ids=atom_id)
             element = atom.__class__.__name__
             x, y, z = (i for i in coords[atom_id])
             content.append(
-                f' {round(x, 4)} {round(y, 4)} {round(z, 4)} '
-                f'{element}\n'
+                f" {round(x, 4)} {round(y, 4)} {round(z, 4)} " f"{element}\n"
             )
 
-        content.append('$end\n')
+        content.append("$end\n")
 
         return content
 
     def to_string(
         self,
         molecule: Molecule,
         atom_ids: typing.Optional[OneOrMany[int]] = None,
@@ -137,15 +135,15 @@
 
         content = self._write_content(
             molecule=molecule,
             atom_ids=atom_ids,
             periodic_info=periodic_info,
         )
 
-        return ''.join(content)
+        return "".join(content)
 
     def write(
         self,
         molecule: Molecule,
         path: str,
         atom_ids: typing.Optional[OneOrMany[int]] = None,
         periodic_info: typing.Optional[PeriodicInfo] = None,
@@ -177,9 +175,9 @@
 
         content = self._write_content(
             molecule=molecule,
             atom_ids=atom_ids,
             periodic_info=periodic_info,
         )
 
-        with open(path, 'w') as f:
-            f.write(''.join(content))
+        with open(path, "w") as f:
+            f.write("".join(content))
```

### Comparing `stk-2022.6.17.0/src/stk/molecular/writers/xyz.py` & `stk-2023.7.5.0/src/stk/_internal/writers/xyz.py`

 * *Files 4% similar despite different names*

```diff
@@ -2,18 +2,19 @@
 XYZ Writer
 ==========
 
 """
 
 from __future__ import annotations
 
+import pathlib
 import typing
 
-from ...utilities import OneOrMany
-from ..molecules import Molecule
+from stk._internal.molecule import Molecule
+from stk._internal.utilities.utilities import OneOrMany
 
 
 class XyzWriter:
     """
     A writer class for ``.xyz`` files.
 
     Examples:
@@ -43,29 +44,28 @@
     """
 
     def _write_content(
         self,
         molecule: Molecule,
         atom_ids: typing.Optional[OneOrMany[int]],
     ) -> list[str]:
-
         if atom_ids is None:
             atom_ids = range(molecule.get_num_atoms())
         elif isinstance(atom_ids, int):
-            atom_ids = (atom_ids, )
+            atom_ids = (atom_ids,)
 
         coords = molecule.get_position_matrix()
-        content = ['']
+        content = [""]
         for i, atom_id in enumerate(atom_ids, 1):
             x, y, z = (i for i in coords[atom_id])
-            atom, = molecule.get_atoms(atom_ids=atom_id)
+            (atom,) = molecule.get_atoms(atom_ids=atom_id)
             symbol = atom.__class__.__name__
-            content.append(f'{symbol} {x:f} {y:f} {z:f}\n')
+            content.append(f"{symbol} {x:f} {y:f} {z:f}\n")
         # Set first line to the atom_count.
-        content[0] = f'{i}\n\n'
+        content[0] = f"{i}\n\n"
 
         return content
 
     def to_string(
         self,
         molecule: Molecule,
         atom_ids: typing.Optional[OneOrMany[int]] = None,
@@ -87,20 +87,20 @@
 
             String in ``.xyz`` file format.
 
         """
 
         content = self._write_content(molecule, atom_ids)
 
-        return ''.join(content)
+        return "".join(content)
 
     def write(
         self,
         molecule: Molecule,
-        path: str,
+        path: pathlib.Path | str,
         atom_ids: typing.Optional[OneOrMany[int]] = None,
     ) -> None:
         """
         Write `molecule` to ``.xyz`` file format.
 
         Parameters:
 
@@ -115,9 +115,9 @@
                 :class:`int`, if a single atom is to be used, or
                 ``None``, if all atoms are to be used.
 
         """
 
         content = self._write_content(molecule, atom_ids)
 
-        with open(path, 'w') as f:
-            f.write(''.join(content))
+        with open(path, "w") as f:
+            f.write("".join(content))
```

### Comparing `stk-2022.6.17.0/src/stk/serialization/json/serializers/molecule/molecule.py` & `stk-2023.7.5.0/src/stk/_internal/json_serde/molecule.py`

 * *Files 23% similar despite different names*

```diff
@@ -1,21 +1,24 @@
-"""
-Molecule JSONizer
-=================
-
-"""
-
-from __future__ import annotations
-
 import typing
 
-from stk.molecular import InchiKey, Molecule, MoleculeKeyMaker
-from stk.utilities import OneOrMany
+import numpy as np
 
-from .utilities import AtomJson, BondJson, atom_to_json, bond_to_json
+from stk._internal.key_makers.inchi_key import InchiKey
+from stk._internal.key_makers.molecule import MoleculeKeyMaker
+from stk._internal.molecule import Molecule
+from stk._internal.utilities.utilities import OneOrMany
+
+from .utilities import (
+    AtomJson,
+    BondJson,
+    atom_to_json,
+    bond_to_json,
+    to_atom,
+    to_bond,
+)
 
 
 class _MolecularGraphJson(typing.TypedDict):
     a: tuple[AtomJson, ...]
     b: tuple[BondJson, ...]
 
 
@@ -95,15 +98,15 @@
         name given by :meth:`.MoleculeKeyMaker.get_key_name` and the
         value given by :meth:`.MoleculeKeyMaker.get_key`.
 
     """
 
     def __init__(
         self,
-        key_makers: OneOrMany[MoleculeKeyMaker] = (InchiKey(), ),
+        key_makers: OneOrMany[MoleculeKeyMaker] = (InchiKey(),),
     ) -> None:
         """
         Initialize a :class:`.MoleculeJsonizer` instance.
 
         Parameters:
 
             key_makers:
@@ -111,15 +114,15 @@
                 included in their JSON representations. Keys allow
                 molecular data to reference itself when split across
                 multiple JSONs.
 
         """
 
         if isinstance(key_makers, MoleculeKeyMaker):
-            key_makers = (key_makers, )
+            key_makers = (key_makers,)
 
         self._key_makers = tuple(key_makers)
 
     def to_json(
         self,
         molecule: Molecule,
     ) -> _MoleculeJson:
@@ -134,32 +137,86 @@
         Returns:
 
             A JSON representation of `molecule`.
 
         """
 
         json: _MolecularGraphJson = {
-            'a': tuple(map(atom_to_json, molecule.get_atoms())),
-            'b': tuple(map(bond_to_json, molecule.get_bonds())),
+            "a": tuple(map(atom_to_json, molecule.get_atoms())),
+            "b": tuple(map(bond_to_json, molecule.get_bonds())),
         }
         position_matrix: _PositionMatrixJson = {
-            'm': molecule.get_position_matrix().tolist(),
+            "m": molecule.get_position_matrix().tolist(),
         }
         for key_maker in self._key_makers:
             key_name = key_maker.get_key_name()
             key = key_maker.get_key(molecule)
             # TypedDict does not allow keys which are not listed in the
             # class definition. However, because we wish to create
             # indices on keys created by KeyMakers we need to add
             # these additional key-value pairs.
             json[key_name] = key  # type: ignore
             position_matrix[key_name] = key  # type: ignore
         return {
-            'molecule': json,
-            'matrix': position_matrix,
+            "molecule": json,
+            "matrix": position_matrix,
         }
 
     def __str__(self) -> str:
         return repr(self)
 
     def __repr__(self) -> str:
-        return f'{self.__class__.__name__}({self._key_makers!r})'
+        return f"{self.__class__.__name__}({self._key_makers!r})"
+
+
+class MoleculeDejsonizer:
+    """
+    Abstract base class for creating molecules from JSONs.
+
+    See Also
+    --------
+    :class:`.ConstructedMoleculeDejsonizer`
+
+    Notes
+    -----
+    You might notice that the public methods of this abstract base
+    class are implemented. These are just default implementations,
+    which can be safely ignored or overridden, when implementing
+    subclasses. However, the default implementation can be used
+    directly, if it suits your needs.
+
+    """
+
+    def from_json(self, json):
+        """
+        Get a :class:`.Molecule` from a JSON.
+
+        Parameters
+        ----------
+        json : :class:`dict`
+            A JSON representation of a molecule.
+
+        Returns
+        -------
+        :class:`.Molecule`
+            The molecule held in `json`.
+
+        """
+
+        atoms = tuple(
+            to_atom(atom_id, atom_json)
+            for atom_id, atom_json in enumerate(json["molecule"]["a"])
+        )
+        return Molecule(
+            atoms=atoms,
+            bonds=tuple(
+                to_bond(atoms, bond_json)
+                for bond_json in json["molecule"]["b"]
+            ),
+            position_matrix=np.array(json["matrix"]["m"]),
+        )
+
+    def __str__(self):
+        return repr(self)
+
+    def __repr__(self):
+        return f"{self.__class__.__name__}()"
```

### Comparing `stk-2022.6.17.0/src/stk/utilities/utilities.py` & `stk-2023.7.5.0/src/stk/_internal/utilities/utilities.py`

 * *Files 24% similar despite different names*

```diff
@@ -21,72 +21,235 @@
 import numpy as np
 import rdkit.Chem.AllChem as rdkit
 from rdkit.Geometry import Point3D
 from scipy.spatial.transform import Rotation
 
 # Holds the elements Van der Waals radii in Angstroms.
 atom_vdw_radii = {
-    'Al': 2, 'Sb': 2, 'Ar': 1.88, 'As': 1.85, 'Ba': 2,
-    'Be': 2, 'Bi': 2, 'B': 2, 'Br': 1.85, 'Cd': 1.58,
-    'Cs': 2, 'Ca': 2, 'C': 1.7, 'Ce': 2, 'Cl': 1.75,
-    'Cr': 2, 'Co': 2, 'Cu': 1.4, 'Dy': 2, 'Er': 2,
-    'Eu': 2, 'F': 1.47, 'Gd': 2, 'Ga': 1.87, 'Ge': 2,
-    'Au': 1.66, 'Hf': 2, 'He': 1.4, 'Ho': 2, 'H': 1.09,
-    'In': 1.93, 'I': 1.98, 'Ir': 2, 'Fe': 2, 'Kr': 2.02,
-    'La': 2, 'Pb': 2.02, 'Li': 1.82, 'Lu': 2, 'Mg': 1.73,
-    'Mn': 2, 'Hg': 1.55, 'Mo': 2, 'Nd': 2, 'Ne': 1.54,
-    'Ni': 1.63, 'Nb': 2, 'N': 1.55, 'Os': 2, 'O': 1.52,
-    'Pd': 1.63, 'P': 1.8, 'Pt': 1.72, 'K': 2.75, 'Pr': 2,
-    'Pa': 2, 'Re': 2, 'Rh': 2, 'Rb': 2, 'Ru': 2, 'Sm': 2,
-    'Sc': 2, 'Se': 1.9, 'Si': 2.1, 'Ag': 1.72, 'Na': 2.27,
-    'Sr': 2, 'S': 1.8, 'Ta': 2, 'Te': 2.06, 'Tb': 2,
-    'Tl': 1.96, 'Th': 2, 'Tm': 2, 'Sn': 2.17, 'Ti': 2,
-    'W': 2, 'U': 1.86, 'V': 2, 'Xe': 2.16, 'Yb': 2,
-    'Y': 2, 'Zn': 1.29, 'Zr': 2, 'X': 1.0, 'D': 1.0
+    "Al": 2,
+    "Sb": 2,
+    "Ar": 1.88,
+    "As": 1.85,
+    "Ba": 2,
+    "Be": 2,
+    "Bi": 2,
+    "B": 2,
+    "Br": 1.85,
+    "Cd": 1.58,
+    "Cs": 2,
+    "Ca": 2,
+    "C": 1.7,
+    "Ce": 2,
+    "Cl": 1.75,
+    "Cr": 2,
+    "Co": 2,
+    "Cu": 1.4,
+    "Dy": 2,
+    "Er": 2,
+    "Eu": 2,
+    "F": 1.47,
+    "Gd": 2,
+    "Ga": 1.87,
+    "Ge": 2,
+    "Au": 1.66,
+    "Hf": 2,
+    "He": 1.4,
+    "Ho": 2,
+    "H": 1.09,
+    "In": 1.93,
+    "I": 1.98,
+    "Ir": 2,
+    "Fe": 2,
+    "Kr": 2.02,
+    "La": 2,
+    "Pb": 2.02,
+    "Li": 1.82,
+    "Lu": 2,
+    "Mg": 1.73,
+    "Mn": 2,
+    "Hg": 1.55,
+    "Mo": 2,
+    "Nd": 2,
+    "Ne": 1.54,
+    "Ni": 1.63,
+    "Nb": 2,
+    "N": 1.55,
+    "Os": 2,
+    "O": 1.52,
+    "Pd": 1.63,
+    "P": 1.8,
+    "Pt": 1.72,
+    "K": 2.75,
+    "Pr": 2,
+    "Pa": 2,
+    "Re": 2,
+    "Rh": 2,
+    "Rb": 2,
+    "Ru": 2,
+    "Sm": 2,
+    "Sc": 2,
+    "Se": 1.9,
+    "Si": 2.1,
+    "Ag": 1.72,
+    "Na": 2.27,
+    "Sr": 2,
+    "S": 1.8,
+    "Ta": 2,
+    "Te": 2.06,
+    "Tb": 2,
+    "Tl": 1.96,
+    "Th": 2,
+    "Tm": 2,
+    "Sn": 2.17,
+    "Ti": 2,
+    "W": 2,
+    "U": 1.86,
+    "V": 2,
+    "Xe": 2.16,
+    "Yb": 2,
+    "Y": 2,
+    "Zn": 1.29,
+    "Zr": 2,
+    "X": 1.0,
+    "D": 1.0,
 }
 
 # This dictionary gives easy access to the rdkit bond types.
 bond_dict = {
-    '1': rdkit.rdchem.BondType.SINGLE,
-    'am': rdkit.rdchem.BondType.SINGLE,
-    '2': rdkit.rdchem.BondType.DOUBLE,
-    '3': rdkit.rdchem.BondType.TRIPLE,
-    'ar': rdkit.rdchem.BondType.AROMATIC
+    "1": rdkit.rdchem.BondType.SINGLE,
+    "am": rdkit.rdchem.BondType.SINGLE,
+    "2": rdkit.rdchem.BondType.DOUBLE,
+    "3": rdkit.rdchem.BondType.TRIPLE,
+    "ar": rdkit.rdchem.BondType.AROMATIC,
 }
 
 # A dictionary which matches atomic number to elemental symbols.
 periodic_table = {
-    1: 'H', 2: 'He', 3: 'Li', 4: 'Be', 5: 'B', 6: 'C',
-    7: 'N', 8: 'O', 9: 'F', 10: 'Ne', 11: 'Na', 12: 'Mg',
-    13: 'Al', 14: 'Si', 15: 'P', 16: 'S', 17: 'Cl',
-    18: 'Ar', 19: 'K', 20: 'Ca', 21: 'Sc', 22: 'Ti',
-    23: 'V', 24: 'Cr', 25: 'Mn', 26: 'Fe', 27: 'Co',
-    28: 'Ni', 29: 'Cu', 30: 'Zn', 31: 'Ga', 32: 'Ge',
-    33: 'As', 34: 'Se', 35: 'Br', 36: 'Kr', 37: 'Rb',
-    38: 'Sr', 39: 'Y', 40: 'Zr', 41: 'Nb', 42: 'Mo',
-    43: 'Tc', 44: 'Ru', 45: 'Rh', 46: 'Pd', 47: 'Ag',
-    48: 'Cd', 49: 'In', 50: 'Sn', 51: 'Sb', 52: 'Te',
-    53: 'I', 54: 'Xe', 55: 'Cs', 56: 'Ba', 57: 'La',
-    58: 'Ce', 59: 'Pr', 60: 'Nd', 61: 'Pm', 62: 'Sm',
-    63: 'Eu', 64: 'Gd', 65: 'Tb', 66: 'Dy', 67: 'Ho',
-    68: 'Er', 69: 'Tm', 70: 'Yb', 71: 'Lu', 72: 'Hf',
-    73: 'Ta', 74: 'W', 75: 'Re', 76: 'Os', 77: 'Ir',
-    78: 'Pt', 79: 'Au', 80: 'Hg', 81: 'Tl', 82: 'Pb',
-    83: 'Bi', 84: 'Po', 85: 'At', 86: 'Rn', 87: 'Fr',
-    88: 'Ra', 89: 'Ac', 90: 'Th', 91: 'Pa', 92: 'U',
-    93: 'Np', 94: 'Pu', 95: 'Am', 96: 'Cm', 97: 'Bk',
-    98: 'Cf', 99: 'Es', 100: 'Fm', 101: 'Md', 102: 'No',
-    103: 'Lr', 104: 'Rf', 105: 'Db', 106: 'Sg', 107: 'Bh',
-    108: 'Hs', 109: 'Mt', 110: 'Ds', 111: 'Rg', 112: 'Cn',
-    113: 'Uut', 114: 'Fl', 115: 'Uup', 116: 'Lv',
-    117: 'Uus', 118: 'Uuo'
+    1: "H",
+    2: "He",
+    3: "Li",
+    4: "Be",
+    5: "B",
+    6: "C",
+    7: "N",
+    8: "O",
+    9: "F",
+    10: "Ne",
+    11: "Na",
+    12: "Mg",
+    13: "Al",
+    14: "Si",
+    15: "P",
+    16: "S",
+    17: "Cl",
+    18: "Ar",
+    19: "K",
+    20: "Ca",
+    21: "Sc",
+    22: "Ti",
+    23: "V",
+    24: "Cr",
+    25: "Mn",
+    26: "Fe",
+    27: "Co",
+    28: "Ni",
+    29: "Cu",
+    30: "Zn",
+    31: "Ga",
+    32: "Ge",
+    33: "As",
+    34: "Se",
+    35: "Br",
+    36: "Kr",
+    37: "Rb",
+    38: "Sr",
+    39: "Y",
+    40: "Zr",
+    41: "Nb",
+    42: "Mo",
+    43: "Tc",
+    44: "Ru",
+    45: "Rh",
+    46: "Pd",
+    47: "Ag",
+    48: "Cd",
+    49: "In",
+    50: "Sn",
+    51: "Sb",
+    52: "Te",
+    53: "I",
+    54: "Xe",
+    55: "Cs",
+    56: "Ba",
+    57: "La",
+    58: "Ce",
+    59: "Pr",
+    60: "Nd",
+    61: "Pm",
+    62: "Sm",
+    63: "Eu",
+    64: "Gd",
+    65: "Tb",
+    66: "Dy",
+    67: "Ho",
+    68: "Er",
+    69: "Tm",
+    70: "Yb",
+    71: "Lu",
+    72: "Hf",
+    73: "Ta",
+    74: "W",
+    75: "Re",
+    76: "Os",
+    77: "Ir",
+    78: "Pt",
+    79: "Au",
+    80: "Hg",
+    81: "Tl",
+    82: "Pb",
+    83: "Bi",
+    84: "Po",
+    85: "At",
+    86: "Rn",
+    87: "Fr",
+    88: "Ra",
+    89: "Ac",
+    90: "Th",
+    91: "Pa",
+    92: "U",
+    93: "Np",
+    94: "Pu",
+    95: "Am",
+    96: "Cm",
+    97: "Bk",
+    98: "Cf",
+    99: "Es",
+    100: "Fm",
+    101: "Md",
+    102: "No",
+    103: "Lr",
+    104: "Rf",
+    105: "Db",
+    106: "Sg",
+    107: "Bh",
+    108: "Hs",
+    109: "Mt",
+    110: "Ds",
+    111: "Rg",
+    112: "Cn",
+    113: "Uut",
+    114: "Fl",
+    115: "Uup",
+    116: "Lv",
+    117: "Uus",
+    118: "Uuo",
 }
 
 
-T = typing.TypeVar('T')
+T = typing.TypeVar("T")
 OneOrMany = typing.Union[T, typing.Iterable[T]]
 
 
 class Cell:
     """
     Represents an individual cell in a supercell.
 
@@ -160,26 +323,26 @@
 
     Returns
     -------
     None : :class:`NoneType`
 
     """
 
-    if 'output' not in os.listdir():
+    if "output" not in os.listdir():
         return
 
     # Make the ``stk_ea_runs`` folder if it does not exist already.
-    if 'stk_ea_runs' not in os.listdir():
-        os.mkdir('stk_ea_runs')
+    if "stk_ea_runs" not in os.listdir():
+        os.mkdir("stk_ea_runs")
 
     # Find out with what number the ``output`` folder should be
     # labelled within ``stk_ea_runs``.
-    num = len(os.listdir('stk_ea_runs'))
-    new_dir = os.path.join('stk_ea_runs', str(num))
-    os.rename('output', new_dir)
+    num = len(os.listdir("stk_ea_runs"))
+    new_dir = os.path.join("stk_ea_runs", str(num))
+    os.rename("output", new_dir)
 
 
 def dedupe(iterable, key=None, seen=None):
     """
     Yields items from `iterable` barring duplicates.
 
     If `seen` is provided it contains elements which are not to be
@@ -275,15 +438,15 @@
 
     """
 
     if excluded_types is None:
         excluded_types = {str}
 
     for x in iterable:
-        if hasattr(x, '__iter__') and type(x) not in excluded_types:
+        if hasattr(x, "__iter__") and type(x) not in excluded_types:
             yield from flatten(x, excluded_types)
         else:
             yield x
 
 
 def kabsch(coords1, coords2):
     """
@@ -369,72 +532,92 @@
         An ``rdkit`` instance of the molecule held in `mae_file`.
 
     """
 
     mol = rdkit.EditableMol(rdkit.Mol())
     conf = rdkit.Conformer()
 
-    with open(mae_path, 'r') as mae:
-        content = re.split(r'[{}]', mae.read())
+    with open(mae_path, "r") as mae:
+        content = re.split(r"[{}]", mae.read())
 
-    prev_block = deque([''], maxlen=1)
+    prev_block = deque([""], maxlen=1)
     for block in content:
-        if 'm_atom[' in prev_block[0]:
+        if "m_atom[" in prev_block[0]:
             atom_block = block
-        if 'm_bond[' in prev_block[0]:
+        if "m_bond[" in prev_block[0]:
             bond_block = block
         prev_block.append(block)
 
-    labels, data_block, *_ = atom_block.split(':::')
-    labels = [label for label in labels.split('\n')
-              if not label.isspace() and label != '']
-
-    data_block = [a.split() for a in data_block.split('\n') if
-                  not a.isspace() and a != '']
+    labels, data_block, *_ = atom_block.split(":::")
+    labels = [
+        label
+        for label in labels.split("\n")
+        if not label.isspace() and label != ""
+    ]
+
+    data_block = [
+        a.split()
+        for a in data_block.split("\n")
+        if not a.isspace() and a != ""
+    ]
 
     for line in data_block:
         line = [word for word in line if word != '"']
         if len(labels) != len(line):
-            raise RuntimeError(('Number of labels does'
-                                ' not match number of columns'
-                                ' in .mae file.'))
+            raise RuntimeError(
+                (
+                    "Number of labels does"
+                    " not match number of columns"
+                    " in .mae file."
+                )
+            )
 
         for label, data in zip(labels, line):
-            if 'x_coord' in label:
+            if "x_coord" in label:
                 x = float(data)
-            if 'y_coord' in label:
+            if "y_coord" in label:
                 y = float(data)
-            if 'z_coord' in label:
+            if "z_coord" in label:
                 z = float(data)
-            if 'atomic_number' in label:
+            if "atomic_number" in label:
                 atom_num = int(data)
 
         atom_sym = periodic_table[atom_num]
         atom_coord = Point3D(x, y, z)
         atom_id = mol.AddAtom(rdkit.Atom(atom_sym))
         conf.SetAtomPosition(atom_id, atom_coord)
 
-    labels, data_block, *_ = bond_block.split(':::')
-    labels = [label for label in labels.split('\n')
-              if not label.isspace() and label != '']
-    data_block = [a.split() for a in data_block.split('\n')
-                  if not a.isspace() and a != '']
+    labels, data_block, *_ = bond_block.split(":::")
+    labels = [
+        label
+        for label in labels.split("\n")
+        if not label.isspace() and label != ""
+    ]
+    data_block = [
+        a.split()
+        for a in data_block.split("\n")
+        if not a.isspace() and a != ""
+    ]
 
     for line in data_block:
         if len(labels) != len(line):
-            raise RuntimeError(('Number of labels does'
-                                ' not match number of '
-                                'columns in .mae file.'))
+            raise RuntimeError(
+                (
+                    "Number of labels does"
+                    " not match number of "
+                    "columns in .mae file."
+                )
+            )
 
         for label, data in zip(labels, line):
-            if 'from' in label:
+            if "from" in label:
                 atom1 = int(data) - 1
-            if 'to' in label:
+            if "to" in label:
                 atom2 = int(data) - 1
-            if 'order' in label:
+            if "order" in label:
                 bond_order = str(int(data))
         mol.AddBond(atom1, atom2, bond_dict[bond_order])
 
     mol = mol.GetMol()
     mol.AddConformer(conf)
     return mol
 
@@ -482,39 +665,43 @@
         new.SetFormalCharge(atom.GetFormalCharge())
         emol.AddAtom(new)
 
     for bond in mol.GetBonds():
         emol.AddBond(
             beginAtomIdx=bond.GetBeginAtomIdx(),
             endAtomIdx=bond.GetEndAtomIdx(),
-            order=bond.GetBondType()
+            order=bond.GetBondType(),
         )
 
     m = emol.GetMol()
     m.AddConformer(mol.GetConformer())
     return m
 
 
 def get_projection(start, target):
     """
     Get the projection of `start` onto `target`.
 
     """
 
-    return target * np.dot(
-        start,
-        target,
-    ) / np.dot(target, target)
+    return (
+        target
+        * np.dot(
+            start,
+            target,
+        )
+        / np.dot(target, target)
+    )
 
 
 def orthogonal_vector(vector):
-    ortho = np.array([0., 0., 0.])
+    ortho = np.array([0.0, 0.0, 0.0])
     for m, val in enumerate(vector):
         if not np.allclose(val, 0, atol=1e-8):
-            n = (m+1) % 3
+            n = (m + 1) % 3
             break
     ortho[n] = vector[m]
     ortho[m] = -vector[n]
     return ortho
 
 
 def rotation_matrix(vector1, vector2):
@@ -551,28 +738,23 @@
     # Hande the case where the input and output vectors are equal.
     if np.allclose(vector1, vector2, atol=1e-8):
         return np.identity(3)
 
     # Handle the case where the rotation is 180 degrees.
     if np.allclose(vector1, np.multiply(vector2, -1), atol=1e-8):
         return rotation_matrix_arbitrary_axis(
-            angle=np.pi,
-            axis=orthogonal_vector(vector1)
+            angle=np.pi, axis=orthogonal_vector(vector1)
         )
 
     v = np.cross(vector1, vector2)
-    vx = np.array([
-        [0, -v[2], v[1]],
-        [v[2], 0, -v[0]],
-        [-v[1], v[0], 0]
-    ])
+    vx = np.array([[0, -v[2], v[1]], [v[2], 0, -v[0]], [-v[1], v[0], 0]])
     s = np.linalg.norm(v)
     c = np.dot(vector1, vector2)
     i = np.identity(3)
-    mult_factor = (1-c)/np.square(s)
+    mult_factor = (1 - c) / np.square(s)
 
     # Initialize as a scipy Rotation object, which normalizes the
     # matrix and allows for returns as quaternion or alternative
     # type in the future.
     return Rotation.from_matrix(
         i + vx + np.multiply(np.dot(vx, vx), mult_factor)
     ).as_matrix()
@@ -595,37 +777,35 @@
     Returns
     -------
     :class:`numpy.ndarray`
         A ``3x3`` array representing a rotation matrix.
 
     """
 
-    a = np.cos(angle/2)
-    b, c, d = axis * np.sin(angle/2)
+    a = np.cos(angle / 2)
+    b, c, d = axis * np.sin(angle / 2)
 
     e11 = np.square(a) + np.square(b) - np.square(c) - np.square(d)
-    e12 = 2*(b*c - a*d)
-    e13 = 2*(b*d + a*c)
+    e12 = 2 * (b * c - a * d)
+    e13 = 2 * (b * d + a * c)
 
-    e21 = 2*(b*c + a*d)
+    e21 = 2 * (b * c + a * d)
     e22 = np.square(a) + np.square(c) - np.square(b) - np.square(d)
-    e23 = 2*(c*d - a*b)
+    e23 = 2 * (c * d - a * b)
 
-    e31 = 2*(b*d - a*c)
-    e32 = 2*(c*d + a*b)
+    e31 = 2 * (b * d - a * c)
+    e32 = 2 * (c * d + a * b)
     e33 = np.square(a) + np.square(d) - np.square(b) - np.square(c)
 
     # Initialize as a scipy Rotation object, which normalizes the
     # matrix and allows for returns as quaternion or alternative
     # type in the future.
-    return Rotation.from_matrix(np.array([
-        [e11, e12, e13],
-        [e21, e22, e23],
-        [e31, e32, e33]
-    ])).as_matrix()
+    return Rotation.from_matrix(
+        np.array([[e11, e12, e13], [e21, e22, e23], [e31, e32, e33]])
+    ).as_matrix()
 
 
 def dice_similarity(mol1, mol2, fp_radius=3):
     """
     Return the chemical similarity between two molecules.
 
     Parameters
@@ -648,22 +828,20 @@
     """
 
     rdkit_mol1 = mol1.to_rdkit_mol()
     rdkit.SanitizeMol(rdkit_mol1)
     fp1 = rdkit.GetMorganFingerprint(
         mol=rdkit_mol1,
         radius=fp_radius,
-
     )
     rdkit_mol2 = mol2.to_rdkit_mol()
     rdkit.SanitizeMol(rdkit_mol2)
     fp2 = rdkit.GetMorganFingerprint(
         mol=rdkit_mol2,
         radius=fp_radius,
-
     )
     return rdkit.DataStructs.DiceSimilarity(fp1, fp2)
 
 
 def quaternion(u):
     """
     Returns a translation + rotation quaternion.
@@ -679,18 +857,18 @@
     K. Shoemake, Uniform random rotations, Graphics Gems III,
     pages 124-132. Academic, New York, 1992.
 
     """
 
     a, b, c = u
     q = np.zeros(4, np.float64)
-    q[0] = np.sqrt(1. - a) * np.sin(2. * np.pi * b)
-    q[1] = np.sqrt(1. - a) * np.cos(2. * np.pi * b)
-    q[2] = np.sqrt(a) * np.sin(2. * np.pi * c)
-    q[3] = np.sqrt(a) * np.cos(2. * np.pi * c)
+    q[0] = np.sqrt(1.0 - a) * np.sin(2.0 * np.pi * b)
+    q[1] = np.sqrt(1.0 - a) * np.cos(2.0 * np.pi * b)
+    q[2] = np.sqrt(a) * np.sin(2.0 * np.pi * c)
+    q[3] = np.sqrt(a) * np.cos(2.0 * np.pi * c)
     return q
 
 
 def translation_component(q):
     """
     Extracts translation vector from quaternion.
 
@@ -704,23 +882,23 @@
     :class:`numpy.ndarray`
         The translation vector encoded within `q`.
 
     """
 
     rot_epsilon = 1e-6
     q = np.copy(q)
-    if q[0] < 0.:
+    if q[0] < 0.0:
         q = -q
     if q[0] > 1.0:
         q /= np.sqrt(np.dot(q, q))
 
-    theta = 2. * np.arccos(q[0])
-    s = np.sqrt(1. - q[0] * q[0])
+    theta = 2.0 * np.arccos(q[0])
+    s = np.sqrt(1.0 - q[0] * q[0])
     if s < rot_epsilon:
-        p = 2. * q[1:4]
+        p = 2.0 * q[1:4]
     else:
         p = q[1:4] / s * theta
     return p
 
 
 def tar_output():
     """
@@ -728,23 +906,23 @@
 
     Returns
     -------
     None : :class:`NoneType`
 
     """
 
-    tname = os.path.join('output', 'output.tgz')
-    with tarfile.open(tname, 'w:gz') as tar:
-        tar.add('output')
+    tname = os.path.join("output", "output.tgz")
+    with tarfile.open(tname, "w:gz") as tar:
+        tar.add("output")
 
 
 def _printer(time_taken):
     m, s = divmod(time_taken, 60)
     h, m = divmod(m, 60)
-    print(f'\nTime taken was {int(h)} : {int(m)} : {int(s)}.\n\n')
+    print(f"\nTime taken was {int(h)} : {int(m)} : {int(s)}.\n\n")
 
 
 @contextmanager
 def time_it(output=_printer):
     """
     Times the code executed within the indent.
 
@@ -818,33 +996,33 @@
     -------
     :class:`float`
         The angle between `vector1` and `vector2` in radians.
 
     """
 
     if np.all(np.equal(vector1, vector2)):
-        return 0.
+        return 0.0
 
     numerator = np.dot(vector1, vector2)
     denominator = np.linalg.norm(vector1) * np.linalg.norm(vector2)
     # This if statement prevents returns of NaN due to floating point
     # inaccuracy.
-    term = numerator/denominator
-    if term >= 1.:
+    term = numerator / denominator
+    if term >= 1.0:
         return 0.0
-    if term <= -1.:
+    if term <= -1.0:
         return np.pi
     return np.arccos(term)
 
 
 def get_acute_vector(reference, vector):
     if (
         # vector_angle is NaN if reference is [0, 0, 0].
         not np.allclose(reference, [0, 0, 0], atol=1e-5)
-        and vector_angle(vector, reference) > np.pi/2
+        and vector_angle(vector, reference) > np.pi / 2
     ):
         return vector * -1
     return vector
 
 
 def get_plane_normal(points):
     centroid = points.sum(axis=0) / len(points)
```

